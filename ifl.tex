\documentclass{jarticle}
\usepackage{mathrsfs}
\usepackage[dvipdfmx]{graphicx}
\usepackage{stmaryrd}

\title{Implementing Functional Languages: a tutorial}

\author{Simon L Peyton Jones and David R Lester}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\begin{abstract}
\end{abstract}
\newpage

\section*{序文}

この本は、遅延グラフ簡約を使用して非正格な関数型言語の実装を理解するための実用的なアプローチを提供します。
この本は、読者がいくつかの重要なコンパイラを開発、変更、および実験するのを支援することにより、
関数型言語の実装を「生きた」ものにするのに役立つ実用的なラボワーク資料のソースとなることを目的としています。
\vskip\baselineskip

この本の珍しい側面は、それが読むだけでなく実行されることを意図しているということです。
各実装手法の抽象的な説明を提示するだけでなく、主要な各メソッドの完全に機能するプロトタイプのコードを提示し、一連の改善を行います。

\subsection*{本書の概要}

この本の主な内容は、コア言語と呼ばれる小さな関数型言語の一連の実装です。
コア言語は可能な限り小さく設計されているため、実装は簡単ですが、効率を損なうことなく最新の非厳密な関数型言語をコア言語に変換できるほどrichです。
これについては、第1章で詳しく説明します。この章では、コア言語用のパーサとプリティプリンタも開発しています。
\vskip\baselineskip

Appendix Bには、本書全体でテストプログラムとして使用するためのコア言語プログラムのセレクションが含まれています。
\vskip\baselineskip

本書の本文は、コア言語の4つの異なる実装で構成されています。

\begin{itemize}
	\item 第2章では、\textbf{テンプレートのインスタンス化}に基づいた最も直接的な実装について説明します。
	\item 第3章では、\textbf{Gマシン}を紹介し、プログラムを一連の命令(Gコード)にコンパイルして、さらにマシンコードに変換する方法を示します。
	\item 第4章では、評価モデルがGマシンの評価モデルとは大きく異なる、異なる抽象マシンである\textbf{Three Instruction Machine}(TIM)についても同じ演習を繰り返します。
	      TIMはGマシンよりも最近開発されたため、他の文献はほとんどありません。
	      したがって、第4章には、Gマシンに与えられたものよりもかなり詳細なTIMの評価モデルの開発が含まれています。
	\item 後に、第5章では、\textbf{並列Gマシン}用の関数型プログラムをコンパイルする方法を示すことにより、新しい次元を追加します。
\end{itemize}

これらの実装のそれぞれについて、\textbf{コンパイラ}と\textbf{マシンインタープリタ}の2つの主要部分について説明します。
コンパイラはコア言語プログラムを受け取り、それをマシンインタープリタによる実行に適した形式に変換します。
\vskip\baselineskip

マシンインタープリタは、コンパイルされたプログラムの実行をシミュレートします。
いずれの場合も、インタープリタは\textbf{状態遷移システム}としてモデル化されているため、マシンインタープリタと「実際の」実装の間には非常に明確な関係があります。
図1は、実装の構造をまとめたものです。
\vskip\baselineskip

コア言語が制限されている重要な方法の1つは、ローカル関数定義がないことです。
\textbf{ラムダリフティング}と呼ばれるよく知られた変換があります。
これは、ローカル関数定義をグローバル関数定義に変換し、ローカル関数定義を自由に記述して後で変換できるようにします。
第6章では、適切なラムダリフターを開発します。
この章は、標準的な資料の単なる再提示ではありません。
\textbf{完全なlaziness}は、以前はラムダリフティングと切り離せないと見なされていた関数型プログラムの特性です。
第6章では、それらが実際にはまったく異なることを示し、ラムダリフティングとは別のパスで完全なlazinessを実装する方法を示します。
\vskip\baselineskip

この本全体を通して、Appendix Aで定義されている多くのユーティリティ関数とデータ型を使用しています。
\vskip\baselineskip

一部のセクションと演習はもう少し進んでおり、大きな損失なしに省略されています。
それらは短剣で識別されます、したがって：\dag

\subsection*{プロトタイピング言語}

実装を作成するためにどの言語を使用するかという問題が発生します。
既存の関数型言語であるMiranda \footnote{Mirandaは、Research SoftwareLtdの商標です。} を使用することを選択しました。
関数型言語の主な用途の1つは、ラピッドプロトタイピングです。
これにより、管理の詳細にとらわれることなく、プロトタイプの基本的な側面を表現できるようになります。
この本がこの主張を立証するための大きな例として役立つことを願っています。
さらに、この本を通して作業することは、実質的な関数型プログラムを書くことの有用な経験を提供するはずです。
\vskip\baselineskip

この本は関数型プログラミングの入門書ではありません。
すでに関数型言語でプログラミングを行っていることを前提としています。
(関数型プログラミングの適切な紹介には、[Bird and Wadler1988]および[Holyer1991]が含まれます。)
それにもかかわらず、この本で開発されたプログラムは非常に充実しており、
明確でモジュール式の関数型プログラムを作成する能力を伸ばし、
開発するためのロールモデルとして役立つことを願っています。
\vskip\baselineskip

Mirandaコードは、「逆コメント規則」を使用してタイプライターファウントで記述されています。
たとえば、リストの長さを取る関数の定義は次のとおりです。

\begin{verbatim}
> length [] = 0
> length (x : xs) = 1 + length xs
\end{verbatim}

左マージンの\begin{verbatim}>\end{verbatim}マークは、これが実行可能なMirandaコードの行であることを示します。

\subsection*{本書がカバーしていないこと}

この本では、関数型コンパイラの「バックエンド」にのみ焦点を当てています。
Mirandaなどの本格的な関数型言語で書かれたプログラムをコア言語に翻訳する方法や、そのようなプログラムの型チェック方法については議論しません。
\vskip\baselineskip

全体の開発は非形式です。
コアプログラムの意味とその実装が同等であることを正式に証明するのは良いことですが、これは非常に難しい作業です。
確かに、私たちが知っているそのような同等性の唯一の完全な証明は[Lester 1988]です。

\subsection*{「The implementation of functional programming languages」との関係}

私たちの1人による以前の本[Peyton Jones 1987]は、これと同様の資料をカバーしていますが、あまり実用的ではありません。
私たちの意図は、学生が他の本を参照せずに、現在の本だけを使用して関数型言語の実装に関するコースをたどることができるようにすることです。
\vskip\baselineskip

この本の範囲はやや控えめで、[Peyton Jones 1987]のパート2とパート3に対応しています。
後者のパート1では、高レベルの関数型言語をコア言語に変換する方法について説明していますが、ここではまったく取り上げていません。

\subsection*{ソースコードの取得}

\subsection*{間違いを見つけたら}
\newpage

\section{コア言語}

すべての実装は、単純なコア言語で記述されたプログラムを使用して実行します。
コア言語は非常に貧弱であり、大きなプログラムを書きたくないでしょう。
それでも、表現力や効率を損なうことなく、豊富な関数型言語(Mirandaなど)のプログラムをコア言語に翻訳できるように慎重に選択されています。
したがって、コア言語は、高水準言語構造に関係するコンパイラの「フロントエンド」と、
さまざまな異なる方法でコア言語を実装することに関係する「バックエンド」との間のクリーンなインターフェースとして機能します。
\vskip\baselineskip

まず、コア言語の非公式な紹介から始めます(セクション\ref{sec_1_1})。
これに続いて、次のようにしてコア言語をより正式に定義します。

\begin{itemize}
	\item その構文(セクション\ref{sec_1_2})。
	\item Mirandaのデータ型coreProgramとcoreExprは、それぞれコア言語のプログラムと式です(セクション\ref{sec_1_3})。これらは、ビルドするコンパイラの入力データ型として機能します。
	\item コア言語関数の小さな標準プレリュードの定義。これは、すべてのコアプログラムで利用できるようになります(セクション\ref{sec_1_4})。
	\item コア言語プログラムを文字列に変換するプリティプリンタ。印刷すると、プログラムのフォーマットされたバージョンになります(セクション\ref{sec_1_5})。
	\item 文字列を解析してコア言語プログラムを生成するパーサ(セクション\ref{sec_1_6})。
\end{itemize}

この章には2番めの目的があります。関数型言語の実装に関与する前に、本全体で使用するMirandaの機能の多くを紹介して使用します。

\subsection{コア言語の概要} \label{sec_1_1}

これは、42と評価されるコアプログラム\footnote{コアプログラムにはタイプライターフォントを使用しますが、実行可能なMirandaコードを区別する最初の$\texttt{>}$記号はありません。}の例です。

\begin{verbatim}
        main = double 21
        double x = x + x
\end{verbatim}

コアプログラムは、主要なものを含む一連の\textbf{スーパーコンビネータ定義}で構成されています。
プログラムを実行するために、\texttt{main}を評価します。
スーパーコンビネータは、\texttt{double}の定義などの機能を定義できます。
\texttt{double}は、1つの引数\texttt{x}の関数であり、引数の2倍を返します。
プログラムは、関数の引数にパターンマッチングが許可されていないことを除いて、Mirandaスクリプトのトップレベルと非常によく似ています。
パターンマッチングは、別のコア言語構造である\texttt{case}式によって実行されます。
これについては、以下で説明します。
各スーパーコンビネータは、引数がすべて単純な変数である単一の等式によって定義されます。
\vskip\baselineskip
すべてのスーパーコンビネータに引数があるわけではないことに注意してください。
\texttt{main}など一部のスーパーコンビネータは引数を取りません。
引数のないスーパーコンビネータは、\textbf{定数適用形式}またはCAFとも呼ばれ、後で説明するように、実装では特別な処理が必要になることがよくあります。

\subsubsection{ローカル定義}

スーパーコンビネータは、コア言語の\texttt{let}構造を使用して、ローカル定義を持つことができます。

\begin{verbatim}
        main = quadruple 20 ;
        quadruple x = let twice_x = x+x
                      in twice_x + twice_x
\end{verbatim}

ここで、\texttt{twice\_x}は\texttt{quadruple}の本体内でローカルに\texttt{x+x}と定義され、\texttt{quadruple}は\texttt{twice\_x + twice\_x}を返します。
Mirandaの\texttt{where}句と同様に、ローカル定義は、
中間値に名前を付けることと、同じ値を2回再計算することを節約することの両方に役立ちます。
プログラマーは、\texttt{quadruple}で2つの加算だけが実行されることを合理的に期待できます。
\vskip\baselineskip
\texttt{let}式は\textbf{非再帰的}です。
再帰的定義の場合、コア言語は\texttt{letrec}構造を使用します。
これは、定義が再帰的である可能性があることを除いて、\texttt{let}とまったく同じです。
例えば:

\begin{verbatim}
        infinite n = letrec ns = cons n ns
                     in ns
\end{verbatim}

(\texttt{letrec}だけを提供するのではなく)コア言語で\texttt{let}と\texttt{letrec}を区別する理由は、
\texttt{let}は\texttt{letrec}よりも実装が少し簡単であり、コードが少し良くなる可能性があるためです。
\vskip\baselineskip
\texttt{let}と\texttt{letrec}はMirandaの\texttt{where}句に似ていますが、いくつかの重要な違いがあります。

\begin{itemize}
	\item \texttt{where}句は、常に再帰スコープを定義します。非再帰的な形式はありません。
	\item \texttt{where}句を使用して、ローカル関数を定義し、パターンマッチングを実行できます。
	      \begin{verbatim}
        ... where f x = x+y
                  (p,q) = zip xs ys
\end{verbatim}
	      これらの機能はどちらも、コア言語の\texttt{let}および\texttt{letrec}式では提供されません。
	      \vskip\baselineskip
	      関数はスーパーコンビネータとしてトップレベルでのみ定義でき、パターンマッチングは\texttt{case}式によってのみ実行されます。
	      \vskip\baselineskip
	      \textbf{つまり、\texttt{let}または\texttt{letrec}バインディングの左側は単純な変数でなければなりません。}
	\item \texttt{let}/\texttt{letrec}構造は\textbf{式}です。したがって、次のように書くことは非常に合法です(例えば):
	      \begin{verbatim}
        quad_plus_one x = 1 + (let tx = x+x in tx+tx)
\end{verbatim}
	      対称的に、Mirandaの\texttt{where}句は、\textbf{定義}にのみ付加できます。
	      (この理由の1つは、Mirandaの\texttt{where}句の定義がいくつかのガードされた右辺に及ぶことを可能にすることです。)
\end{itemize}

\subsubsection{ラムダ抽象化}

関数は通常、トップレベルの-スーパーコンビネータ定義を使用してコア言語で表現されます。
ほとんどの本では、これが関数を表す表す表す唯一の方法です。
ただし、明示的な\textbf{ラムダ抽象化}を使用して関数を指定できると便利な場合があり、コア言語はそのための構造を提供します。
たとえば、次のプログラムで

\begin{verbatim}
        double_list xs = map (\ x. 2*x) xs
\end{verbatim}

ラムダ抽象化\texttt{(\textbackslash ~ x. 2*x)}は、引数を2倍にする関数を示します。
\vskip\baselineskip
明示的なラムダ抽象化を含むプログラムを、トップレベルのスーパーコンビネータ定義のみを使用する同等のプログラムに変換することができます。
このプロセスは\textbf{ラムダリフティング}と呼ばれ、第6章で詳しく説明します。
他の章では、このラムダリフティングプロセスが実行されたと想定しているため、明示的なラムダ抽象化を使用していません。
\vskip\baselineskip
コア言語の最後の主要な構成要素は,パターンマッチングを表す\texttt{case}式です。
パターンマッチングを処理する方法はいくつかあるため、構造化データ型の確認から始めます。

\subsubsection{構造化データ型} \label{sec_1_1_3}

最新の関数型プログラミング言語すべての普遍的な機能は、\textbf{代数的データ型}と呼ばれることが多い\textbf{構造化型}の提供です。
たとえば、Mirandaで書かれたいくつかの代数的型の定義は次のとおりです。

\begin{verbatim}
        colour ::= Red | Green | Blue

        complex ::= Rect num num | Polar num num

        numPair ::= MkNumPair num num

        tree * ::= Leaf * | Branch (tree *) (tree *)
\end{verbatim}

各定義は、1つ以上の\textbf{コンストラクタ}(\texttt{Red}, \texttt{Green}など)とともに、新しい\textbf{型}(\texttt{colour}など)を導入します。
それらは次のように読むことができます:
「\texttt{colour}型の値は\texttt{Red}または\texttt{Green}または\texttt{Blue}のいずれかです」、
および「\texttt{complex}は2つの\texttt{num}を含む\texttt{Rect}、または2つの\texttt{num}を含む\texttt{Polar}のいずれかです」。
\vskip\baselineskip
型\texttt{tree}は、\textbf{パラメータ化された}代数的データ型の例です。
型\texttt{tree}は、型変数\texttt{*}に関してパラメータ化されます。
次のように読む必要があります。
「\texttt{*}の\texttt{tree}」sは、\texttt{*}を含む\texttt{Leaf}、または\texttt{*}の2つの\texttt{tree}「s」を含む\texttt{Branch}のいずれかです。
特定の\texttt{tree}には、同じ型の\texttt{Leaf}が必要です。
たとえば、型\texttt{tree num}は、\texttt{Leaf}に\texttt{num}がある\texttt{tree}であり、
型\texttt{tree colour}は、\texttt{Leaf}に\texttt{colour}がある\texttt{tree}です。

構造化された値は、これらのコンストラクタを使用して構築されます。
たとえば、次の式は構造化された値を示します。

\begin{verbatim}
        Green
        Rect 3 4
        Branch (Leaf num) (Leaf num)
\end{verbatim}

構造化された値は、\textbf{パターンマッチング}を使用して\textbf{分解}されます。
例えば:

\begin{verbatim}
        isRed Red = True
        isRed Green = False
        isRed Blue = False

        first (MkNumPair n1 n2) = n1

        depth (Leaf n) = 0
        depth (Branch t1 t2) = 1 + max (depth t1) (depth t2)
\end{verbatim}

通常「組み込み」とみなされるいくつかのデータ型は、構造化型の特殊なケースにすぎません。
例えば、ブール値は構造化型です。
代数的データ型宣言によって定義できます。

\begin{verbatim}
        bool ::= False | True
\end{verbatim}

特別な構文とは別に、Mirandaが提供するリストとタプルは構造化型のさらなる例です。
\texttt{:}と\texttt{[]}の特別な構文ではなく、コンストラクタとして\texttt{Cons}と\texttt{Nil}を使用する場合、次のようなリストを定義できます。

\begin{verbatim}
        list * ::= Nil | Cons * (list *)
\end{verbatim}

[Peyton Jones 1987]の第4章では、構造化型について詳しく説明しています。
従って、疑問が生じます。
\textbf{小さなコア言語で構造化型をどのように表現および操作するのでしょうか。}
特に、私たちの目標は、コア言語でのデータ型宣言を完全に回避することです。
私たちが採用するアプローチは、2つの部分に別れています。

\begin{itemize}
	\item コンストラクタには、単純で統一された表現を使用します。
	\item パターンマッチングを単純な\texttt{case}式に変換します。
\end{itemize}

\subsubsection{コンストラクタの表現} \label{sec_1_1_4}

コア言語で\texttt{Red}や\texttt{Branch}などのユーザ定義のコンストラクタを許可する代わりに、コンストラクタの単一ファミリ
\begin{center}
	\texttt{Pack\{\textit{tag}, \textit{arity}\}}
\end{center}
を提供します。

ここで、\textbf{tag}はコンストラクタを一意に識別する整数であり、\textbf{arity}はそれが取る引数の数を示します。
たとえば、\texttt{colour}、\texttt{complex}、\texttt{tree}、\texttt{numPair}のコンストラクタを次のように表すことができます。
\begin{verbatim}
        Red       = Pack{1, 0}
        Green     = Pack{2, 0}
        Blue      = Pack{3, 0}

        Rect      = Pack{4, 2}
        Polar     = Pack{5, 2}

        Leaf      = Pack{6, 1}
        Branch    = Pack{7, 2}

        MkNumPair = Pack{8, 2}
\end{verbatim}

したがって、コア言語では、
\begin{verbatim}
        Branch (Leaf 3) (Leaf 4)
\end{verbatim}
の代わりに
\begin{verbatim}
        Pack{7,2} (Pack{6,1} 3) (Pack{6,1} 4)
\end{verbatim}
と記述します。
このtagは、異なるコンストラクタで作成されたオブジェクトを互いに区別できるようにするためです。
適切に型指定されたプログラムでは、実行時に異なる型のオブジェクトを区別する必要画ないため、tagは\textbf{データ型内で}一意である必要があります。
したがって、新しいデータ型ごとに1からtagを新たに開始して、次の表現を与えることができます。
\begin{verbatim}
        Red       = Pack{1, 0}
        Green     = Pack{2, 0}
        Blue      = Pack{3, 0}

        Rect      = Pack{1, 2}
        Polar     = Pack{2, 2}

        Leaf      = Pack{1, 1}
        Branch    = Pack{2, 2}

        MkNumPair = Pack{1, 2}
\end{verbatim}

\subsubsection{\texttt{case}式}

一般に、最新の関数型プログラミング言語で許可されているパターンマッチングは、複数のネストされたパターン、重複するパターン、ガードなど、かなり複雑になる可能性があります。
コア言語の場合、パターンマッチングのすべての複雑な形式を非合法化することにより、これらの複雑さを排除します。
これを行うには、コア言語では\texttt{case}\textbf{式}のみを提供します。
そられの正式な構文はセクション1.2に記載されていますが、いくつかの例を示します。

\begin{verbatim}
        isRed c = case c of
                        <1> -> True ;
                        <2> -> False ;
                        <3> -> False

        depth t = case t of
                        <1> n -> 0 ;
                        <2> t1 t2 -> 1 + max (depth t1) (depth t2)
\end{verbatim}

\texttt{case}式で重要なことは、各選択肢がタグとそれに続くいくつかの変数(コンストラクタのアリティと同じである必要があります)のみで構成されていることです。
ネストされたパターンは許可されていません。
\vskip\baselineskip
\texttt{case}式は、多方向ジャンプのように、非常に単純な操作上の解釈を持っています。
分析する式を評価し、それが構築されているコンストラクタのタグを取得して、適切な選択肢を評価します。
\newpage

\subsection{コア言語の構文} \label{sec_1_2}

図1.1に、コア言語の構文を示します。
文法では、中置二項演算子を使用できますが、（簡潔にするために）それらの優先順位については明示されていません。
代わりに、次の優先順位の表を示します。
優先順位が高いほど、バインディングが厳しくなります。
\vskip\baselineskip

\begin{tabular} {|c|c|l|} \hline
	優先度 & 結合の向き & 演算子                                                                          \\ \hline
	6      & 左結合     & 関数適用                                                                        \\
	5      & 右結合     & \texttt{*}                                                                      \\
	       & なし       & \texttt{/}                                                                      \\
	4      & 右結合     & \texttt{+}                                                                      \\
	       & なし       & \texttt{-}                                                                      \\
	3      & なし       & \texttt{==} ~ \texttt{~=} ~ \texttt{>} ~ \texttt{>=} ~ \texttt{<} ~ \texttt{<=} \\
	2      & 右結合     & \texttt{\&}                                                                     \\
	1      & 右結合     & \texttt{\textbar}                                                               \\ \hline
\end{tabular}
\vskip\baselineskip

演算子の結合法則は、演算子の繰り返しの前後で括弧を省略できる場合を決定します。
たとえば、\texttt{+}は右結合であるため、\texttt{x+y+z}は\texttt{x+(y+z)}と同じ意味です。
一方、\texttt{/}は結合多元環ではないため、式\texttt{x/y/z}は不正です。
\vskip\baselineskip
単項否定のための特別な演算子記号はありません。
代わりに、通常の関数と構文的に同じように動作する\texttt{negate}関数が提供されます。
例えば：

\begin{verbatim}
        f x = x + (negate x)
\end{verbatim}

ブール否定演算子\texttt{not}は、同じ方法で処理されます。

\begin{center}
	\begin{tabular} {|l r c l l|} \hline
		プログラム           & $program$ & $\rightarrow$ & $sc_1 \texttt{;} \ldots \texttt{;} ~ sc_n$                                                                                                                       & $n \geq 1$              \\
		スーパーコンビネータ & $sc$      & $\rightarrow$ & $var ~ var_1 \ldots var_n ~ = ~ expr$                                                                                                                            & $n \geq 0$              \\
		式                   & $expr$    & $\rightarrow$ & $expr ~ expr$                                                                                                                                                    & 関数適用                \\
		                     &           & \textbar      & $expr_1 ~ binop ~ expr_2$                                                                                                                                        & 中置2項演算             \\
		                     &           & \textbar      & $\texttt{let} ~ defns ~ \texttt{in} ~ expr$                                                                                                                      & 局所定義                \\
		                     &           & \textbar      & $\texttt{letrec} ~ defns ~ \texttt{in} ~ expr$                                                                                                                   & 局所再帰定義            \\
		                     &           & \textbar      & $\texttt{case} ~ expr ~ \texttt{of} ~ alts$                                                                                                                      & case式                  \\
		                     &           & \textbar      & $\texttt{\textbackslash} ~ var_1 \ldots var_n ~ \texttt{.} ~ expr$                                                                                               & ラムダ抽象 $(n \geq 1)$ \\
		                     &           & \textbar      & $aexpr$                                                                                                                                                          & 原子式                  \\
		                     &           &               &                                                                                                                                                                  &                         \\
		                     & $aexpr$   & $\rightarrow$ & $var$                                                                                                                                                            & 変数                    \\
		                     &           & \textbar      & $num$                                                                                                                                                            & 数値                    \\
		                     &           & \textbar      & $\texttt{Pack\{} num \texttt{,} num \texttt{\}}$                                                                                                                 & コンストラクタ          \\
		                     &           & \textbar      & $\texttt{(} ~ expr ~ \texttt{)}$                                                                                                                                 & 括弧で囲まれた式        \\
		                     &           &               &                                                                                                                                                                  &                         \\
		定義                 & $defns$   & $\rightarrow$ & $defn_1 \texttt{;} \ldots \texttt{;} ~ defn_n$                                                                                                                   & $n \geq 1$              \\
		                     & $defn$    & $\rightarrow$ & $var ~ \texttt{=} ~ expr$                                                                                                                                        &                         \\
		                     &           &               &                                                                                                                                                                  &                         \\
		選択肢               & $alts$    & $\rightarrow$ & $alt_1 ; \ldots ; ~ alt_n$                                                                                                                                       & $n \geq 1$              \\
		                     & $alt$     & $\rightarrow$ & $\texttt{<} num \texttt{>} ~ var_1 \ldots var_n ~ \texttt{->} ~ expr$                                                                                            & $n \geq 0$              \\
		                     &           &               &                                                                                                                                                                  &                         \\
		二項演算子           & $binop$   & $\rightarrow$ & $arithop$ ~ \textbar ~ $relop$ ~ \textbar ~ $boolop$                                                                                                             &                         \\
		                     & $arithop$ & $\rightarrow$ & $\texttt{+}$ ~ \textbar ~ $\texttt{-}$ ~ \textbar ~ $\texttt{*}$ ~ \textbar ~ $\texttt{/}$                                                                       & 算術演算子              \\
		                     & $relop$   & $\rightarrow$ & $\texttt{<}$ ~ \textbar ~ $\texttt{<=}$ ~ \textbar ~ $\texttt{==}$ ~ \textbar ~	$\texttt{\textasciitilde =}$ ~ \textbar ~ $\texttt{>=}$ ~ \textbar ~ $\texttt{>}$ & 比較演算子              \\
		                     & $boolop$  & $\rightarrow$ & $\texttt{\&}$ ~ \textbar ~ $\texttt{\textbar}$                                                                                                                   & 論理演算子              \\
		                     &           &               &                                                                                                                                                                  &                         \\
		変数                 & $var$     & $\rightarrow$ & $alpha ~ varch_1 ~ \ldots ~ varch_n$                                                                                                                             & $n \geq 0$              \\
		                     & $alpha$   & $\rightarrow$ & $an alphabetic character$                                                                                                                                        &                         \\
		                     & $varch$   & $\rightarrow$ & $alpha$ ~ \textbar ~ $digit$ ~ \textbar ~ \texttt{\_}                                                                                                            &                         \\
		                     &           &               &                                                                                                                                                                  &                         \\
		数値                 & $num$     & $\rightarrow$ & $digit_1 \ldots digit_n$                                                                                                                                         & $n \geq 1$              \\ \hline
	\end{tabular}
\end{center}
\newpage

\subsection{コア言語のデータ型} \label{sec_1_3}

この本で説明されている実装ごとに、コンパイラとマシンインタープリタを構築します。
コンパイラはコアプログラムを受け取り、それをマシンインタープリタによる実行に適した形式に変換します。
これを行うには、コアプログラムを表すMirandaデータ型が必要です。これを、このセクションで定義します。
実際、コアプログラム用の型、コア式用の型、およびその他のいくつかの補助的な型を定義します。
\vskip\baselineskip
コア言語式\texttt{expr}のデータ型は、次のように定義されます。

\begin{verbatim}
module Language where
import Utils

data Expr a
  =  EVar Name                    -- Variables
   | ENum Int                     -- Numbers
   | EConstr Int Int              -- Constructor tag arity
   | EAp (Expr a) (Expr a)        -- Applications
   | ELet                         -- Let(rec) expressions
        IsRec                     --   boolean with True = recursive,
        [(a, Expr a)]             --   Definitions
        (Expr a)                  --   Body of let(rec)
   | ECase                        -- Case expression
        (Expr a)                  --   Expression to scrutinise
        [Alter a]                 --   Alternatives
   | ELam [a] (Expr a)            -- Lambda abstraction
    deriving (Text)
\end{verbatim}

バインダに関して\texttt{expr}のデータ型をパラメータ化することを選択します。
バインダは、変数のバインディングオカレンスで使用される名前です。
つまり、\texttt{let(rec)}定義の左側、またはラムダ抽象化です。
コア言語式\texttt{expr}の型は、
宣言は、
「\texttt{*}の\texttt{expr}は、\texttt{name}含む\texttt{EVar}、
または$\ldots$、またはタイプ\texttt{*}の値のリストと\texttt{*}の\texttt{expr}を含む\texttt{ELam}のいずれかです」
と読み取ることができます。
\vskip\baselineskip
本書のほとんどの部分では、これらのバインディング位置で常に\texttt{name}を使用しているため、
\textbf{型シノニム}を使用して、通常使用するタイプである\texttt{coreExpr}のタイプを定義します。

\begin{verbatim}
type CoreExpr = Expr Name
\end{verbatim}
\newpage

\subsection{A small standard prelude} \label{sec_1_4}
\newpage

\subsection{コア言語用のプリティプリンタ} \label{sec_1_5}

\texttt{CoreProgram}型の値を取得したら、それを表示できると便利なことがよくあります。
Mirandaの組み込み機能は、ここではあまり役に立ちません。
たとえば、Mirandaプロンプトに応答して\texttt{preludeDefs}と入力すると、生成される出力を理解するのはかなり困難です。
(それを試してみてください。)
\vskip\baselineskip
必要なのは、次の型が付いた「プリティプリント」関数\texttt{pprint}です。

\begin{verbatim}
pprint :: CoreProgram -> String
\end{verbatim}

次に、\texttt{pprint preludeDefs}と入力して、印刷すると\texttt{preludeDefs}の適切にフォーマットされたバージョンのように見える文字のリストを取得することを期待できます。
このセクションの目標は、そのような関数を作成することです。
\vskip\baselineskip
プログラムの結果がリストの場合、Mirandaは通常、リスト項目をコンマで区切り、角かっこで囲んで印刷します。
ただし、プログラムの結果が\texttt{[char]}型の特殊なケースでは、Mirandaは角かっことコンマを付けずに「すべて押しつぶされた」リストを表示します。
たとえば、値\texttt{``Hi \textbackslash nthere''}は次のように表示されます。
\begin{verbatim}
        Hi
        there
\end{verbatim}
次のようには表示されません。
\begin{verbatim}
        ['H', 'i', '\n', 't', 'h', 'e', 'r', 'e']
\end{verbatim}
このようにして、\texttt{pprint}は出力フォーマットを完全に制御できます。

\subsubsection{文字列を使ったプリティプリンティング}

まず、コア言語の式に集中しましょう。
プリティプリンティング関数\texttt{pprExpr}が必要なように見えます。
次のように定義されています。

\begin{verbatim}
  pprExpr :: CoreExpr -> String
  pprExpr (ENum n) = show n
  pprExpr (EVar v) = v
  pprExpr (EAp e1 e2) = pprExpr e1 ++ " " ++ pprAExpr e2
\end{verbatim}

(現時点では、\texttt{pprExpr}のケースの多くを意図的に除外しています。)
\texttt{pprAExpr}の型は\texttt{pprExpr}と同じですが、変数または数値でない限り、式を括弧で囲む点が異なります。

\begin{verbatim}
  pprAExpr :: CoreExpr -> String
  pprAExpr e = isAtomicExpr e | pprExpr e
  pprAExpr e = otherwise | "(" ++ pprExpr e ++ ")"
\end{verbatim}

この方法で進めることはできますが、そうすることには深刻な問題があります。
プリティプリンタは、リスト連結関数\texttt{++}を大量に使用します。
次の例に示すように、これは非常に厄介なパフォーマンスをもたらす可能性があります。
次の式を考えてみましょう。

\begin{verbatim}
        (x1 ++ x2) ++ x3
\end{verbatim}

内側の\texttt{++}は\texttt{＃xs1}\footnote{\texttt{＃}関数は、リストの長さを取得するための標準のMiranda関数です。}に比例する時間がかかりますが、
外側の\texttt{++}は\texttt{xs1 ++ xs2}の長さに比例する時間がかかるため、合計時間は（2 * \texttt{＃xs1}）+ \texttt{＃xs2}になります。
一般に、このネストされたappendにさらにリストを追加した場合、コストは結果の長さの2次式になる可能性があります！
もちろん、式を逆に括弧でくくった場合、コストは結果の長さに比例しますが、残念ながら、きれいなプリンターでこれを保証することはできません。
\vskip\baselineskip

この効果を実証するために、最初に関数\texttt{mkMultiAp}を記述します。これにより、特定のサイズのサンプル式を簡単に作成できます。
呼び出し(\texttt{mkMultiAp} \textit{n e1 e2})は、式を表す\texttt{coreExpr}を生成します

\[
	e_1 ~ \underbrace{e_2 ~ e_2 \ldots e_2}_{n}
\]

\begin{verbatim}
  mkMultiAp :: Int -> CoreExpr -> CoreExpr -> CoreExpr
  mkMultiAp n e1 e2 = foldll EAp e1 (take n e2s)
                      where
                      e2s = e2 : e2s
\end{verbatim}

この定義では、 \texttt{take} は、リストの最初の $n$ 個の要素を取り、リストの残りを破棄する Miranda の標準関数です。
関数 \texttt{foldll} は標準関数であり、Appendix A\footnote{Mirandaのバージョンが異なればfoldlの定義も異なるため、
	Mirandaの標準関数\texttt{foldl}ではなく\texttt{foldll}を使用します。} で定義されています。
二項関数 $\otimes$、値 $acc$ およびリスト $xs = [x_1, ~ \ldots, ~ x_n]$ が与えられると、$\texttt{foldll} ~ \otimes ~ acc ~ xs$ は $acc'$ を計算します。

\[
	acc' = (\ldots ((acc ~ \otimes ~ x_1) ~ \otimes ~ x_2) ~ \otimes ~ \ldots ~ x_n)
\]

これを図1.2に示します。
\texttt{mkMultiAp}では、\texttt{foldll}を使用して\texttt{EAp}ノードの左分岐チェーンを構築します。
初期のアキュムレータ$acc$は\texttt{e1}であり、結合関数は\texttt{EAp}コンストラクターです。
最後に、\texttt{e2s}は無限のリスト\texttt{[e2, e2, ...]}です。
最初の\texttt{n}個の要素のみが\texttt{take}によって使用されます。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_1-2.png}

\begin{description}
	\item[演習 1.1] \texttt{n} のさまざまな値に対して、計算に必要なミランダのステップ数を測定します。

		\begin{verbatim}
    # (pprExpr (mkMultiAp n (EVar "f") (EVar "x")))
  \end{verbatim}

		(Miranda ディレクティブ \texttt{/ count} を使用して、Miranda に実行統計を出力するように指示できます。
		画面が巨大なプリントアウトでいっぱいにならないように、結果の長さをとります。)
		実行コストが \texttt{n} でどのように上昇するかを示すグラフをスケッチし、\texttt{n} に関してほぼ 2 次であることを確認します。
\end{description}

\subsubsection{プリティプリンティングのための抽象データ型}

コストが印刷されるプログラムのサイズの 2 倍になるプリティ プリンタは、明らかに容認できないので、それを回避する方法を見つけたほうがよいでしょう。
\vskip\baselineskip

この問題を 2 つの部分に分けることができます: \textbf{「実行したい操作は?」}と\textbf{「それらを実行する効率的な方法は?」}です。
他の言語と同様に、Miranda は抽象データ型を導入することでこの区別を明確にする方法を提供します。

\begin{verbatim}
  iNil     :: Iseq                 -- The empty iseq
  iStr     :: String -> Iseq       -- Turn a string into an iseq
  iAppend  :: Iseq -> Iseq -> Iseq -- Append two iseqs
  iNewline :: Iseq                 -- New line with indentation
  iIndent  :: Iseq -> Iseq         -- Indent an iseq
  iDisplay :: Iseq -> String       -- Turn an iseq into a string
\end{verbatim}

\texttt{abstype} キーワードは、抽象データ型 \texttt{iseq} を導入します。
その後に、データ型の\textbf{インターフェイス}が続きます。
つまり、データ型 \texttt{iseq} で実行できる操作と、各操作の型です。
\vskip\baselineskip

このようなデータ型が与えられた場合、\texttt{pprExpr} を書き直して、文字のリストではなく \texttt{iseq} を返すようにします。

\begin{verbatim}
  pprExpr :: CoreExpr -> Iseq
  pprExpr (EVar v)    = iStr v
  pprExpr (EAp e1 e2) = (pprExpr e1) `iAppend` (iStr " ") `iAppend` (pprAExpr e2)
\end{verbatim}

\texttt{++} を \texttt{iAppend}\footnote{Miranda では、識別子の前にドル記号を書くと、それが中置演算子に変わり、
	引数の前ではなく引数の間に \texttt{iAppend} を書くことができます。このような中置演算子は右結合です。} に単純に置き換え、
リテラル文字列の周りに \texttt{iStr} を追加しました。
\vskip\baselineskip

\texttt{iseq} と文字のリストの違いは何ですか?
まず、リスト追加の予想外の二次動作を持たない \texttt{iAppend} の実装を作成することを目指しています。
次に \texttt{iseq} は、インデントの制御に役立つ新しい操作 \texttt{iIndent} および \texttt{iNewline} を提供します。
アイデアは、\texttt{iIndent} がその引数をインデントして現在の列に揃えるというものです。
引数が何行にもわたっており、それ自体に \texttt{iIndent} の呼び出しが含まれている場合でも機能するはずです。
\texttt{iNewline} は、改行の後に、現在のインデント レベルによって決定されるいくつかのスペースが続くことを表します。
\vskip\baselineskip

\texttt{iIndent} と \texttt{iNewline} の使用方法の例として、\texttt{pprExpr} を拡張して \texttt{let} と \texttt{letrec} 式を処理してみましょう。

\begin{verbatim}
  pprExpr (ELet isrec defns expr)
    = iConcat [ iStr keyword, iNewline,
                iStr " ", iIndent (pprDefns defns), iNewline,
                iStr "in ", pprExpr expr ]
      where
        keyword | not isrec = "let"
                | isrec     = "letrec"

  pprDefns :: [(Name, CoreExpr)] -> Iseq
  pprDefns defns = iInterleave sep (map pprDefn defns)
                   where
                     sep = iConcat [ iStr ";", iNewline ]
                
  pprDefn :: (Name, CoreExpr) -> Iseq
  pprDefn (name, expr) = iConcat [ iStr name, iStr " = ", iIndent (pprExpr expr) ]
\end{verbatim}

定義をより読みやすくするために、\texttt{iConcat} と \texttt{iInterleave} の 2 つの新しい関数を使用しました。

\begin{verbatim}
  iConcat :: [Iseq] -> Iseq
  iInterleave :: Iseq -> [Iseq] -> Iseq
\end{verbatim}

\texttt{iConcat} は \texttt{iseq} のリストを受け取り、\texttt{iAppend} を使用してそれらを単一の \texttt{iseq} に連結します。
\texttt{iInterleave} は、隣接する各ペア間に指定された \texttt{iseq} をインターリーブする点を除いて、\texttt{iConcat} に似ています。

\begin{description}
	\item[演習 1.2] \texttt{iAppend} と \texttt{iNil} に関して \texttt{iConcat} と \texttt{iInterleave} を定義します。
\end{description}

一般に、すべてのプリティ プリンティング関数は\texttt{iseq} を返し、
表示したいもの全体を表す \texttt{iseq} に \texttt{iDisplay} をトップ レベルで 1 回だけ適用します。

\begin{description}
	\item[演習 1.3] \texttt{pprExpr} に式を追加して\texttt{case}式とラムダ式を処理し、
		\texttt{pprAExpr} と \texttt{pprProgram} の定義を同じスタイルで記述します。
\end{description}

\subsubsection{\texttt{iseq}の実装}

\texttt{iseq} 型の実装に移ります。
すべてのインデントを無視する実装を作成することから始めます。
抽象データ型を実装するには、型が何であるかを言う必要があります
\texttt{iseq} を表すために使用されます。

\begin{verbatim}
  data Iseq = INil
            | IStr String
            | IAppend Iseq Iseq
\end{verbatim}

最初の宣言は \texttt{iseqRep} が \texttt{iseq} を表すために使用されることを示し、
2 番目の宣言は \texttt{iseqRep} が 3 つのコンストラクター \texttt{INil}、\texttt{IStr}、
および \texttt{IAppend} を持つ代数データ型であることを宣言します。
\vskip\baselineskip

この特定の表現の一般的な考え方は、\texttt{iDisplay} の最終的なすべてまですべての作業を延期することです。
操作 \texttt{iNil}、\texttt{iStr}、\texttt{iAppend} はすべて、関連するコンストラクターを使用するだけです。

\begin{verbatim}
  iNil = INil
  iStr str = IStr str
  iAppend seq1 seq2 = IAppend seq1 seq2
\end{verbatim}

インデントを無視しているので、\texttt{iIndent} と \texttt{iNewline} は自明に定義されています。
次のセクションでそれらを改善します。

\begin{verbatim}
  iNewline = IStr "\n"
  iIndent seq = seq
\end{verbatim}

\texttt{iseq} を文字のリストに変換する操作 \texttt{iDisplay} にすべての関心があります。
目標は、\texttt{iseq} のサイズに比例した時間だけかかるようにすることです。
より一般的な機能である \texttt{flatten} に関して \texttt{iDisplay} を定義すると便利であることが判明しました。

\begin{verbatim}
  flatten :: [Iseq] -> String

  iDisplay seq = flatten [seq]
\end{verbatim}

関数 \texttt{flatten} は \texttt{iseqReps} のリストを受け取り、リスト内の各 \texttt{iseqReps} を連結した結果を返します。
このリストを持つ理由は、すぐにわかるように、保留中の作業のリストを蓄積できるようにするためです。
\texttt{flatten} は、抽象型 \texttt{iseq} ではなく、表現型 \texttt{iseqRep} を操作することに注意してください。
\vskip\baselineskip

\textbf{ワークリスト}と呼ばれる引数のケース分析によって\texttt{flatten}を定義します。
ワークリストが空の場合、完了です。

\begin{verbatim}
  flatten [] = ""
\end{verbatim}

それ以外の場合は、ワークリストの最初の要素でケース分析を行うことで作業します。
\texttt{INil}の場合は、ワークリストからアイテムをポップするだけです。

\begin{verbatim}
  flatten (INil : seqs) = flatten seqs
\end{verbatim}

\texttt{IStr}の場合は、指定された文字列を追加して、残りのワークリストをフラット化することで機能します。

\begin{verbatim}
  flatten (IStr s : seqs) = s ++ (flatten seqs)
\end{verbatim}

これまでのところ、\texttt{flatten}がリストを取得するという事実は、私たちにはあまり役に立ちませんでした。
\texttt{IAppend}を扱うと、リスト引数の正当性がより明確にわかります。
実行する必要があるのは、もう1つのアイテムをワークリストの先頭にプッシュすることだけです。

\begin{verbatim}
  flatten (IAppend seq1 seq2 : seqs) = flatten (seq1 : seq2 : seqs)
\end{verbatim}

\begin{description}
	\item[演習 1.4] \texttt{iseq} のサイズに関して平坦化のコストはいくらですか?
		上記のように \texttt{iseq} を使用するように \texttt{pprExpr} を変更し、前の演習と同じ実験を使用して新しい実装の効果を測定します。
		\texttt{pprExpr} の結果に \texttt{iDisplay} を適用することを忘れないでください。

	\item[演習 1.5] 抽象データ型を使用する主な利点は、\textbf{インターフェイス}に影響を与えずに ADT の\textbf{実装}を変更できることです。
		この例として、引数のいずれかが \texttt{INil} の場合に単純化された結果を返すように \texttt{iAppend} を再定義します。
\end{description}

\subsubsection{レイアウトとインデント}

これまでのところ、\texttt{iIndent} 操作に対してかなり些細な解釈しか与えていません。次に、それを改善します。
以前と同じ精神で、最初に \texttt{iseqRep} 型を追加の 2 つのコンストラクター \texttt{IIndent} と \texttt{INewline} で拡張し、
これらのコンストラクターを使用するように操作を再定義します。

\begin{verbatim}
  data Iseq = INil
  | IStr String
  | IAppend Iseq Iseq
  | IIndent Iseq
  | INewline

  iIndent seq = IIndent seq
  iNewline    = INewline
\end{verbatim}

次に、\texttt{flatten}をより強力にする必要があります。
まず、現在のカラムを追跡する必要があります。
次に、そのワークリストは\texttt{(iseq, num)}ペアで構成されている必要があります。
ここで、数値は対応する\texttt{iseq}に必要なインデントを示します。

\begin{verbatim}
  flatten :: Int              -- Current column; 0 for first column
             -> [(Iseq, Int)] -- Work list
             -> String        -- Result
\end{verbatim}

\texttt{flatten}を適切に初期化するには、\texttt{iDisplay} を変更する必要があります。

\begin{verbatim}
  iDisplay seq = flatten 0 [(seq, 0)]
\end{verbatim}

\texttt{flatten} の興味深いケースは、\texttt{INewline} を扱う場合です。これは、インデントを実行する必要があるためです。

\begin{verbatim}
  flatten col ((INewline, indent) : seqs)
    = '\n' : (space indent) ++ (flatten indent seqs)
\end{verbatim}

新しい行に移動して \texttt{indent} スペースを追加したので、
\texttt{flatten} の再帰呼び出しには現在の列引数 \texttt{indent} があることに注意してください。
これは、新しい行に移動してインデント スペースを追加したためです。
\vskip\baselineskip

\texttt{IIndent} ケースは、現在の列から現在のインデントを設定するだけです。

\begin{verbatim}
  flatten col ((IIndent seq, indent) : seqs) = flatten col ((seq, col) : seqs)
\end{verbatim}

\begin{description}
	\item[演習 1.6] \texttt{IAppend}、\texttt{IStr}、および \texttt{INil} の\texttt{flatten}の定義を追加します。
		\texttt{Elet} を含む式で \texttt{pprExpr} を試し、レイアウトが適切に機能することを確認します。

	\item[演習 1.7] \texttt{IStr} に与えられた文字列に改行文字 \texttt{'\textbackslash n'} が埋め込まれていると、プリティプリンタは正しく動作しません。
		これをチェックするように \texttt{iStr} を変更し、改行文字を \texttt{INewline} を使用して置き換えます。
\end{description}

\subsubsection{演算子の優先順位}

セクション 1.3 で説明したように、\texttt{coreExpr} 型には中置演算子適用のための構造がありません。
代わりに、そのような関数適用は、他の関数適用と同様に、前置形式で表現されます。
私たちの プリティプリンタ がそのような関数適用を認識し、それらを中置形式で印刷できれば素晴らしいと思います。
これは、次の形式の \texttt{pprExpr} に式を追加することで簡単に実行できます。

\begin{verbatim}
  pprExpr (EAp (EAp (EVar "+") e1) e2)
    = iConcat [ pprAExpr e1, iStr " + ", pprAExpr e2 ]
\end{verbatim}

挿入する括弧が多すぎるため、これでもあまりうまくいきません。
次の式

\begin{verbatim}
  x + y > p * length xs
\end{verbatim}

を見たいですか？
または完全に括弧で囲まれたバージョン

\begin{verbatim}
  (x + y) > (p * (length xs))
\end{verbatim}

の方がいいですか？

これを実現する最も簡単な方法は、 \texttt{pprExpr} にそのコンテキストの優先レベルを示す追加の引数を与え、
これを使用して、生成される式の周りに括弧を追加するかどうかを決定することです。
(関数 \texttt{pprAExpr} は冗長になります。)

\begin{description}
	\item[演習 1.8] これらの変更を \texttt{pprExpr} に加えてテストします。
\end{description}

\subsubsection{\texttt{iseq} のその他の便利な機能}

後で \texttt{iseq} で動作する関数がいくつかあると便利です。
これらはすべて \texttt{iseq} インターフェイス関数の観点から定義されているため、これらの定義を変更せずに実装を変更できます。
\vskip\baselineskip

\texttt{iNum} は数値を \texttt{iseq} にマップし、\texttt{iFWNum} は同じことを行いますが、結果は指定された幅までスペースで左がパディングされます。

\begin{verbatim}
  iNum :: Int -> Iseq
  iNum n = iStr (show n)
  
  iFWNum :: Int -> Int -> Iseq
  iFWNum width n
    = iStr (space (width - length digits) ++ digits)
      where
        digits = show n
\end{verbatim}

(数値が必要な幅より広い場合、負の数値がスペースに渡され、空のリストが返されます。
したがって、最終的な効果は、含めるのに十分な幅のフィールドを返すことです
数字。）
\texttt{iLayn} は、標準関数 \texttt{layn} と同じように、項目に番号を付け、それぞれの後に改行文字を付けてリストをレイアウトします。

\begin{verbatim}
  iLayn :: [Iseq] -> Iseq
  iLayn seqs
    = iConcat (map lay_item (zip [1..] seqs))
      where
        lay_item (n, seq)
          = iConcat [ iFWNum 4 n,
                      iStr ")",
                      iIndent seq,
                      iNewline
                    ]
\end{verbatim}

\subsubsection{概要}

私たちのプリティプリンタにはまだ欠点があります。
特に、優れたプリティプリンタは、収まる場合は 1 行にレイアウトし、収まらない場合は複数の行にレイアウトします。
次のように \texttt{iseq} データ型を精巧にすることは十分に可能です。
これを行いますが、ここでは行いません。
\texttt{iseq} 型は、プログラム以外のデータをきれいに印刷するのに役立ちます。この本では、さまざまな目的で使用します。
このセクションから導き出したい 2 つの一般的なポイントがあります。

\begin{itemize}
	\item 抽象データ型の\textbf{インターフェース}をその\textbf{実装}から分離することは、非常にしばしば役に立ちます。
	      Miranda は、抽象型に対する関数が表現を検査しないようにすることで、この抽象化を直接サポートします。
	\item \texttt{flatten}に関する \texttt{iDisplay} の定義は、汎化と呼ばれる非常に一般的な手法の例です。
	      より一般的な関数への単純な呼び出しという観点から、本当に必要な関数を定義することがよくあります。
	      これは通常、より一般的な関数が、簿記をまっすぐに保つために必要ないくつかの追加の引数を持ち運ぶためです。
	      \vskip\baselineskip

	      一般化が適切な手法である場合について、一般的な意見を述べるのは困難です。
	      実際、適切な一般化を行うことは、多くの場合、プログラムを作成する際の主要な創造的ステップです。
	      ただし、この本には一般化の例がたくさんあり、アイデアを伝えるのに役立つことを願っています。
\end{itemize}
\newpage

\subsection{コア言語のパーサ} \label{sec_1_6}

それぞれの実装をさまざまなコアプログラムで実行する必要があります。
これは、具体的な構文でCoreプログラムを含むファイルを取得し、
それを\texttt{CoreProgram}型の値に解析する方法が必要であることを意味します。
\vskip\baselineskip
パーサを作成するのは一般的にかなり面倒なので、文法を受け入れてパーサを作成するツールの作成に多大な労力が費やされてきました。
Unix Yaccユーティリティは、そのようなパーサジェネレータの例です。
ただし、関数型言語では、単純なパーサを作成するのは非常に簡単です。
このセクションでは、コア言語について説明します。
タスクを3つの段階に分割します。

\begin{itemize}
	\item まず、名前付きファイルの内容を文字のリストとして取得します。
	      これは、組み込みのMiranda関数\texttt{read}によって実行されます。
	\item 次に、\textbf{字句解析}関数\texttt{lex}は、入力を識別子、数字、記号などの小さなチャンクのシーケンスに分割します。
	      これらの小さなチャンクは\textbf{トークン}と呼ばれます。

	      \begin{verbatim}
Clex :: String -> [Token]
\end{verbatim}

	\item 最後に、\textbf{構文解析}関数の構文は、この一連のトークンを使用して\texttt{CoreProgram}を生成します。

	      \begin{verbatim}
syntax :: [Token] -> CoreProgram
\end{verbatim}
\end{itemize}
\vskip\baselineskip

完全なパーサは、これら3つの関数の合成にすぎません。

\begin{verbatim}
parse :: String -> CoreProgram
parse = syntax . clex
-- In Gofer I propose to compose this with some function
-- CoreProgram -> String, which will illustrate some sort of
-- execution machine, and then give this composition to catWith
-- from my utils
\end{verbatim}
\vskip\baselineskip

記号 '.' は、Mirandaの中置関数合成演算子であり、次のように定義できます。

\begin{verbatim}
        (f . g) x = f (g x)
\end{verbatim}
\vskip\baselineskip

同様に、次のように、合成を使用せずに解析関数を定義することもできます。

\begin{verbatim}
parse filename = syntax (lex (read filename))
\end{verbatim}
\vskip\baselineskip

ただし、構文解析を３つの関数のパイプラインとして定義していることが特に簡単にわかるため、関数合成を使用する方が適切なスタイルです。

\subsubsection{字句解析}

字句解析器から始めます。
トークンの種類はまだ定義されていません。
最初に最も簡単なことは、トークンをまったく処理せず、(空でない)文字列として残すことです。

\begin{verbatim}
type Token = String -- A token is never empty
\end{verbatim}

今、字句解析自体。
空白(空白、タブ、改行)を破棄する必要があります：

\begin{verbatim}
clex (c : cs) | isWhiteSpace c = clex cs
\end{verbatim}

数字を単一のトークンとして認識する必要があります。

\begin{verbatim}
clex (c : cs) | isDigit c = num_token : clex rest_cs
                where
                  num_token = c : takeWhile isDigit cs
                  rest_cs   = dropWhile isDigit cs
\end{verbatim}

標準関数\texttt{isDigit}は文字を受け取り、その文字が10進数の場合にのみ、\texttt{True}を返します。
\texttt{takewhile}と\texttt{dropwhile}も標準機能です。
\texttt{takewhile}は、述語が満たされている間、リストの先頭から要素を取得し、
\texttt{dropwhile}は、述語が満たされている間、リストの先頭から要素を削除します。
例えば、

\begin{verbatim}
        takeWhile isDigit "123abc456"
\end{verbatim}

の結果はリスト\texttt{"123"}です。
\vskip\baselineskip

字句解析プログラムは、アルファベット文字で始まり、文字、数字、アンダースコアのシーケンスで続く変数も認識する必要があります。

\begin{verbatim}
clex (c : cs) | isAlpha c = var_tok : clex rest_cs
                where
                  var_tok = c : takeWhile isIdChar cs
                  rest_cs = dropWhile isIdChar cs
\end{verbatim}

ここで、\texttt{letter}はアルファベット文字で\texttt{True}を返す\texttt{digit}のような標準関数であり、\texttt{isIdChar}は以下で定義されています。
\vskip\baselineskip

上記の式のいずれにも当てはまらない場合、字句解析プログラムは1文字を含むトークンを返します。

\begin{verbatim}
clex (c : cs) = [c] : clex cs
\end{verbatim}

最後に、入力文字列が空の場合、\texttt{lex}は空のトークンリストを返します。

\begin{verbatim}
clex [] = []
\end{verbatim}

上記で使用した補助関数の定義で締めくくります。
(演算子'\texttt{\/}'はMirandaのブール'or'演算です。)

\begin{verbatim}
isIdChar, isWhiteSpace :: Char -> Bool
isIdChar c = isAlpha c || isDigit c || (c == '_')
isWhiteSpace c = c `elem` " \t\n"
\end{verbatim}

\begin{description}
	\item[演習 1.9] コメントと空白を無視するように字句アナライザを変更します。
		コメントが二重の縦棒\texttt{||}によって導入されるのと同じ規則を使用し、行の終わりまで延長します。
	\item[演習 1.10] 字句解析プログラムは現在、\texttt{<=}や\texttt{==}などの2文字の演算子を単一のトークンとして認識しません。
		それらのリストを提供することにより、そのような演算子を定義します。

		\begin{verbatim}
twoCharOps :: [String]
twoCharOps = ["==", "~=", ">=", "<=", "->"]
\end{verbatim}

		\texttt{twoCharOps}の\texttt{member}をトークンとして認識するように\texttt{lex}を変更します。
		(標準関数メンバーが役立つ場合があります。)
	\item[演習 1.11] 字句解析では空白が破棄されるため、パーサは構文エラーの行番号を報告できません。
		この問題を解決する1つの方法は、各トークンに行番号を付けることです。
		つまり、タイプ\texttt{token}は次のようになります。

		\begin{verbatim}
token == (num, [char])
\end{verbatim}

		これを行うように字句アナライザを変更します。
		これを行うには、現在の行番号であるパラメータを\texttt{lex}に追加する必要があります。
\end{description}

\subsubsection{構文解析のための基本的なツール}

コア言語のパーサを作成する準備として、パーサを作成するときに使用するいくつかの汎用関数を開発します。
以下で説明する手法はよく知られていますが[Fairbairn1986、Wadler 1985]、関数型プログラミングで何ができるかをかなりうまく示しています。
実行例として、次の小さな文法を使用します。

\begin{center}
	\begin{tabular} {l c l}
		\textit{greeting} & $\rightarrow$ & \textit{hg} \textit{person} \texttt{!} \\
		\textit{hg}       & $\rightarrow$ & \texttt{hello}                         \\
		                  & \textbar      & \texttt{goodbye}
	\end{tabular}
\end{center}

ここで、\textit{person}は文字で始まるトークンです。
\vskip\baselineskip

関数型プログラミングで非常に一般的な私たちの一般的なアプローチは、小さなパーサを接着して大きなパーサを構築しようとすることです。
重要な質問は、パーサのタイプはどうあるべきかということです。
これは、トークンのリストを引数として受け取る関数であり、最初は、解析された値を返すだけでよいように見えます。
しかし、これは2つの理由から、十分に一般的ではありません。

\begin{enumerate}
	\item まず、トークンの残りのリストも返す必要があります。
	      たとえば、入力から2つの項目を次々に解析する場合は、最初のパーサを入力に適用できますが、
	      最初のパーサから返された残りの入力に2番目のパーサを適用する必要があります。
	\item 次に、文法があいまいな場合があるため、入力を解析する方法は複数あります。
	      または、入力が文法に準拠していない可能性があります。
	      その場合、入力を正常に解析する方法はありません。
	      これらの可能性に対応するためのエレガントな方法は、可能な解析のリストを返すことです。
	      このリストは、入力を解析する方法がない場合は空であり、入力を解析する独自の方法がある場合は1つの要素を含みます。
\end{enumerate}

次のように、型シノニムを使用してパーサの型を定義することにより、結論を要約できます。

\begin{verbatim}
type Parser a = [Token] -> [(a, [Token])]
\end{verbatim}

つまり、型\texttt{*}の値のパーサは、トークンのリストを受け取り、解析のリストを返します。
各解析は、型\texttt{*}の値と残りのトークンのリストを組み合わせたものです。

\subsubsection{ツールを鋭利にする}

これで、パーサを開発するための基本的なツールが完成しました。
このセクションでは、さまざまな方法でそれらを開発します。
\vskip\baselineskip
文法では人の名前の後に感嘆符が必要なため、上記のpGreetingの定義は完全には正しくありません。
次のように問題を解決できます。

\begin{verbatim}
  pGreeting = pThen keep_first
                        (pThen mk_pair pHelloOrGoodbye pVar)
                        (pLit "!")
              where
              keep_first hg_name exclamation = hg_name
              mk_pair hg name = (hg, name)
\end{verbatim}
\vskip\baselineskip

最終的な感嘆符は常に存在するため、解析された値の一部として返さないことを選択しました。
\texttt{keep\_first}によって破棄されます。
ただし、この定義はかなり不器用です。
新しい関数\texttt{pThen3}を定義すると、次のように記述できるので便利です。

\begin{verbatim}
  pGreeting = pThen3 mk_greeting
                        pHelloOrGoodbye
                        pVar
                        (pLit "!")
              where
              mk_greeting hg name exclamation = (hg, name)
\end{verbatim}

\begin{description}
	\item[演習 1.12] \texttt{pThen3}の型を指定し、その定義を書き留めて、新しいバージョンの\texttt{pGreeting}をテストします。
		同様に、後で必要になる\texttt{pThen4}を記述します。
\end{description}

文法のもう1つの非常に一般的な機能は、記号の0回以上の繰り返しを要求することです。
これを反映するために、パーサpを受け取り、pが認識する0回以上の出現を認識する新しいパーサを返す関数\texttt{pZeroOrMore}が必要です。
成功した解析によって返される値は、pの継続的な使用によって返される値のリストである可能性があります。
従って、\texttt{pZeroOrMore}の型は次のようになります。

\begin{verbatim}
pZeroOrMore :: Parser a -> Parser [a]
\end{verbatim}

例えば、0個以上の挨拶を認識するパーサは次のようになります。

\begin{verbatim}
pGreetings :: Parser [(String, String)]
pGreetings = pZeroOrMore pGreeting
\end{verbatim}

1つ以上の出現、または出現なしのいずれかを確認する必要があることを確認することで、\texttt{pZeroOrMore}になることができます。

\begin{verbatim}
pZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])
\end{verbatim}

ここで、\texttt{pEmpty}は常に成功するパーサであり、入力から何も削除せず、最初の引数として指定された値を返します。

\begin{verbatim}
pEmpty :: a -> Parser a
\end{verbatim}

関数\texttt{pOneOrMore}は、\texttt{pZeroOrMore}と同じ型です。

\begin{verbatim}
pOneOrMore :: Parser a -> Parser [a]
\end{verbatim}

\begin{description}
	\item[演習 1.13] \texttt{pOneOrMore}と\texttt{pEmpty}の定義を記述します。
		(ヒント：\texttt{pOneOrMore}から\texttt{pZeroOrMore}を呼び出すと便利です。)
		1つまたは複数の挨拶を認識するパーサを定義するためにそれらを使用して、定義をテストします。
\end{description}

成功した解析によって返された値を処理すると便利なことがよくあります。
たとえば、\texttt{pGreetings}が内容ではなく、挨拶の数を返すようにしたいとします。
これを行うには、長さ関数\texttt{＃}を\texttt{pZeroOrMore}によって返される値に適用します。

\begin{verbatim}
pGreetingsN :: Parser Int
pGreetingsN = (pZeroOrMore pGreeting) `pApply` length
\end{verbatim}

ここで、\texttt{pApply}は新しいパーサ操作関数であり、パーサと関数を受け取り、パーサによって返される値に関数を適用します。

\begin{verbatim}
pApply :: Parser a -> (a -> b) -> Parser b
\end{verbatim}

\begin{description}
	\item[演習 1.14] \texttt{pApply}の定義を記述し、それをテストします。
		(ヒント：リスト内包表記を使用してください。)
\end{description}

文法のもう1つの非常に一般的なパターンは、他の記号で区切られた1つ以上の記号の出現を探すことです。
たとえば、図1.1のプログラムは、セミコロンで区切られた1つ以上のスーパーコンビネータ定義のシーケンスです。
さらに別のパーサ構築関数\texttt{pOneOrMoreWithSep}が必要です。
この関数のタイプは、次の通りです。
\begin{verbatim}
pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
\end{verbatim}
2番目の引数は、結果の一部として返されないセパレータを認識するパーサです。
そのため、型に\texttt{**}が1回だけ出現します。

\begin{description}
	\item[演習 1.15] \texttt{pOneOrMoreWithSep}を定義してテストします。
		\textit{program}の次の文法を考えると役立つ場合があります。

		\begin{center}
			\begin{tabular} {l c l}
				\textit{program}     & $\rightarrow$ & \textit{sc} \textit{programRest} \\
				\textit{programRest} & $\rightarrow$ & \texttt{;} \textit{program}      \\
				                     & \textbar      & $\epsilon$
			\end{tabular}
		\end{center}

		ここで、$\epsilon$は空の文字列(\texttt{pEmpty}パーサに対応)です。
\end{description}

パーサ\texttt{pLit}と\texttt{pVar}は互いに非常に似ています。
どちらも最初のトークンのプロパティをテストし、失敗するか(プロパティがない場合)、成功してトークン内の文字列を返します(トークンがある場合)。
このアイデアを一般化するには、パーサ\texttt{pSat}('sat'は'satisfies'の略)を次のように記述します。

\begin{verbatim}
pSat :: (String -> Bool) -> Parser String
\end{verbatim}

\texttt{pSat}は、トークン内の文字列に目的のプロパティがあるかどうかを通知する関数を受け取り、そのプロパティを持つトークンを認識するパーサを返します。
これで、\texttt{pSat}\footnote{式\texttt{(= s)}は\textbf{セクション}と呼ばれます。
	これは、等式演算子\texttt{=}を1つの引数\texttt{s}に部分適用し、
	その引数が\texttt{s}に等しいかどうかをテストする関数を生成します。}の観点から\texttt{pLit}を記述できます。

\begin{verbatim}
pLit s = pSat (== s)
\end{verbatim}

\begin{description}
	\item[演習 1.16] \texttt{pSat}を定義し、テストします。
		\texttt{pLit}と同様の方法で、\texttt{pSat}の観点から\texttt{pVar}を記述します。
\end{description}

\texttt{pSat}は、有用なレベルのモジュール性を追加します。
たとえば、\texttt{pVar}は現在、すべてのアルファベットトークンを変数として認識しますが、
最終的には、言語キーワード(\texttt{let}や\texttt{case}など)を変数として認識しないようにする必要があります。

\begin{description}
	\item[演習 1.17] 上記の\texttt{pVar}の定義で\texttt{pSat}に渡される関数を変更して、リストキーワードの文字列を変数として扱わないようにします。

		\begin{verbatim}
keywords :: [String]
keywords = ["let", "letrec", "case", "in", "of", "Pack"]
\end{verbatim}

	\item[演習 1.18] 別の例として、\texttt{pSat}を使用して、以下に示す型の数値のパーサを定義します。

		\begin{verbatim}
pNum :: ParserInt
\end{verbatim}

		\texttt{pNum}は\texttt{pSat}を使用して数値トークンを識別し、次に\texttt{pApply}を使用して文字列を数値に変換する必要があります。
		(Mirandaは、ハードワークを実行するために使用できる\texttt{[Char]-> num}型の標準関数\texttt{numval}を提供します。)
\end{description}

\texttt{pOneOrMore}とそれに関連する機能に関連する興味深いパフォーマンスの問題があります。
次のコアプログラムについて考えてみます。

\begin{verbatim}
        f x = let x1 = x; x2 = x; ...; xn = x
              of x1
\end{verbatim}

アイデアは、\texttt{x1}, \texttt{x2}, $\ldots$, \texttt{xn} の定義を持つ大きな\texttt{let}式があるということです。(定義はかなり些細なものですが、目的を果たします。)
このプログラムには構文エラーがあります。
\texttt{let}式の後に「\texttt{in}」ではなく「\texttt{of}」を記述しました。

\subsubsection{コア言語の構文解析}

コア言語のパーサを定義する準備が整いました。
まず、「ラッパー」関数、構文を扱います。
トークンのリストを取得し、\texttt{coreProgram}型の結果を提供することを思い出してください。
これを行うには、非終端プログラムを解析するパーサ\texttt{pProgram}(図1.1)を呼び出し、それが返す最初の完全な解析を選択します。
完全な解析が返されない場合、つまり、解析後に残っているトークンのシーケンスが空である場合、構文は(ひどく情報が少ない)エラーメッセージを生成します。

\begin{verbatim}
syntax = take_first_parse . pProgram
         where
           take_first_parse ((prog, []) : others) = prog
           take_first_parse (parse      : others) = take_first_parse others
           take_first_parse other                 = error "Syntax error"
\end{verbatim}

私たちの構文解析ツールの利点は、文法をMirandaに直訳するだけでパーサを記述できることです。
たとえば、図1.1の\textit{program}と\textit{sc}のプロダクションについて考えてみます。

\begin{center}
	\begin{tabular} {l c l l}
		\textit{program} & $\rightarrow$ & $sc_1 \texttt{;} \ldots \texttt{;} sc_n$ & $(n \geq 1)$ \\
		\textit{sc}      & $\rightarrow$ & $var ~ var_1 ~ \ldots ~ var_n = expr$    & $(n \geq 0)$
	\end{tabular}
\end{center}

これらを直接Mirandaに直訳することができます。

\begin{verbatim}
pProgram :: Parser CoreProgram
pProgram = pOneOrMoreWithSep pSc (pLit ";")

pSc :: Parser CoreScDefn
pSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit "=") pExpr
\end{verbatim}

\begin{description}
	\item[演習 1.20] 関数\texttt{mk\_sc}を記述します。
		これは、\texttt{pSc}で使用される4つのパーサによって返される4つの引数を取り、次のタイプの値を作成します。
		\begin{verbatim}
  (name, [name], coreExpr)
\end{verbatim}
\end{description}

関数適用と中置演算子の生成を除いて、残りの文法の定義を完了するのは簡単なことです。

\begin{description}
	\item[演習 1.21] これらの2つのプロダクションを除外して、パーサを完成させます。
		型が\texttt{Parser CoreExpr}であるパーサ\texttt{pAexpr}には少し注意が必要です。
		\texttt{pApply}関数は、\texttt{pVar}によって返される値の周りに\texttt{EVar}コンストラクタをラップし、
		\texttt{pNum}によって返される値の周りに\texttt{ENum}コンストラクタをラップするために必要です。
		次のプログラムでパーサをテストします。

		\begin{verbatim}
  f = 3 ;
  g x y = let z = x in z ;
  h x = case (let y = x in y) of
          <1> -> 2 ;
          <2> -> 5
\end{verbatim}

		より大きなプログラムでパーサを実行すると、出力が判読できなくなることがわかります。
		これを解決するには、プリティプリンティング関数\texttt{pprint}を使用して、パーサの出力をフォーマットします。
	\item[演習 1.22] 次のプログラムを検討します。

		\begin{verbatim}
  f x y = case x of
          <1> -> case y of
                  <1> -> 1;
          <2> -> 2
\end{verbatim}

		\texttt{<2>}で始まる選択肢は、内側の\texttt{case}または外側の\texttt{case}のどちらに取り付けられますか？
		答えを見つけて、パーサが期待どおりに動作するかどうかを確認します。
		これは「ぶら下がりelse」の問題として知られています。
\end{description}

ここで、上記の2つの問題に目を向けます。

\subsubsection{左再帰}

関数適用の問題は比較的簡単に解決できます。
関数適用のためのプロダクションは次のようになります。
\[ expr \rightarrow expr ~ aexpr \]
これを単に直訳すると

\begin{verbatim}
  pExpr = pThen EAp pExpr pAexpr
\end{verbatim}

残念ながら、\texttt{pExpr}はそれ自体を無期限に呼び出し続けるため、終了することはありません。
問題は、\textit{expr}が\textit{expr}の生成の最初のシンボルとして表示されることです。
これは\textbf{左再帰}と呼ばれます。
私たちの構文解析ツールは、単に左再帰文法に対処できません。
幸いなことに、通常、文法を変換して左再帰にならないようにすることができますが、
結果の文法は、構築しようとしている結果の構造を反映していません。
この場合、たとえば、繰り返しを使用して、問題のあるプロダクションを次のように変換できます。
\[ expr \rightarrow aexpr_1 \ldots aexpr_n ~ (n \geq 1) \]
これで、パーサ\texttt{(pOneOrMore pAexpr)}を使用できるようになりました。
問題は、これがEApコンストラクターで作成された単一の式ではなく、式のリストを返すことです。
pApplyを使用してこれを解決し、パーサを提供します

\begin{verbatim}
(pOneOrMore pAexpr) $ pApply mk_ap_chain
\end{verbatim}

\begin{description}
	\item[演習 1.23] 型が\texttt{[CoreExpr] -> CoreExpr}の適切な関数\texttt{mk\_ap\_chain}を定義します。
		関数適用のプロダクションをパーサに追加してテストします。
\end{description}

\subsubsection{中置演算子の追加}

中置演算子の最初の問題は、それらの優先順位が図1.1の文法に暗黙的に含まれていることです。
これを明示的にする標準的な方法は、図1.3に示すように、いくつかの種類の式を使用することです。

\begin{center}
	\begin{tabular} {l c l l}
		\textit{expr}  & $\rightarrow$ & $\texttt{let} ~ defns ~ \texttt{in} ~ expr$                        &              \\
		               & \textbar      & $\texttt{letrec} ~ defns ~ \texttt{in} ~ expr$                     &              \\
		               & \textbar      & $\texttt{case} ~ expr ~ \texttt{of} ~ alts$                        &              \\
		               & \textbar      & $\texttt{\textbackslash} ~ var_1 \ldots var_n ~ \texttt{.} ~ expr$ &              \\
		               & \textbar      & \textit{expr1}                                                     &              \\
		\textit{expr1} & $\rightarrow$ & \textit{expr2} \texttt{|} \textit{expr1}                           &              \\
		               & \textbar      & \textit{expr2}                                                     &              \\
		\textit{expr2} & $\rightarrow$ & \textit{expr3} \texttt{\&} \textit{expr2}                          &              \\
		               & \textbar      & \textit{expr3}                                                     &              \\
		\textit{expr3} & $\rightarrow$ & \textit{expr4} \textit{relop} \textit{expr4}                       &              \\
		               & \textbar      & \textit{expr4}                                                     &              \\
		\textit{expr4} & $\rightarrow$ & \textit{expr5} \texttt{+} \textit{expr4}                           &              \\
		               & \textbar      & \textit{expr5} \texttt{-} \textit{expr5}                           &              \\
		               & \textbar      & \textit{expr5}                                                     &              \\
		\textit{expr5} & $\rightarrow$ & \textit{expr6} \texttt{*} \textit{expr5}                           &              \\
		               & \textbar      & \textit{expr6} \texttt{/} \textit{expr6}                           &              \\
		               & \textbar      & \textit{expr6}                                                     &              \\
		\textit{expr6} & $\rightarrow$ & $aexpr_1 \ldots aexpr_n$                                           & $(n \geq 1)$ \\
	\end{tabular}
\end{center}

この文法が次の事実を表現する方法に注意してください。
\texttt{|}および\texttt{＆}は右結合ですが、関係演算子は非結合です。
非常に多くのルールを書き出さなければならないのはかなり面倒ですが、私たちはずっと意味していることを明確にしているだけです。
しかし、ここで2番目の問題が発生します。
これらのルールから直接実装されたパーサはひどく非効率的です。
\textit{expr1}のプロダクションを考えてみましょう。
ナイーブなパーサは\textit{expr2}を認識しようとし、次に垂直バー\texttt{|}を探します。
検出されなかった場合(よくあることですが)、元の入力を手間をかけて再解析して、\textit{expr2}を再度検索します。
さらに悪いことに、\textit{expr2}を解析する各試行には、\textit{expr3}を解析する2回の試行が含まれる可能性があり、
したがって、\textit{expr4}を解析する4回の試行が含まれる可能性があります。
\vskip\baselineskip

\textit{expr2}の解析を2つのプロダクション間で共有したいのですが、
\textit{expr1}プロダクションを2つに分割することで、これを行うのは難しくありません。

\begin{center}
	\begin{tabular} {l c l}
		\textit{expr1}  & $\rightarrow$ & \textit{expr2} \textit{expr1c} \\
		\textit{expr1c} & $\rightarrow$ & \texttt{|} \textit{expr1}      \\
		                & \textbar      & $\epsilon$
	\end{tabular}
\end{center}

ここで、$\epsilon$は空の文字列を表します。
\textit{expr1}の生成では、\textit{expr1}は垂直バー\texttt{|}の後に\textit{expr1}が続くか、空であると示されています。
私たちは、ほぼ、そこにいる！
最後の質問は、\textit{expr1}のパーサの型は何ですか。
\texttt{|}というフレーズがあるため、\texttt{parser coreExpr}型にすることはできません。
\textit{expr1}は式の一部にすぎず、空の文字列$\epsilon$も式ではありません。
いつものように、文法を変換すると構造が破壊されます。
\vskip\baselineskip

解決策はかなり簡単です。
このような新しいデータ型\texttt{partialExpr}を定義します

\begin{verbatim}
data PartialExpr = NoOp
                 | FoundOp Name CoreExpr
\end{verbatim}

これで、次のように\textit{expr1c}のパーサを定義できます。

\begin{verbatim}
pExpr1c :: Parser PartialExpr
pExpr1c = (pThen FoundOp (pLit "|") pExpr1) `pAlt` (pEmpty NoOp)
\end{verbatim}

\textit{expr1}のパーサは、\texttt{pExpr1}によって返される中間結果を分解します：

\begin{verbatim}
pExpr1 :: Parser CoreExpr
pExpr1 = pThen assembleOp pExpr2 pExpr1c

assembleOp :: CoreExpr -> PartialExpr -> CoreExpr
assembleOp e1 NoOp = e1
assembleOp e1 (FoundOp op e2) = EAp (EAp (EVar op) e1) e2
\end{verbatim}

\begin{description}
	\item[演習 1.24] 提案された行に沿って文法を変換し、変更をMirandaコードに直訳して、結果のパーサをテストします。
\end{description}

\subsubsection{まとめ}

パーサ構築関数のライブラリによって効率的に処理できる文法は、LL(1) 文法と呼ばれます。
これは、従来の再帰降下パーサによって処理できるものとまったく同じクラスです [Aho et al. 1986]。
\vskip\baselineskip

ライブラリを使用すると、非常に簡潔なパーサを簡単に作成できます。
ほとんどすべてのプログラムには何らかの入力言語があり、プログラムによって解析される必要があるため、これは重要で便利なプロパティです。
\vskip\baselineskip

気をつけなければならないことはたくさんありますが (左再帰、演算子の優先順位、共有)、
実装されている言語に関係なく、再帰降下パーサではまったく同じ問題が発生します。
\newpage

\begin{verbatim}
  module Template where
  import Language
  import Utils
\end{verbatim}
\newpage

\section{テンプレートのインスタンス化}

この章では、関数型言語の可能な限りの単純な実装、つまりテンプレートのインスタンス化に基づくグラフ簡約器を紹介します。
\vskip\baselineskip
初期バージョン(マーク1)の完全なソースコードが示され、その後に基本設計の一連の改善とバリエーションが続きます。
まず、グラフの簡約とテンプレートのインスタンス化のレビューから始めます。

\subsection{テンプレートインスタンス化のプレビュー}

テンプレートのインスタンス化かの概要から始めます。
この資料は、[Peyton Jones 1987]の第11章と第12章で詳しく説明されています。

次の重要な事実を思い出します。

\begin{itemize}
	\item 関数型プログラムは、\textbf{式を評価する}ことによって「実行」されます。
	\item 式は\textbf{グラフ}で表されます。
	\item 評価は、一連の\textbf{簡約}を実行することによって行われます。
	\item 簡約は、グラフ内の\textbf{簡約可能な式}をその簡約形式に置き換えます(または\textbf{更新}します)。
	      「簡約可能な式」という用語は、しばしば「redex」と省略されます。
	\item redexがなくなると、評価は完了です。
	      式は\textbf{正規形}であると言います。
	\item 評価される式にはいつでも複数のredexが含まれる可能性があるため、次にどれを簡約するかを選択できます。
	      幸い、どの簡約手順を選択しても、常に同じ答え(つまり、正規形)が得られます。
	      注意点が1つあります。一部の簡約手順は終了しない場合があります。
	\item ただし、どのredexを選択しても評価が終了する場合、常に最も外側のredexを選択するというポリシーも終了します。
	      この簡約順序の選択は、\textbf{最外最左簡約(normal order reduction)}と呼ばれ、常に使用されるものです。
\end{itemize}

従って、評価のプロセスは次のように説明できます。

\begin{verbatim}
        until there are more redexes
              select the outermost redex
              reduce it
              update the (root of the) redex with the result
        end
\end{verbatim}

\subsubsection{実例}

例として、次のコア言語プログラムについて考えてみます。

\begin{verbatim}
        square x = x * x ;
        main = square (square 3)
\end{verbatim}

このプログラムは、スーパーコンビネータと呼ばれる一連の定義で構成されています。
\texttt{square}と\texttt{main}はどちらもスーパーコンビネータです。
慣例により、評価される四季はスーパーコンビネータ\texttt{main}です。
従って、最初に評価される式は、次のかなり些細なツリーで表されます
(ツリーは単なる特別な種類のグラフであることを忘れないでください)。

\begin{verbatim}
        main
\end{verbatim}

ここで、\texttt{main}には引数がないため、\texttt{main}自体がredexとなり、\texttt{main}をその本体で置き換えます。

\begin{verbatim}
        main            reduces to      @
                                       / \
                                 square   @
                                         / \
                                   square   3
\end{verbatim}

これらの図と後に続くすべての図では、関数適用は@記号で表されています。
\vskip\baselineskip
ここで、最も外側のredexは外側の関数適用(squareの適用)です。
関数適用を減らすために、redexを関数本体のインスタンスに置き換え、仮引数が出現するたびに引数へのポインタを置き換えます。

\begin{verbatim}
               @!       reduces to      @!
              / \                      / \
        square   @                    @   \
                / \                  / \___@
          square   3                *     / \
                                    square   3
\end{verbatim}

結果で上書きされるredexのルートは、!でマークされます。
内側の\texttt{square 3}のredexが共有され、ツリーがグラフになっていることに注意してください。
\vskip\baselineskip
\texttt{square}の定義では、式\texttt{x*x}(\texttt{*}は中置演算子として書かれています)は\texttt{((* x) x)}の略で、2つの引数に\texttt{*}を適用します。
\textbf{カリー化}を使用して、1引数の関数適用の形で複数の引数を持つ関数を記述します。
\texttt{*}は、引数\texttt{p}に適用されたとき、関数を返す関数となります。
\texttt{(* p)}が返す関数は、別の引数\texttt{q}に適用されると\texttt{p}と\texttt{q}の積を返すような関数です。
\vskip\baselineskip
現在、唯一のredexは内側の関数適用(\texttt{square}の\texttt{3}への適用)です。
\texttt{*}の引数を評価する必要があるため、\texttt{*}の適用は簡約できません。
内側の関数適用は次のように簡約されます。

\begin{verbatim}
               @        reduces to      @
              / \                      / \
             @   \                    @   \
            / \___@!                 / \___@
           *     / \                *     / \
           square   3                    @   \
                                        / \___3
                                       *
\end{verbatim}

まだ1つのredex、内側の乗算があります。
redexを乗算結果の9に置き換えます。

\begin{verbatim}
               @        reduces to      @
              / \                      / \
             @   \                    @   \
            / \___@!                 / \___9
           *     / \                *
                @   \
               / \___3
              *
\end{verbatim}

redexのルートを結果で物理的に更新することにより、外側の乗算の両方の引数が内側の乗算の結果を「参照」することに注意してください。
最終的な簡約は簡単です。

\begin{verbatim}
               @        reduces to      81
              / \
             @   \
            / \___9
           *
\end{verbatim}

\subsubsection{3つのステップ}

前に見たように、グラフ簡約は、正規形に達するまで次の3つのステップを繰り返すことで構成されます。

\begin{enumerate}
	\item 次のredexを見つける。
	\item それを簡約する。
	\item 簡約結果でredex(のルート)を更新する。
\end{enumerate}

前のセクションの例からわかるように、2種類のredexがあり、さまざまな方法で簡約されます。

\begin{description}
	\item[スーパーコンビネータ] 最も外側の関数適用がスーパーコンビネータの適用である場合、
		それは確かにredexでもあり、以下に説明するように簡約することができます(セクション2.1.4)。
	\item[組み込みのプリミティブ] 最も外側の関数適用が組み込みプリミティブの適用である場合、
		引数が評価されるかどうかに応じて、適用はredexである場合とそうでない場合があります。
		redexでない場合は、引数を評価する必要があります。
		これは、まったく同じプロセスを使用して行われます。
		引数の最も外側のredexを繰り返し見つけて、それを簡約します。
		これが完了すると、外側の組み込みプリミティブ適用の簡約に戻ることができます。
\end{description}

\subsubsection{次のredexを見つけるためのスパインの巻き戻し}

簡約サイクルの最初のステップは、実行する次の簡約の部位を見つけることです。
つまり、最も外側の簡約可能な関数適用です。
次のように、最も外側の関数適用を見つけるのは簡単です（ただし、簡約できない場合があります）。

\begin{enumerate}
	\item スーパーコンビネータまたは組み込みプリミティブに到達するまで、ルートから開始して、関数適用ノードの左側の枝をたどります。
	      この関数適用ノードの左分岐チェーンはエクスプレッションの\textbf{スパイン}と呼ばれ、このプロセスはスパインの\textbf{巻き戻し}と呼ばれます。
	      通常、\textbf{スタック}は、途中で遭遇したノードのアドレスを記憶するために使用されます。
	\item ここで、スーパーコンビネータまたはプリミティブが取る引数の数を確認し、その数の関数適用ノードに戻ります。
	      これで、最も外側の関数適用のルートが見つかりました。
\end{enumerate}

たとえば、式\texttt{(f E1 E2 E3)}では、\texttt{f}は2つの引数を取ります。
たとえば、最も外側の関数適用は\texttt{(f E1 E2)}です。
式とスタックは次のようになります。

\begin{verbatim}
         Stack
      -----------
        |  ---|-------> @
        -------        / \
        |  ---|-----> @!  E3
        -------      / \
        |  ---|---> @   E2
        -------    / \
        |  ---|-> f  E1
        -------
\end{verbatim}

最も外側の関数適用(のルート)は\texttt{!}でマークされています。
\vskip\baselineskip
fが2つではなく4つの引数をとった場合のように、評価の結果が部分適用である可能性がある場合は、
上記の手順2の前に、スパインに十分な関数適用ノードがあることを確認する必要があります。
そうでない場合、式はWeak Head Normal Form (WHNF)に達しています。
サブ式\texttt{E1}、\texttt{E2}、および\texttt{E3}にはまだredexeが含まれている可能性がありますが、
ほとんどの評価器は、サブ式も簡約しようとするのではなく、WHNFに到達すると停止します。
プログラムが型チェックされており、結果が数値、たとえば、リストであることが保証されている場合、このアンダーフローチェックは省略できます。
\vskip\baselineskip
最も外側の関数適用のルートのみが見つかったことに注意してください。
それは同様にredexであるかもしれないしそうでないかもしれません。
関数がスーパーコンビネータである場合、それは確かにredexになりますが、
\texttt{+}などのプリミティブである場合、引数が評価されるかどうかによって異なります。
もしスーパーコンビネータなら、私たちは最も外側のredexを見つけました。
スーパーコンビネータでない場合は、まだやるべきことがあります。
\vskip\baselineskip
プリミティブが現在評価されていない引数の値を必要とする場合、
プリミティブの簡約を進める前に引数を評価する必要があります。
これを行うには、以前と同じように、現在のスタックを片側に配置し、
引数を減らすために新しいスタックから開始する必要があります。
これは、前のセクションの例でステージに到達したときの状況でした。

\begin{verbatim}
               @
              / \
             @   \
            / \___@!
           *     / \
           square   3
\end{verbatim}

新しいスタックで引数\texttt{(square 3)}を評価する必要があります。
この評価中に、未評価の引数を持つプリミティブに再び遭遇する可能性があるため、新しい評価を再度開始する必要があります。
正しい順序でスタックに戻ることができるように、すべての「古い」スタックを追跡する必要があります。
これは、ダンプと呼ばれるスタックのスタックを保持することによって便利に行われます。
引数を評価する必要がある場合は、現在のスタックをダンプにプッシュします。
評価が終了したら、古いスタックをダンプから取り出します。
\vskip\baselineskip
もちろん、実際の実装では、スタック全体をコピーすることはありません。
「新しい」スタックは「古い」スタックが再び必要になる前に終了するため、
「新しい」スタックは「古い」スタックの上に物理的に構築できます。
ダンプスタックは、「新しい」と「古い」の境界がどこにあったかを追跡するだけです。
ただし、概念的には、ダンプはスタックのスタックであり、この方法でモデル化します。

\subsubsection{スーパーコンビネータredex}

スーパーコンビネータredexは、引数を本体に置き換えることで簡約されます。
より正確には：

\begin{quote}

	スーパーコンビネータの簡約。
	\textbf{スーパーコンビネータredexは、redexをスーパーコンビネータ本体のインスタンスに置き換え、}
	\textbf{実引数へのポインタで対応する仮引数の発生箇所を置き換えることによって簡約されます。}
	\textbf{引数はコピーされないことに注意してください。}
	\textbf{むしろ、それらへのポインタを使用するデバイスによって、それらは共有されます。}

\end{quote}

スーパーコンビネータ本体には、\texttt{let}式と\texttt{letrec}式を含めることができます。
例えば：

\begin{verbatim}
        f x = let y = x*x
              in y+y
\end{verbatim}

\texttt{let}および\texttt{letrec}式は、\textbf{グラフのテキスト記述}として扱われます。
ここでは、たとえば、\texttt{f}の定義の可能な使用法があります。

\begin{verbatim}
               @        reduces to      @
              / \                      / \
             f   3                    @   \
                                     / \   \
                                    +   \___@y
                                           / \
                                          @   \
                                         / \   \
                                        *   \___3
\end{verbatim}

\texttt{let}式は、\texttt{y}という名前の部分式\texttt{x*x}を定義します。
\texttt{let}式の本体\texttt{y+y}は、\texttt{y}の代わりに部分式へのポインタを使用します。
したがって、通常の表現は木を表します。
式に循環グラフを記述させます。
および\texttt{letrec}式は循環グラフを記述します。

\subsubsection{更新}

簡約を実行した後、結果でredexのルートを更新する必要があります。
これにより、redexが共有されている場合(例 \texttt{(sqrt (sqrt 3))}のように)、簡約は1回だけ実行されます。
この更新は、\textbf{遅延評価}の本質です。
redexはまったく評価されない場合がありますが、評価された場合、更新により、そのコストが最大で1回発生することが保証されます。
\vskip\baselineskip
更新を省略してもエラーは発生しません。
これは、一部の式が複数回評価される可能性があることを意味するだけであり、非効率的です。
\vskip\baselineskip
更新を実行するときに少し注意が必要なケースが1つあります。
以下のプログラムを検討します。

\begin{verbatim}
        id x = x
        f p = (id p) * p
        main = f (sqrt 4)
\end{verbatim}

fの簡約が行われた後、グラフは次のようになります。

\begin{verbatim}
               @
              / \
             @   \
            / \   \
           +   \___@y
                  / \
                 @   \
                / \   \
               *   \___3
\end{verbatim}

\texttt{sqrt}は、平方根を取るための組み込みプリミティブであると想定しています。
ここで、次に選択されたredexが\texttt{*}の最初の引数、つまり\texttt{id}の関数適用であると仮定します。
(どちらの引数も通常の形式ではないため、\texttt{*}の2番目の引数でも同様に適切である可能性がありますが、最初の引数であると想定します。)
\texttt{id}簡約を実行した後、redexのルートを何で上書きする必要がありますか？
\textbf{\texttt{(sqrt 4)}が2回評価されるため、\texttt{(sqrt 4)}関数適用ノードのコピーで上書きしないでください。}
\vskip\baselineskip
このジレンマから抜け出す最も簡単な方法は、新しい種類のグラフノードである間接ノードを追加することです。
これは\texttt{\#}記号で示されます。
間接ノードを使用して、簡約の結果を指すようにredexのルートを更新できます。

\begin{verbatim}
               @        reduces to      @
              / \                      / \
             @   \                    @   \
            / \   \                  / \   \
           *   @   \                *   #   \
              / \   \                    \   \
            id   \___@                    \___@
                    / \                      / \
                sqrt   4                 sqrt   4
\end{verbatim}

[Peyton Jones 1987]のセクション12.4には、更新に関連する問題の詳細な説明が含まれています。

\subsubsection{定数適用形式 \dag}

一部のスーパーコンビネータには引数がありません。 それらは、定数適用形式またはCAFと呼ばれます。
たとえば、fac20はCAFです。

\begin{verbatim}
        fac20 = factorial 20
\end{verbatim}

CAFの興味深い点は、スーパーコンビネータ自体がredexであるということです。
\texttt{fac20}が呼び出されるたびに、\texttt{factorial20}の新しいコピーをインスタンス化する必要はありません。
これは、\texttt{factorial20}の計算を繰り返すことを意味するためです。
むしろ、スーパーコンビネータ\texttt{fac20}は\texttt{fac20}簡約のルートであり、その本体をインスタンス化した結果で上書きする必要があります。
\vskip\baselineskip
実際の結果は、スーパーコンビネータを通常の方法で更新できるようにするために、グラフノードで表す必要があるということです。
これは、各実装で実際に発生することがわかります。
\vskip\baselineskip
これでグラフ簡約のレビューは終わりです。
\newpage

\subsection{状態遷移システム}

ここで、グラフ簡約の実装に注意を向けます。
\textbf{状態遷移システム}を使用して、各実装について説明します。
このセクションでは、状態遷移システムを紹介します。
\vskip\baselineskip
状態遷移システムは、シーケンシャルマシンの動作を説明するための表記法です。
いつでも、マシンは指定された\textbf{初期状態}から始まるある\textbf{状態}にあります。
マシンの状態が\textbf{状態遷移ルール}の1つと\textbf{一致する}場合、ルールはマシンの新しい状態を指定します。
一致する状態遷移ルールがない場合、実行は停止します。
複数のルールが一致する場合は、1つが任意に選択されて発火します。
その場合、マシンは\textbf{非決定論的}です。
すべてのマシンは決定論的です。
\vskip\baselineskip
これは、(かなり非効率的な)乗算器を指定するために使用される状態遷移システムの簡単な例です。
状態は4つ組\textbf{(n, m, d, t)}です。
掛ける数は\textbf{n}と\textbf{m}、現在の合計は\textbf{t}で、マシンは状態\textbf{(n, m, 0, 0)}に初期化されます。
\vskip\baselineskip
マシンの動作は、2つの遷移ルールによって指定されます。
最初のルールで指定されているように、\textbf{d}は\textbf{0}に向かって繰り返しデクリメントされると同時に、\textbf{t}をインクリメントします。
\vskip\baselineskip

\begin{tabular} {|l l l l l|} \hline
	                  & n                                     & m & d     & t     \\
	$\Longrightarrow$ & n                                     & m & d - 1 & t + 1 \\
	                  & \multicolumn {4} {l|} {where d $>$ 0}                     \\ \hline
\end{tabular}
\vskip\baselineskip

古い状態の同じ値の真下に新しい状態の各値を使用して遷移ルールを常に作成するため、どの値が変更されたかを簡単に確認できます。
\vskip\baselineskip
\textbf{d}が\textbf{0}に達すると、再び\textbf{n}に初期化され、\textbf{m}が0に達するまでmがデクリメントされます。
これは、2番目のルールで指定されています。
\vskip\baselineskip

\begin{tabular} {|l l l l l|} \hline
	                  & n                                     & m     & 0 & t     \\
	$\Longrightarrow$ & n                                     & m - 1 & n & t + 1 \\
	                  & \multicolumn {4} {l|} {where m $>$ 0}                     \\ \hline
\end{tabular}
\vskip\baselineskip

ルールが適用されない場合、マシンは終了します。
この時点で、状態\textbf{（n, 0, 0, t）}になります。
ここで、\textbf{t}は初期状態からの\textbf{n}と\textbf{m}の積です。

\begin{description}
	\item[演習 2.1] 初期状態（2; 3; 0; 0）から開始して、各ステップでどのルールを実行するかを指定して、マシンを手動で実行しなさい。
		最終状態が（2; 0; 0; 6）であることを確認しなさい。
	\item[演習 2.2] 一連の状態の不変量は、すべての状態に当てはまる述語です。
		\textbf{n}と\textbf{m}の初期値（\textbf{N}と\textbf{M}と呼びます）と\textbf{m}、\textbf{d}、\textbf{t}の現在の値との関係を表す不変量を見つけなさい。
		次に、マシンが乗算を実行するという推測を\textbf{証明}しなさい。
		証明を行うには、以下を示す必要があります。
		\begin{enumerate}
			\item 不変量は初期状態では真になる。
			\item 不変量が特定の状態で真になれば、次の状態でも真になる。
			\item 不変量と終了条件$(m = d = 0)$が与えられると、$t = N * M$になる。
			\item マシンは終了する。
		\end{enumerate}
\end{description}

状態遷移システムは、次の理由で私たちの目的に便利です。

\begin{itemize}
	\item それらは十分に\textbf{抽象的}であるため、非常に低レベルの詳細に巻き込まれることがない。
	\item それらは十分に\textbf{具体的}であるため、ルールに多くの複雑さを隠すことで「不正行為」をしていないことを確認できる。
	\item 状態遷移システムを直接Mirandaに書き直して、システムの実行可能な実装を提供できる。
\end{itemize}

最後のポイントを説明するために、乗算器をMirandaに書き直します。
このマシンの状態の型を定義するために、型シノニムを与えることから始めます。

\begin{verbatim}
type MultState = (Int, Int, Int, Int) -- (n, m, d, t)
\end{verbatim}

次に、関数evalMultは状態を取得し、その状態とそれに続くすべての状態で構成されるリストを返します。

\begin{verbatim}
evalMult :: MultState -> [MultState]
evalMult state = if multFinal state
                 then [state]
                 else state : evalMult (stepMult state)
\end{verbatim}

関数\texttt{stepMult}は非最終状態を取り、次の状態を返します。
遷移ルールごとに\texttt{stepMult}の式が1つあります。

\begin{verbatim}
stepMult (n, m, d, t) | d >  0 = (n, m    , d - 1, t + 1)
                      | d == 0 = (n, m - 1, n    , t    )
\end{verbatim}

関数\texttt{multFinal}は状態を取得し、その状態が最終状態であるかどうかをテストします。

\begin{verbatim}
multFinal :: MultState -> Bool
\end{verbatim}

\begin{description}
	\item[演習 2.3] 関数\texttt{multFinal}を定義し、結果のマシンを初期状態(2, 3, 0, 0)で実行し、結果リストの最後の状態が(2, 0, 0, 6)であることを確認します。
		標準関数\texttt{layn}は、結果をより読みやすくレイアウトするのに役立つ場合があります。
\end{description}

\begin{verbatim}
multFinal state = m == 0 && d == 0
                  where (_, m, d, _) = state

*Main> evalMult (2, 3, 0, 0)
[(2,3,0,0),(2,2,2,0),(2,2,1,1),(2,2,0,2),
           (2,1,2,2),(2,1,1,3),(2,1,0,4),
           (2,0,2,4),(2,0,1,5),(2,0,0,6)]
\end{verbatim}
\newpage

\subsection{Mark 1: 最小限のテンプレートインスタンス化グラフ簡約器}

これで、かなり単純なグラフ簡約器の定義を開始する準備が整いました。
シンプルですが、より洗練されたグラフ簡約器が持つ多くの部分が含まれているため、説明するのに数ページかかります。

\subsubsection{グラフ簡約の遷移規則}

テンプレートインスタンス化グラフ簡約マシンの状態は、4つ組

\begin{center}
	\textbf{(スタック、ダンプ、ヒープ、グローバル)}
\end{center}

または略して\textbf{(s, d, h, f)}です。

\begin{itemize}
	\item \textbf{スタック}は\textbf{アドレス}のスタックであり、各アドレスはヒープ内の\textbf{ノード}を識別します。
	      これらのノードは、評価される式のスパインを形成します。 表記$a_1 : s$は、最上位の要素が$a_1$で、残りが$s$であるスタックを示します。
	\item \textbf{ダンプ}は、厳密なプリミティブの引数を評価する前に、スパインスタックの状態を記録します。
	      ダンプはMark1マシンではまったく使用されませんが、後続のバージョンでは役立ちます。
	\item \textbf{ヒープ}は、タグ付けされた\textbf{ノード}のコレクションです。
	      表記$h [a：node]$は、ヒープ$h$内のアドレス$a$がノード$node$を指すことを意味します。
	\item 各スーパーコンビネータ(および後で各プリミティブ)について、\textbf{グローバル}はスーパーコンビネータ(またはプリミティブ)を表すヒープノードのアドレスを提供します。
\end{itemize}

ヒープノードは、次の3つの形式のいずれかを取ることができます(最も原始的なマシンの場合)。

\begin{itemize}
	\item $\texttt{NAp} ~ a_1 ~ a_2$は、アドレスが$a_1$であるノードからアドレスが$a_2$であるノードへの関数適用を表します。
	\item $\texttt{NSupercomb} ~ args ~ body$は、引数$args$と本体$body$を持つスーパーコンビネータを表します。
	\item $\texttt{NNum} ~ n$は、数$n$を表します。
\end{itemize}

このプリミティブテンプレートインスタンス化マシンには、2つの状態遷移ルールしかありません。
1つ目は、単一のアプリケーションノードをスパインスタックに巻き戻す方法を説明しています。
\vskip\baselineskip

\begin{tabular} {|c|l r l l l|} \hline
	(2.1) &                   & $a : s$       & $d$ & $h[a : \texttt{NAp} ~ a_1 ~ a_2]$ & $f$ \\
	      & $\Longrightarrow$ & $a_1 : a : s$ & $d$ & $h$                               & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

(このルールの2行目のヒープコンポーネントには、アドレス$a$から$\texttt{NAp} ~ a_1 ~ a_2$へのマッピングが含まれていますが、混乱を避けるために、再度書き出すことはありません。)
このルールを繰り返し適用すると、スタックの最上位のノードが\texttt{NAp}ノードでなくなるまで、式のスパイン全体がスタックに巻き戻されます。
\vskip\baselineskip
2番目のルールは、スーパーコンビネータの簡約 を実行する方法を説明しています。
\vskip\baselineskip

\begin{tabular} {|c|l r l l l|} \hline
	(2.2) &                   & $a_0 : a_1 : \ldots : a_n : s$                                                                                      & $d$ & $h[a_0 : \texttt{NSupercomb} ~ [x_1, \ldots , x_n] ~ body]$ & $f$ \\
	      & $\Longrightarrow$ & $a_r : s$                                                                                                           & $d$ & $h'$                                                        & $f$ \\
	      &                   & \multicolumn {4} {l|} {where $(h', ~ a_r) = instantiate ~ body ~ h ~ f[x_1 \mapsto a_1, \ldots , x_n \mapsto a_n]$}                                                                           \\ \hline
\end{tabular}
\vskip\baselineskip

このルールへの関心のほとんどは、関数のインスタンス化の中に隠されています。
その引数は次のとおりです。

\begin{itemize}
	\item インスタンス化する式
	\item ヒープ
	\item スタックから取得したアドレスへの引数名のマッピングによって拡張された、ヒープアドレスへの名前のグローバルマッピング$f$
\end{itemize}

新しいヒープと、新しく構築されたインスタンス（のルート）のアドレスを返します。
このような強力な操作は、各ステップが単純なアトミックアクションであることが意図されている状態遷移システムの精神とは実際には異なりますが、それがテンプレートインスタンス化マシンの性質です。
後の章の実装はすべて、真にアトミックなアクションを持ちます！
\vskip\baselineskip
redexのルート自体はこのルールの影響を受けないことに注意してください。
スタック上で結果のルートに置き換えられるだけです。
言い換えると、これらのルールは、グラフ簡約マシンではなく、redexのルートを更新しないツリー簡約マシンを記述しています。
これについては、セクション2.5で後ほど改善します。

\subsubsection{実装の構造}

マシンの仕様がわかったので、その実装に着手する準備が整いました。
\vskip\baselineskip
関数型言語で実装を記述しているので、たとえば、ジョブを実行するために関数\texttt{run}を記述しなければなりません。
そのタイプはどうあるべきですか？
それは、ファイル名を取り、その中でプログラムを実行し、結果を出力する必要があります。
これは、最終結果またはある種の実行トレースのいずれかである可能性があります。
したがって、\texttt{run}のタイプは、次の型シグネチャによって指定されます。

\begin{verbatim}
runProg :: [Char] -> [Char] -- name changed to not conflict
\end{verbatim}

これで、\texttt{run}がどのように構築されるかを考えることができます。
プログラムの実行は、次の4つの段階で構成されます。

\begin{enumerate}
	\item 指定されたファイルにある式からプログラムを解析します。
	      \texttt{parse}関数はファイル名を受け取り、解析されたプログラムを返します。
	      \begin{verbatim}
parse :: [Char] -> CoreProgram
\end{verbatim}
	\item プログラムを実行に適した形式に変換します。
	      このタスクを実行する\texttt{compile}関数は、プログラムを受け取り、テンプレートインスタンス化マシンの初期状態を生成します。
	      \begin{verbatim}
compile :: CoreProgram -> TiState
\end{verbatim}
	      \texttt{tiState}は、テンプレートインスタンス化マシンの状態の型です。(接頭辞「ti」はテンプレートのインスタンス化の略です。)
	\item 最終状態に達するまで状態遷移を繰り返し実行して、プログラムを実行します。
	      結果は、通過したすべての状態のリストです。
	      これから、その後、最終状態を抽出するか、すべての状態のトレースを取得できます。
	      今のところ、結果として数値を返すプログラムに限定するので、この実行関数を\texttt{eval}と呼びます。
	      \begin{verbatim}
eval :: TiState -> [TiState]
\end{verbatim}
	\item 印刷用に結果をフォーマットします。
	      これは、印刷する情報を選択し、それを文字のリストにフォーマットする関数\texttt{showResults}によって実行されます。
	      \begin{verbatim}
showResults :: [TiState] -> [Char]
\end{verbatim}
\end{enumerate}

関数\texttt{run}は、次の4つの関数を組み合わせたものです。

\begin{verbatim}
runProg = showResults . eval . compile . parse -- ``run'': name conflict
\end{verbatim}

これらの各フェーズにサブセクションを割り当てます。

\subsubsection{パーサ}

パーサ関数を含むソース言語は、第1章で定義されている別のモジュール\texttt{language}で定義されています。
モジュールをインポートするために\texttt{\%include}ディレクティブを使用して利用できるようにします。

\begin{verbatim}
-- import Language
\end{verbatim}

\subsubsection{コンパイラ}

このセクションでは、\texttt{compile}関数を定義します。
\texttt{utils}モジュールで定義されたデータ型と関数が必要になるため、\texttt{\%include}を使用して使用できるようにします。

\begin{verbatim}
-- import Utils
\end{verbatim}

次に、コンパイラが操作するデータ型の表現を検討する必要があります。
\vskip\baselineskip

\textbf{データ型}
\vskip\baselineskip

コンパイラは、型\texttt{tiState}を持つマシンの初期状態を生成するため、次に行うことは、型シノニムを使用して、マシンの状態がどのように表されるかを定義することです。

\begin{verbatim}
type TiState = (TiStack, TiDump, TiHeap, TiGlobals, TiState)
\end{verbatim}

マシンの状態は、最初の4つのコンポーネントがセクション2.3.1で指定されたコンポーネントに正確に対応し、5番目のコンポーネントが統計の累積に使用される5つです。
\vskip\baselineskip
次に、これらの各コンポーネントの表現を検討する必要があります。

\begin{itemize}
	\item \textbf{スパインスタック}は、\textbf{ヒープアドレス}の単なるスタックです。
	      \begin{verbatim}
type TiStack = [Addr]
\end{verbatim}
	      スタックをリストとして表すことを選択します。
	      スタックの要素は、\texttt{utils}モジュール(付録A.1)で定義された抽象データ型\texttt{addr}のメンバーです。
	      これらはヒープアドレスを表し、抽象化することで、\texttt{utils}モジュールによって提供される操作のみを使用できるようにします。
	      したがって、たとえば誤ってアドレスに1つ追加することは不可能です。
	\item \textbf{ダンプ}はセクション2.6まで必要ありませんが、後で追加すると状態遷移ルールに多くの面倒な変更が必要になるため、すでに状態の一部にしています。
	      今のところ、引数のない単一のコンストラクタで構成される簡単な型の定義を与えます。
	      \begin{verbatim}
data TiDump = DummyTiDump
initialTiDump = DummyTiDump
\end{verbatim}
	\item \textbf{ヒープ}は、\texttt{utils}モジュールで定義された\texttt{heap}抽象データ型によって表されます。
	      ヒープに含まれるもの、つまり\texttt{node}型のオブジェクト(まだ定義されていません)を指定する必要があります。
	      \begin{verbatim}
type TiHeap = Heap Node
\end{verbatim}
	      ヒープ\texttt{node}は、次の代数的データ型宣言で表されます。
	      これは、セクション2.3.1に記載されている可能性のリストに対応しています。
	      \begin{verbatim}
data Node = NAp Addr Addr                     -- Application
            | NSupercomp Name [Name] CoreExpr -- Supercombinator
            | NNum Int                        -- A number
\end{verbatim}
	      唯一の違いは、スーパーコンビネータの名前を保持するために使用される\texttt{NSupercomb}コンストラクタにタイプ\texttt{name}のフィールドを追加したことです。
	      これは、文書化とデバッグの目的でのみ使用されます。
	\item \textbf{グローバル}コンポーネントは、各スーパーコンビネータ名を、その定義を含むヒープノードのアドレスに関連付けます。
	      \begin{verbatim}
type TiGlobals = ASSOC Name Addr
\end{verbatim}
	      \texttt{assoc}タイプは、その操作とともに\texttt{utils}モジュールで定義されます(付録A.2)。
	      リストの組み込み構文を使用して関連付けを操作できると非常に便利なため、実際には(抽象データ型ではなく)型シノニムとして定義されています。
	      ここでは、抽象化とプログラミングの容易さの間に緊張関係があります。
	\item 状態の\texttt{tiStats}コンポーネントは遷移ルールには記載されていませんが、これを使用して、マシンの動作に関する実行時のパフォーマンス統計を収集します。
	      収集する統計を簡単に変更できるように、抽象型にします。
	      まず、実行したステップ数のみを記録します。
	      \begin{verbatim}
tiStatInitial  :: TiStats
tiStatIncSteps :: TiStats -> TiStats
tiStatGetSteps :: TiStats -> Int
\end{verbatim}
	      実装はかなり単純です。
	      \begin{verbatim}
type TiStats = Int
tiStatInitial    = 0
tiStatIncSteps s = s + 1
tiStatGetSteps s = s
\end{verbatim}
	      便利な関数\texttt{applyToStats}は、特定の関数を状態の統計コンポーネントに適用します。
	      \begin{verbatim}
applyToStats :: (TiState -> TiState) -> TiState -> TiState
applyToStats stats_fun (stack, dump, heap, sc_defs, stats)
  = (stack, dump, heap, sc_defs, stats_fun stats)
\end{itemize}
\end{verbatim}
\end{itemize}

これで、関連するデータ型の定義が完了しました。
\vskip\baselineskip

\textbf{コンパイラ自体}
\vskip\baselineskip

コンパイラの仕事は、プログラムを取得し、そこからマシンの初期状態を作成することです。

\begin{verbatim}
compile program
  = (initial_stack, initialTiDump, initial_heap, globals, tiStatInitial)
    where
      sc_defs = program ++ preludeDefs ++ extraPreludeDefs

      (initial_heap, globals) = buildInitialHeap sc_defs

      initial_stack = [address_of_main]
      address_of_main = aLookup globals "main" (error "main is not defined")
\end{verbatim}

\texttt{where}節の各定義を順番に考えてみましょう。
最初の\texttt{sc\_defs}は、プログラムに含まれるすべてのスーパーコンビネータ定義のリストにすぎません。
\texttt{preludeDefs}はセクション1.4で定義されており、すべてのプログラムに常に含まれている標準のスーパーコンビネータ定義のリストであることを思い出してください。
\texttt{extraPreludeDefs}は、追加したい標準関数のリストです。
今のところそれは空です：

\begin{verbatim}
extraPreludeDefs = []
\end{verbatim}

2番目の定義は、補助関数\texttt{buildInitialHeap}を使用して、
各スーパーコンビネータの名前をそのノードのアドレスにマップする関連付けリスト\texttt{globals}とともに、
各スーパーコンビネータの\texttt{NSupercomb}ノードを含む初期ヒープを構築します。
\vskip\baselineskip
最後に、\texttt{initial\_stack}は、\texttt{globals}から取得されたスーパーコンビネータ\texttt{main}のノードのアドレスである1つの項目のみを含むように定義されています。
\vskip\baselineskip
次に、\texttt{buildInitialHeap}の定義を検討する必要があります。
これは少し注意が必要です。
リスト\texttt{sc\_defs}の要素ごとに何かを行う必要がありますが、厄介なのは、「何か」にヒープの割り当てが含まれることです。
各ヒープ割り当ては新しいヒープを生成するため、\texttt{sc\_defs}の1つの要素から次の要素にヒープを渡す方法を見つける必要があります。
このプロセスは、空のヒープ\texttt{hInitial}(付録A.1)から始まります。
\vskip\baselineskip
このアイデアを高階関数\texttt{mapAccuml}にカプセル化します。
これは、この本で非常に多く使用します。
\texttt{mapAccuml}は3つの引数を取ります：「処理関数」$f$、「アキュムレータ」$acc$、およびリスト$[x_1, \ldots , x_n]$です。
入力リストの各要素を受け取り、それと現在のアキュムレータに$f$を適用します。
$f$は、結果のペア、結果リストの要素、およびアキュムレータの新しい値を返します。
\texttt{mapAccuml}は、$f$の1つの呼び出しから次の呼び出しにアキュムレータを渡し、最終的に2つの結果を返します：
「アキュムレータの最終値」$acc'$と、「結果リスト」$[y_1, \ldots , y_n]$です。
図2.1は、この配管を示しています。
mapAccumlの定義は、付録A.5に記載されています。
\vskip\baselineskip
この場合、「アキュムレータ」はヒープであり、初期値は\texttt{hInitial}です。
リスト$[x_1, \ldots , ~ x_n]$はスーパーコンビネータ定義、\texttt{sc\_defs}であり、
結果リスト$[y_1, \ldots , ~ y_n]$は、スーパーコンビネータの名前とアドレス、\texttt{sc\_addrs}の関連付けです。
ここに、\texttt{buildInitialHeap}の定義があります。

\begin{verbatim}
buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
buildInitialHeap sc_defs = mapAccuml allocateSc hInitial sc_defs
\end{verbatim}

\texttt{allocateSC}と呼ぶ「処理関数」は、
単一のスーパーコンビネータを割り当て、
新しいヒープと\texttt{sc\_addrs}アソシエーションリストのメンバーを返します。

\begin{verbatim}
allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
allocateSc heap (name, args, body)
  = (heap', (name, addr))
    where
      (heap', addr) = hAlloc heap (NSupercomb name args body)
\end{verbatim}

これでコンパイラの定義は完了です。
次に、評価器に注意を向けます。

\subsubsection{評価器}

評価器の\texttt{eval}は、マシンの初期状態を取得し、一度に1ステップずつマシンを実行して、通過したすべての状態のリストを返します。
\vskip\baselineskip

\texttt{eval}は、常に現在の状態を結果の最初の要素として返します。
現在の状態が最終状態の場合、それ以上の状態は返されません。
それ以外の場合、\texttt{eval}は次の状態に再帰的に適用されます。
後者は、(\texttt{step}を使用して)単一のステップを実行し、
次に\texttt{doAdmin}を呼び出して、
ステップ間に必要な管理作業を実行することによって取得されます。

\begin{verbatim}
eval state = state : rest_states
             where
               rest_states | tiFinal state = []
                           | otherwise     = eval next_state
               next_state  = doAdmin (step state)

doAdmin :: TiState -> TiState
doAdmin state = applyToStats tiStatIncSteps state
\end{verbatim}
\vskip\baselineskip

\textbf{最終状態のテスト}
\vskip\baselineskip

関数\texttt{tiFinal}は最終状態を検出します。
スタックに単一のオブジェクトが含まれていて、それが数値またはデータオブジェクトのいずれかである場合にのみ、終了します。
\vskip\baselineskip

\begin{verbatim}
tiFinal :: TiState -> Bool

tiFinal ([sole_addr], dump, heap, globals, stats)
  = isDataNode (hLookup heap sole_addr)

tiFinal ([], dump, heap, globals, stats) = error "Empty stack!"
tiFinal state = False --Stack contains more than one item
\end{verbatim}

スタック要素はアドレスであることに注意してください。
これは、数値であるかどうかを確認する前に、ヒープで検索する必要があります。
スタックが空である必要がある場合(これは決して発生しないはずです)にも、適切なエラーメッセージを生成する必要があります。
\vskip\baselineskip

最後に、\texttt{isDataNode}を定義できます。

\begin{verbatim}
isDataNode :: Node -> Bool
isDataNode (NNum n) = True
isDataNode node     = False
\end{verbatim}

\textbf{ステップを進める}
\vskip\baselineskip

関数\texttt{step}は、ある状態をその後続状態に写像します。
\vskip\baselineskip

\begin{verbatim}
step :: TiState -> TiState
\end{verbatim}

スパインスタックの最上位のノードでケース分析を行う必要があるため、
ヒープからこのノードを抽出し、\texttt{dispatch}を使用して適切な関数を呼び出し、ノードの各形式のハードワークを実行します。

\begin{verbatim}
step state
  = dispatch (hLookup heap (hd stack))
      where
        (stack, dump, heap, globals, stats) = state
        dispatch (NNum n)                   = numStep state n
        dispatch (NAp a1 a2)                = apStep  state a1 a2  -- 状態遷移ルール 2.1
        dispatch (NSupercomb sc args body)  = scStep  state sc args body -- 状態遷移ルール 2.2
\end{verbatim}

数値や関数適用のケースもほとんどトラブルなく対応できます。
数値を関数として適用してはならないため、スタックの最上位に数値があるのはエラーです。
(スタック上の唯一のオブジェクトである場合、実行は\texttt{tiFinal}によって停止されます。)

\begin{verbatim}
numStep :: TiState -> Int -> TiState
numStep state n
  = error "Number applied as a function!"
\end{verbatim}

関数適用ノードの処理は、アンワインドルール(ルール2.1)で説明されており、Mirandaに直接変換できます。

\begin{verbatim}
apStep :: TiState -> Addr -> Addr -> TiState
apStep (stack, dump, heap, globals, stats) a1 a2
  = (a1 : stack, dump, heap, globals, stats)
\end{verbatim}

\textbf{スーパーコンビネータの適用}
\vskip\baselineskip

スーパーコンビネータを適用するには、
その本体をインスタンス化し、
引数名をスタック内の引数アドレスにバインドする必要があります(ルール2.2)。
次に、redexのルートを含む引数をスタックから破棄し、
代わりにリダクションの結果(のルート)をスタックにプッシュします。
(この最初のバージョンのマシンでは、更新を実行していないことに注意してください。)
\vskip\baselineskip

\begin{verbatim}
scStep :: TiState -> Name -> [Name] -> CoreExpr -> TiState
scStep (stack, dump, heap, globals, stats) sc_name arg_names body
  = (new_stack, dump, new_heap, globals, stats)
    where
      new_stack               = result_addr : (drop (length arg_names + 1) stack)
      (new_heap, result_addr) = instantiate body heap env
      env                     = arg_bindings ++ globals
      arg_bindings            = zip2 arg_names (getargs heap stack)
\end{verbatim}

スーパーコンビネータとプリミティブを適用するには、補助関数が必要です。
関数\texttt{getArgs}は、スタック(関数適用ノードのスタックの最上位にあるスーパーコンビネータで構成されている必要があります)を受け取り、
スタック上の各関数適用ノードの引数から形成されたリストを返します。

\begin{verbatim}
-- now getargs since getArgs conflicts with Gofer standard.prelude
getargs :: TiHeap -> TiStack -> [Addr]
getargs heap (sc : stack)
  = map get_arg stack
    where
      get_arg addr = arg
                     where
                       (NAp fun arg) = hLookup heap addr
\end{verbatim}

\texttt{instantiate}関数は、式、ヒープ、および名前とアドレスを関連付ける環境を取ります。
ヒープ内に式のインスタンスを作成し、インスタンスのルートの新しいヒープとアドレスを返します。
この環境は、\texttt{instantiate}によって、スーパーコンビネータとローカル変数の代わりに使用されるアドレスを指定するために使用されます。

\begin{verbatim}
instantiate :: CoreExpr           -- Body of supercombinator
               -> TiHeap          -- Heap before instantiation
               -> ASSOC Name Addr -- Association of names to addresses
               -> (TiHeap, Addr)  -- Heap after instantiation,
                                  --   and address of root of instance
\end{verbatim}

数字の場合は、非常に簡単です。

\begin{verbatim}
instantiate (ENum n) heap env = hAlloc heap (NNum n)
\end{verbatim}

関数適用の場合も簡単です。 2つのブランチをインスタンス化し、関数適用ノードを構築するだけです。
\texttt{instantiate}の再帰呼び出しを介して、ヒープを「スレッド化」する方法に注目してください。
つまり、\texttt{instantiate}の最初の呼び出しにヒープが与えられ、新しいヒープが生成されます。
後者は、\texttt{instantiate}の2番目の呼び出しに与えられ、さらに別のヒープを生成します。
後者は、新しい関数適用ノードが割り当てられるヒープであり、呼び出し元に返される最終ヒープを生成します。

\begin{verbatim}
instantiate (EAp e1 e2) heap env
  = hAlloc heap2 (NAp a1 a2)
    where
      (heap1, a1) = instantiate e1 heap  env
      (heap2, a2) = instantiate e2 heap1 env
\end{verbatim}

変数の場合、指定された環境で名前を検索するだけで、バインディングが見つからない場合は適切なエラーメッセージが生成されます。

\begin{verbatim}
instantiate (EVar v) heap env
  = (heap, aLookup env v (error ("Undefined name " ++ show v)))
\end{verbatim}

Appendix A.2で定義されている\texttt{aLookup}は、連想リストで変数を検索しますが、検索が失敗した場合は3番目の引数を返します。

\begin{verbatim}
instantiate (EConstr tag arity) heap env
  = instantiateConstr tag arity heap env
instantiate (ELet isrec defs body) heap env
  = instantiateLet isrec defs body heap env
instantiate (ECase e alts) heap env
  = error "Can't instantiate case exprs"
\end{verbatim}

コンストラクタと\texttt{let(rec)}式をインスタンス化する問題を延期するために、
補助関数\texttt{instantiateConstr}と\texttt{instantiateLet}を呼び出します。
これらはそれぞれ、現在のエラーを生成します。
後で、それらを運用定義に置き換えます。
最後に、後で説明するように、テンプレートマシンは\texttt{case}式をまったく処理できません。

\begin{verbatim}
instantiateConstr tag arity heap env
  = error "Can't instantiate constructors yet"
instantiateLet isrec defs body heap env
  = error "Can't instantiate let(rec) yet"
\end{verbatim}

\subsubsection{結果の書式付け}

\texttt{eval}からの出力は状態のリストであり、全体を表示するとかなり大量になります。
さらに、ヒープとスタックは抽象オブジェクトであるため、Mirandaはそれらをまったく表示しません。
したがって、\texttt{showResults}関数は、セクション1.5で紹介した\texttt{iseq}データ型を使用して、出力をフォーマットします。

\begin{verbatim}
showResults :: [TiState] -> [Char]
showResults states
  = iDisplay (iConcat [ iLayn (map showState states),
                        showStats (last states)
                      ])
\end{verbatim}

スタックの内容を表示するだけで状態を表示します。
各ステップの後にヒープ全体を表示するのは面倒なので、スタックから直接参照されるノードの内容を表示することで満足します。
状態の他のコンポーネントは変更されないため、それらも表示しません。

\begin{verbatim}
showState :: TiState -> Iseq
showState (stack, dump, heap, globals, stats)
  = iConcat [ showStack heap stack, iNewline ]
\end{verbatim}

スタック上のアドレスと、それが指すノードの内容を表示することにより、スタックを最上位の要素から最初に表示します。
これらのノードのほとんどは関数適用ノードであり、これらのそれぞれについて、引数ノードの内容も表示します。

\begin{verbatim}
showStack :: TiHeap -> TiStack -> Iseq
showStack heap stack
  = iConcat [ iStr "stk [",
              iIndent (iInterleave iNewline (map show_stack_item stack)),
              iStr " ]"
            ]
    where
      show_stack_item addr
        = iConcat [ showFWAddr addr,
                    iStr ": ",
                    showStkNode heap (hLookup heap addr)
                  ]

showStkNode :: TiHeap -> Node -> Iseq
showStkNode heap (NAp fun_addr arg_addr)
  = iConcat [ iStr "NAp ",
              showFWAddr fun_addr,
              iStr " ",
              showFWAddr arg_addr,
              iStr " (",
              showNode (hLookup heap arg_addr),
              iStr ")"
            ]
showStkNode heap node = showNode node
\end{verbatim}

\texttt{showNode}は、ノードの値を表示します。
完全な値を出力するのではなく、\texttt{NSupercomb}ノード内に格納されている名前のみを出力します。
実際、これが名前がこれらのノード内に保存される唯一の理由です。

\begin{verbatim}
showNode :: Node -> Iseq
showNode (NAp a1 a2)
  = iConcat [ iStr "NAp ",
              showAddr a1,
              iStr " ",
              showAddr a2
            ]
showNode (NSupercomb name args body)
  = iStr ("NSupercom " ++ name)
showNode (NNum n)
  = (iStr "NNum ") `iAppend` (iNum n)

showAddr :: Addr -> Iseq
showAddr addr = iStr (show addr)

showFWAddr :: Addr -> Iseq -- Show address in field of width 4
showFWAddr addr
  = iStr (space (4 - length str) ++ str)
    where
      str = show addr
\end{verbatim}

\texttt{showStats}は、累積された統計を出力する責任があります。

\begin{verbatim}
showStats :: TiState -> Iseq
showStats (stack, dump, heap, globals, stats)
  = iConcat [ iNewline,
              iNewline,
              iStr "Total number of steps = ",
              iNum (tiStatGetSteps stats)
            ]
\end{verbatim}

\begin{description}
	\item [演習 2.4] これまでに与えられた実装をテストします。
	      適切なテストプログラムは次のとおりです。

	      \begin{verbatim}
        main = S K K 3
\end{verbatim}

	      結果は3になります。
	      さらにいくつかのテストプログラムを考案し、それらが機能することを確認します。
	      算術演算はまだ定義されていないことを忘れないでください。
	\item [演習 2.5] ヒープの内容全体を出力するように\texttt{showState}を変更します。
	      (ヒント：ヒープ内のすべてのノードのアドレスを検出するには、\texttt{hAddresses}を使用します。)
	      このようにして、ヒープが1つのステップから次のステップにどのように進化するかを確認できます。
	\item [演習 2.6] スーパーコンビネータまたはプリミティブが適用される引数が少なすぎると、\texttt{scStep}は失敗します。
	      このケースを検出するために、適切なチェックとエラーメッセージを\texttt{scStep}に追加します。
	\item [演習 2.7] より多くの実行統計を収集するようにインタープリタを変更します。
	      たとえば、次のような統計情報を累積できます。

	      \begin{itemize}
		      \item 簡約の数。
		            おそらくスーパーコンビネータの簡約とプリミティブの簡約に分けられます。
		      \item 各種類のヒープ操作の数、特に割り当て。
		            これを行う最も便利な方法は、\texttt{heap}抽象データ型を変更してこの情報自体を累積することですが、
		            これは結果の一部として新しいヒープを返すヒープ操作でのみ機能します。
		      \item 最大スタック深度。
	      \end{itemize}

	\item [演習 2.8] \texttt{scStep}の定義では、\texttt{instantiate}に渡される環境\texttt{env}は次のように定義されます。

	      \begin{verbatim}
      env = arg\_bindings ++ globals
\end{verbatim}

	      \texttt{++}の引数を逆にすると、どのような違いがありますか？
	\item [演習 2.9] (少し注意が必要です。)
	      次の\texttt{eval}の定義は、与えられたものよりも明白だと思うかもしれません。
	      \begin{verbatim}
  eval state = [state],                 tiFinal state
             = state : eval next_state, otherwise
\end{verbatim}

	      (\texttt{next\_state}は以前と同じように定義されています)。
	      なぜこれが劣った定義なのですか？
	      (ヒント：すべての状態が\texttt{showResults}によってフォーマットされていて、
	      存在しないヒープノードにアクセスしようとするなど、
	      \texttt{tiFinal state}を評価するときにエラーが発生した場合にどうなるかを考えてください。
	      エラーの原因となった状態が出力されますか？
	      そうでない場合は、なぜですか？)
\end{description}
\newpage

\subsection{Mark 2: \texttt{let(rec)} 式}

最初の機能強化は、マシンが\texttt{let}および\texttt{letrec}式を処理できるようにすることです。
2.1.4で説明したように、スーパーコンビネータの本体には、グラフのテキスト記述とみなされる\texttt{let(rec)}式が含まれる場合があります。
\vskip\baselineskip

したがって、実装に加える必要がある唯一の変更は、インスタンス化を拡張することであり、その結果、\texttt{Elet}コンストラクの等式が得られます。

\begin{description}
	\item [演習 2.10] \textbf{非再帰的}な\texttt{let}式用の\texttt{instantiate}関数定義を追加します。
	      インスタンス化するために必要なこと(\texttt{ELet nonRecursive defs body})は次のとおりです。
	      \begin{enumerate}
		      \item \texttt{defs}の各定義の右辺をインスタンス化します。
		      \item 環境を拡張して、\texttt{defs}の名前を新しく構築されたインスタンスのアドレスにバインドします。
		      \item 拡張した環境と式本体を渡す\texttt{instantiate}を呼び出します。
	      \end{enumerate}
\end{description}

これはまだ\texttt{let}式のみを処理します。
\texttt{letrec}式をインスタンス化した結果は\textbf{閉路}グラフですが、let式は閉路グラフを生成するもとになります。

\begin{description}
	\item [演習 2.11] 非再帰的\texttt{ELet}用\texttt{instantiate}関数の定義をコピーし、
	      再帰的な場合に機能するように変更します(または、両方を処理するように定義を変更します)。
	      (ヒント：ステップ1で、既存の環境の代わりに拡張環境(ステップ2で構築)を渡してインスタンス化することを除いて、
	      letの場合とまったく同じようにすべてを実行します。)
\end{description}

この演習のヒントは、ステップ2で作成された名前とアドレスのバインディングをステップ1への入力として使用する必要があるため、不思議に思われます。
Mirandaでこれを試してみると、すべてが完全に機能します。
これは、他の非厳密な関数型言語と同様に、関数を呼び出す前に関数への入力を評価する必要がないためです。
実際の実装では、\texttt{letrec}内の各(ルート)ノードが割り当てられるアドレスを計算し、この情報を反映するように環境を拡張してから
、定義式の右辺をインスタンス化することにより、このトリックを「手動で」実行する必要があります。
\vskip\baselineskip

実装が機能するかどうかを確認するためのテストプログラムを次に示します。

\begin{verbatim}
  pair x y f = f x y ;
  fst p = p K ;
  snd p = p K1 ;
  f x y = letrec
              a = pair x b ;
              b = pair y a
          in
          fst (snd (snd (snd a))) ;
  main = f 3 4
\end{verbatim}

結果は4になります。
このプログラムがどのように機能するか理解できますか？
(すべてはセクション2.8.3で明らかにされます。)

\begin{description}
	\item [演習 2.12] 次のプログラムを検討します。

	      \begin{verbatim}
  main = letrec f = f x in f
\end{verbatim}

	      このプログラムを実行するとどうなりますか？
	      この問題は、Mirandaのような強く型付けされた言語で発生する可能性がありますか？
\end{description}
\newpage

\subsection{Mark 3: 更新機能の追加}

これまでのところ簡約器は更新を実行しないため、共有部分は何度も評価される可能性があります。
\vskip\baselineskip
セクション2.1.5で説明した様に、問題を解決する最も簡単な方法は、結果を指す間接ノードでredexのルートを更新することです。
\vskip\baselineskip

\begin{tabular} {|c|l r l l l|} \hline
	(2.3) &                   & $a_0 : a_1 : \ldots : a_n : s$                                                                                      & $d$ & $h[a_0 : \texttt{NSupercomb} ~ [x_1, \ldots , x_n] ~ body]$ & $f$ \\
	      & $\Longrightarrow$ & $a_r : s$                                                                                                           & $d$ & $h'[a_n : \texttt{NInd} ~ a_r]$                             & $f$ \\
	      &                   & \multicolumn {4} {l|} {where $(h', ~ a_r) = instantiate ~ body ~ h ~ f[x_1 \mapsto a_1, \ldots , x_n \mapsto a_n]$}                                                                           \\ \hline
\end{tabular}
\vskip\baselineskip

違いは、\textbf{インスタンス化}関数によって返されるヒープ$h'$は、
ノード$a_n$(redexのルート)を$a_r$(\textbf{インスタンス化}によって返される結果のルート)への間接参照で上書きすることによってさらに変更されることです。
スーパーコンビネータがCAF(セクション2.1.6を参照)の場合、$n = 0$であり、変更されるノードはスーパーコンビネータノード自体であることに注意してください。
\vskip\baselineskip

さらに1つの変更が必要です。
スパインをほどくときに間接に遭遇する可能性があるため、この場合に対処するために新しいルールを追加する必要があります。
\vskip\baselineskip

\begin{tabular} {|c|l r l l l|} \hline
	(2.4) &                   & $a : s$   & $d$ & $h[a : \texttt{NInd} ~ a_1]$ & $f$ \\
	      & $\Longrightarrow$ & $a_1 : s$ & $d$ & $h$                          & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

間接ノードのアドレス$a$は、あたかもそこになかったかのように、スタックから削除されます。
\vskip\baselineskip

これらの新しいルールを実装するには、いくつかのことを行う必要があります。

\begin{itemize}
	\item 新しいノードコンストラクター\texttt{NInd}を\texttt{node}データ型に追加します。
	      これにより、次の改訂された定義が得られます。
	      \begin{verbatim}
data Node = NAp Addr Addr                   -- Application
          | NSupercomb Name [Name] CoreExpr -- Supercombinator
          | NNum Int                        -- Number
          | NInd Addr                       -- Indirection
\end{verbatim}
	      この余分なコンストラクターを考慮に入れるために、\texttt{showNode}に新しい定義式を追加する必要があります。
	\item 結果への間接参照でredexのルートを更新するために\texttt{hUpdate}を使用するように\texttt{scStep}を変更します(ルール2.3)。
	\item 間接化に対処するために、\texttt{dispatch}の定義に新な定義式を追加します(ルール2.4)。
\end{itemize}

\begin{description}
	\item[演習 2.13] 間接ノードで更新を実行するように変更を加えます。
		リダクションマシンのMark1バージョンとMark3バージョンの両方で次のプログラムを実行して、変更の効果を試してください。
		\begin{verbatim}
        id x = x ;
        main = twice twice id 3
\end{verbatim}
		(\texttt{twice}は\texttt{preludeDefs}(セクション1.4)で定義されていることを思い出してください。)
		最初に手でそれを簡約することによって何が起こるかを理解するようにしてください。
		\texttt{main}を\texttt{twice twice twice id3}と定義するとどうなりますか？
\end{description}

\subsubsection{間接参照の数を減らす}

多くの場合、\texttt{instantiate}によって(または、後で説明するように、プリミティブによって)新しく作成されたノードへの間接参照を使用して、redexのルートを更新します。
このような状況では、間接参照を使用するのではなく、結果のルートノードをredexのルートの上に直接構築する方が安全です。
結果のルートが新しく作成されるため、これを行うことで共有が失われることはなく、余分な間接ノードを構築(およびその後トラバース)する手間が省けます。
\vskip\baselineskip

これを行うには、新しいインスタンス化関数\texttt{instantiateAndUpdate}を定義します。
これは、追加の引数、結果で更新されるノードのアドレスを取り、結果のグラフのアドレスを返さないことを除いて、\texttt{instantiate}と同じです 。

\begin{verbatim}
instantiateAndUpdate
    :: CoreExpr           -- Body of supercombinator
       -> Addr            -- Address of node to update
       -> TiHeap          -- Heap before instantiation
       -> ASSOC Name Addr -- Associate parameters to addresses
       -> TiHeap          -- Heap after instantiation
\end{verbatim}

たとえば、式が関数適用の場合のインスタンス化と更新の定義は次のとおりです。

\begin{verbatim}
instantiateAndUpdate (EAp e1 e2) upd_addr heap env
  = hUpdate heap2 upd_addr (NAp a1 a2)
    where
    (heap1, a1) = instantiate e1 heap env
    (heap2, a2) = instantiate e2 heap1 env
\end{verbatim}

再帰的なインスタンス化は、古いインスタンス化によって引き続き実行されることに注意してください。
ルートノードのみを更新する必要があります。

\begin{description}
	\item[演習 2.14] \texttt{instanceiateAndUpdate}の定義を完了します。
		次の点には少し注意が必要です。

		\begin{itemize}
			\item インスタンス化される式が単純な変数である場合でも、間接参照を使用する必要があります。
			      なんで？
			\item \texttt{let(rec)}式の方程式の再帰的なインスタンス化について慎重に検討してください。
		\end{itemize}

		\texttt{scStep}を変更して、インスタンス化の代わりに\texttt{instantiateAndUpdate}を呼び出し、更新するノードのアドレスとしてredexのルートを渡します。
		\texttt{scStep}自体から更新コードを削除します。
		削減の数と割り当てられたヒープノードの数に対するこの変更の影響を測定します。
\end{description}
\newpage

\subsection{Mark 4: 算術演算機能の追加}

このセクションでは、算術プリミティブを追加します。
これには、初めてダンプを使用することが含まれます。

\subsubsection{算術演算の遷移規則}

\subsubsection{算術演算の実装}

算術演算を実装するには、いくつかの変更を加える必要があります。
まず、型\texttt{tiDump}を、初期値が空のスタックのスタックに再定義する必要があります。
\begin{verbatim}
type TiDump = [TiStack]
initialTiDump = []
\end{verbatim}
次に、新しい種類のヒープノードを追加する必要があります。
\texttt{NPrim n p}は、名前が\texttt{n}で、値が\texttt{p}であるプリミティブを表します。
ここで、\texttt{p}はプリミティブタイプです。
\texttt{NSupercomb}ノードの場合と同様に、名前はデバッグと文書化の理由でのみ\texttt{NPrim}ノードに存在します。
\begin{verbatim}
data Node = NAp Addr Addr                   -- Application
          | NSupercomb Name [Name] CoreExpr -- Supercombinator
          | NNum Int                        -- Number
          | NInd Addr                       -- Indirection
          | NPrim Name Primitive            -- Primitive
\end{verbatim}
いつものように、\texttt{NPrim}ノードを表示するには、\texttt{showNode}も拡張する必要があります。
前のセクションで示した遷移ルールは、データ型\texttt{primitive}を次のように定義する必要があることを示しています。
\begin{verbatim}
data Primitive = Neg | Add | Sub | Mul | Div
\end{verbatim}
必要なプリミティブごとに1つのコンストラクターを使用します。
\vskip\baselineskip
ここで、各スーパーコンビネータの初期ヒープに\texttt{NSupercomb}ノードを割り当てる必要があるのと同じように、
各プリミティブの初期ヒープに\texttt{NPrim}ノードを割り当てる必要があります。
次に、マシン状態の\textbf{グローバル}コンポーネントに追加のバインディングを追加できます。
これにより、スーパーコンビネータの場合と同様に、各プリミティブの名前がそのノードのアドレスにマップされます。
次のように\texttt{buildInitialHeap}の定義を変更することで、これを簡単に行うことができます。
\begin{verbatim}
buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
buildInitialHeap sc_defs
  = (heap2, sc_addrs ++ prim_addrs)
    where
      (heap1, sc_addrs)   = mapAccuml allocateSc Initial sc_defs
      (heap2, prim_addrs) = mapAccuml allocatePrim heap1 primitives
\end{verbatim}
変数名からプリミティブへのマッピングを提供する関連付けリストを定義します。
したがって、次のようになります。
\begin{verbatim}
primitives :: ASSOC Name Primitive
primitives = [ ("negate", Neg),
               ("+", Add), ("-", Sub),
               ("*", Mul), ("/", Div)
             ]
\end{verbatim}
さらにプリミティブを追加するには、\texttt{primitive}型にコンストラクターを追加し、\texttt{primitives}関連付けリストに要素を追加します。
\vskip\baselineskip
次に、\texttt{allocateSc}を定義したのと同じように、\texttt{allocatePrim}を定義できます。
\newpage

\subsection{Mark 5: 構造化データ型の追加}

このセクションでは、構造化データ型をリダクションマシンに追加します。
コア言語の\texttt{case}式の実装を提供するのは良いことですが、テンプレートインスタンス化マシンのフレームワーク内で実装するのはかなり難しいことがわかりました。
(後の実装ではこの問題は発生しません。)
代わりに、\texttt{if}, \texttt{casePair}, \texttt{caseList}などの組み込み関数のコレクションを使用して、特定の構造化型を操作できるようにします。
テンプレートマシンは、一般的な構造化オブジェクトを処理できません。

\begin{description}
	\item[演習 2.18] テンプレートインスタンス化マシンにcase式を導入するのが難しいのはなぜですか？
		(ヒント：インスタンス化が\texttt{case}式で何をするかを考えてください。)
\end{description}

\subsubsection{構造化データの構築}

構造化データは、コンストラクターのファミリー\texttt{Pack\{\textit{t}, \textit{a}\}}で構築されます。
ここで、\textit{t}はコンストラクターのタグを示し、\textit{a}はそのアリティを示します（セクション1.1.4）。
したがって、グラフでこれらのコンストラクター関数を表現する必要があります。
これらは実際には新しい形式のプリミティブであるため、プリミティブ型に新しいコンストラクタ\texttt{PrimConstr}を追加することでこれを行うことができます。
これで、\texttt{instantiateConstr}の式で、式\texttt{EConstr \textit{t} \textit{a}}を
ヒープノード\texttt{NPrim "Pack"（PrimConstr \textit{t} \textit{a}）}にインスタンス化できます。
\vskip\baselineskip
次に、このプリミティブがどのように実装されているかという疑問が生じます。
新しい補助関数\texttt{primConstr}を呼び出す\texttt{PrimConstr}コンストラクターと一致するように、\texttt{primStep}にケースを追加する必要があります。
これにより、十分な引数が指定されていることを確認し、指定されている場合は、ヒープ内に構造化データオブジェクトを構築します。
\vskip\baselineskip
次に、このプリミティブがどのように実装されているかという疑問が生じます。
新しい補助関数\texttt{primConstr}を呼び出す\texttt{PrimConstr}コンストラクターと一致するように、\texttt{primStep}にケースを追加する必要があります。
これにより、十分な引数が指定されていることを確認し、指定されている場合は、ヒープ内に構造化データオブジェクトを構築します。
\vskip\baselineskip
これを行うには、構造化データオブジェクトを表す新しいコンストラクタ\texttt{NData}をノードタイプに追加する必要があります。
\texttt{NData}コンストラクタには、オブジェクトのタグとそのコンポーネントが含まれています。

\begin{verbatim}
data Node = NAp Addr Addr                   -- Application
          | NSupercomb Name [Name] CoreExpr -- Super combinator
          | NNum Int                        -- Number
          | NInd Addr                       -- Indirection
          | NPrim Name Primitive            -- Primitive
          | NData Int [Addr]                -- Tag, list of components
\end{verbatim}

これで、\texttt{NPrim (PrimConstr \textit{t} \textit{n})}のルールを指定できます。
\vskip\baselineskip

\begin{tabular} {|c|l r l l l|} \hline
	(2.10) &                   & $a_0 : a_1 : \ldots : a_n : []$ & $d$ & $h\left[
			\begin{array}{l}
				a   : \texttt{NPrim} ~ (\texttt{PrimConstr} ~ \textit{t} ~ \textit{n}) \\
				a_1 : \texttt{NAp} ~ a ~ b_1                                           \\
				$\ldots$                                                               \\
				a_n : \texttt{NAp} ~ a_{n-1} ~ b_n
			\end{array}
			\right]
	$      & $f$                                                                                                                   \\
	       & $\Longrightarrow$ & $a_n : []$                      & $d$ & $h[a_n : \texttt{NData} ~ t ~ [b_1, \ldots , b_n]]$ & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

構造化オブジェクトの構築についてはこれだけです。
次の質問は、それらをどのように分解するかです。
これは、コア言語の\texttt{case}式で表されます。
すでに述べたように、\texttt{case}式を直接実装するのは難しいため、
ブール値から始まるいくつかの特殊なケースに満足しています。

\subsubsection{条件式}

ブール型は、Mirandaで次のように宣言される可能性があります。

\begin{verbatim}
        boolean ::= False | True
\end{verbatim}

\texttt{True}と\texttt{False}の2つのコンストラクタがあります。
それぞれアリティは0であり、タグ1を\texttt{False}に、タグ2を\texttt{True}に任意に割り当てます。
したがって、次のコア言語定義を与えることができます。

\begin{verbatim}
        False = Pack{1, 0}
        True = Pack{2, 0}
\end{verbatim}

一般的な\texttt{case}式を使用することはできないため、次の簡約ルールを使用して条件付きプリミティブを追加するだけで十分です。

\begin{verbatim}
        if Pack{2, 0} t e = t
        if Pack{1, 0} t 3 = e
\end{verbatim}

動作上、データオブジェクトであると想定される最初の引数を評価し、タグを調べ、
タグが2(\texttt{True})または1(\texttt{False})のどちらであるかに応じて、2番目または3番目の引数を選択します。

\begin{description}
	\item[演習 2.19] 条件付きプリミティブの状態遷移ルールを記述します。
		3つのルールが必要です。
		ブール条件がすでに評価されている場合に削減を実行するための2つのルール。
		1つは、条件が評価されていない場合に、古いスタックをダンプにプッシュし、
		条件のアドレスを新しい空のスタックにプッシュすることによって評価を開始します（ルール2.9を参照）。
		最初の2つのルールの更新では、間接参照を使用する必要があることに注意してください。
		もう1つのルールがありません。
		それは何ですか？
		（ヒント：条件の評価が完了すると、条件はどのように再試行されますか？）
\end{description}

\texttt{if}があれば、それと\texttt{False}および\texttt{True}に関して、他のブール演算子のコア言語定義を与えることができます。
例えば：

\begin{verbatim}
        and x y = if x y False
\end{verbatim}

\begin{description}
	\item[演習 2.20] \texttt{or}、\texttt{xor}および\texttt{not}のコア言語定義を指定します。
		これらのコア言語定義をすべて\texttt{extraPreludeDefs}に追加します。
\end{description}

最後に、数値を比較する何らかの方法が必要です。
これには、新しいプリミティブ\texttt{>}、\texttt{>=}などが必要です。

\subsubsection{構造化データの実装}

構造化データオブジェクト、条件、比較操作を追加するために実装に必要な変更のリストを次に示します。

\begin{itemize}
	\item \texttt{NData}コンストラクターを\texttt{node}データ型に追加します。
	      \texttt{showNode}を拡張して、\texttt{NData}ノードを表示します。
	\item \texttt{PrimConstr}、\texttt{If}、\texttt{Greater}、\texttt{GreaterEq}、\texttt{Less}、\texttt{LessEq}、
	      \texttt{Eq}、\texttt{NotEq}を\texttt{primitive}型に追加します。
	      最初のものを除くすべての場合、\texttt{primitive}の関連付けリストに適切なペアを追加して、
	      これらのプリミティブの名前を\texttt{instantiateVar}によってそれらの値にマップできるようにします。
	\item \texttt{instanceiateConstr}(および必要に応じて\texttt{instantiateAndUpdateConstr})の定義を追加します。
	\item \texttt{isDataNode}関数は、\texttt{NNum}ノードだけでなく\texttt{NData}ノードも識別する必要があります。
	\item \texttt{step}の\texttt{dispatch}コードには、新しい補助関数\texttt{dataStep}を呼び出す、\texttt{NData}ノードの追加のケースが必要です。
	\item \texttt{dataStep}の定義; \texttt{numStep}と非常によく似ています。
	\item \texttt{primStep}を拡張して、新しいプリミティブ\texttt{PrimConstr}、\texttt{If}、\texttt{Greater}などに対応します。
	      \texttt{PrimConstr}と\texttt{If}の場合、新しい補助関数\texttt{primConstr}と\texttt{primIf}を呼び出す必要があります。
	      比較プリミティブは、\texttt{primArith}をほとんど使用できますが、完全には使用できません。
	      必要なのは、\texttt{primArith}のわずかな一般化です。
	      \begin{verbatim}
primDyadic :: TiState -> (Node -> Node -> Node) -> TiState
\end{verbatim}
	      これは、数値を組み合わせる関数ではなく、ノードを組み合わせる関数を取ります。
	      \texttt{primDyadic}に関して、\texttt{primArith}と同様の関数\texttt{primComp}を比較プリミティブとして定義するのは簡単です。
	      そして、\texttt{primArith}の定義を一般化することによって\texttt{primDyadic}を定義します。
\end{itemize}

\begin{description}
	\item[演習 2.21] これらすべての変更を行います。
		再帰を終了する条件があるので、ついに、賢明な再帰関数を書くことができます。
		たとえば、階乗関数を試してください
		\begin{verbatim}
        fac n = if (n == 0) 1 (n * fac (n-1)) ;
        main = fac 3
\end{verbatim}
\end{description}

\subsubsection{ペア}

ブール値のコンストラクタは両方ともアリティが0となっています。
次に、ペアのデータ型を追加します。
これは、Mirandaで次のように宣言される可能性があります。

\begin{verbatim}
        pair * ** ::= MkPair * **
\end{verbatim}

\texttt{Pack {1, 2}}コンストラクタを使用してペアを作成できます。

\begin{verbatim}
        MkPair = Pack{1, 2}
\end{verbatim}

\texttt{case}式を使わずに、それらを分解してみませんか？
たとえば、\texttt{case}式を含む次のコア言語プログラムについて考えてみます。

\begin{verbatim}
        f p = case p of
                <1> a b -> b*a*a end
\end{verbatim}

\texttt{case}式がないため、代わりに次のように翻訳できます。

\begin{verbatim}
        f p = casePair p f'
        f' a b = b*a*a
\end{verbatim}

ここで、\texttt{f'}は補助関数であり、\texttt{casePair}は次のように定義された組み込みのプリミティブです。

\begin{verbatim}
        casePair (Pack{1, 2} a b) f = f a b
\end{verbatim}

操作上、\texttt{casePair}は最初の引数を評価します。
これはペアを生成することを期待しています。
次に、2番目の引数をペアの2つのコンポーネントに適用します。
これを実装するには、プリミティブ型にさらに別のコンストラクタ\texttt{PrimCasePair}を追加し、それを処理するコードをさらに記述します。
\vskip\baselineskip

たとえば、次のコア言語定義を使用して、ペアの1番目と2番目のコンポーネントを抽出する\texttt{fst}と\texttt{snd}を定義できます。

\begin{verbatim}
        fst p = casePair p K
        snd p = casePair p K1
\end{verbatim}

\begin{description}
	\item[演習 2.22] \texttt{casePair}の状態遷移ルールを記述します。
		いつものように、2つのルールが必要になります。
		1つは最初の引数が評価された場合に削減を実行し、もう1つは評価されなかった場合にその評価を開始します。
		上記のように、ペアを実装するために必要な変更を加えます。
		次のプログラム(および独自の他のプログラム)を使用して実装をテストします。
		\begin{verbatim}
main = fst (snd (fst (MkPair (MkPair 1 (MkPair 2 3)) 4)))
\end{verbatim}
\end{description}

\subsubsection{リスト}

ペアとブール値を作成したので、リストは簡単なはずです。
リストのデータ型は、Mirandaで次のように定義されている可能性があります。

\begin{verbatim}
        list * ::= Nil | Cons * (list *)
\end{verbatim}

タグ1をNilに、タグ2をConsに割り当てます。
\vskip\baselineskip
唯一の問題は、リストを分解する\texttt{caseList}プリミティブが正確に何をすべきかということです。
\texttt{casePair}には、ペアのコンポーネントを引数として取る関数である「継続」が1つあることを思い出してください。
\texttt{if}には2つの「継続」があり、最初の引数の値に応じていずれかを選択します。
したがって、\texttt{caseList}は、これら両方のアイデアを組み合わせたものにすぎません。

\begin{verbatim}
        caseList Pack{1, 0}        cn cc = cn
        caseList (Pack{2, 2} x xs) cn cc = cc x xs
\end{verbatim}

3つの引数を取り、最初の引数を評価します。
それが空のリストである場合(つまり、タグが1でコンポーネントがない場合)、
\texttt{caseList}は単に2番目の引数\texttt{cn}を選択します。
それ以外の場合は、リストセル(つまり、タグが2でコンポーネントが2つ)である必要があり、
\texttt{caseList}は3番目の引数をこれらのコンポーネントに適用します。
\vskip\baselineskip
たとえば、Mirandaで記述される\texttt{length}関数を実装したいとします。

\begin{verbatim}
        length [] = 0
        length (x : xs) = 1 + length xs
\end{verbatim}

\texttt{caseList}を使用すると、次のように\texttt{length}を記述できます。

\begin{verbatim}
        length xs = caseList xs 0 length'
        length' x xs = 1 + length xs
\end{verbatim}

\begin{description}
	\item[演習 2.23] \texttt{Cons}、\texttt{Nil}、\texttt{head}、\texttt{tail}のコア言語定義を記述します。
		\texttt{head}と\texttt{tail}を定義するには、新しいプリミティブ\texttt{abort}を導入する必要があります。
		これは、空リストの\texttt{head}または\texttt{tail}を取得した場合に返されます。
		\texttt{abort}は、Mirandaの\texttt{error}プリミティブを呼び出してプログラムを停止することで便利に実装できます。
	\item[演習 2.24] \texttt{caseList}の状態遷移ルールを記述し、それと\texttt{abort}を実装して、
		\texttt{preludeDefs}に\texttt{Cons}、\texttt{Nil}、\texttt{head}、\texttt{tail}の定義を追加します。
		実装をテストするためのプログラムをいくつか作成します。
\end{description}

これで、考えたい構造化データ型に適した\texttt{case}プリミティブを記述できるようになります。

\begin{description}
	\item[演習 2.25] 完全な\texttt{case}式を実装するのではなく、\texttt{case}プリミティブを使用して構造化データ型を分解することの主な欠点は何ですか？
\end{description}

\subsubsection{リストの表示}

これを説明するための状態遷移ルールを書き始めるとすぐに、状態遷移の世界で「数値を出力する」という考えをどのように表現するかを決定する必要があります。
最も簡単な解決策は、出力と呼ばれる新しいコンポーネントを状態に追加し、「出力に数値を追加する」ことによって「数値を出力する」モデルを作成することです。
また、\texttt{Print}と\texttt{Stop}という2つの新しいプリミティブを追加します。
\vskip\baselineskip
\texttt{Stop}プリミティブは簡単です。スタックを空にします。
(\texttt{tiFinal}は、現在のようにエラーを出すのではなく、空のスタックを検出したときにマシンを停止するように変更されます。)
\texttt{Stop}は、ダンプが空であることを期待しています。
\vskip\baselineskip

\begin{tabular} {|c|l l r l l l|} \hline
	(2.11) &                   & $o$ & $a : []$ & $[]$ & $h[a : \texttt{NPrim} ~ \texttt{Stop}]$ & $f$ \\
	       & $\Longrightarrow$ & $o$ & $[]$     & $[]$ & $h$                                     & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Print}プリミティブは、最初の引数を整数に評価し、その値を出力リストに付加します。
次に、結果として2番目の引数を返します。
また、ダンプが空であることも想定しています。
最初の引数がすでに評価されている場合、最初のルールが適用されます。
\vskip\baselineskip

\begin{tabular} {|c|l l r l l l|} \hline
	(2.12) &                   & $o$            & $a : a_1 : a_2 : []$ & $[]$ & $h\left[
			\begin{array}{l}
				a   : \texttt{NPrim} ~ \texttt{Print} \\
				a_1 : \texttt{NAp} ~ a ~ b_1          \\
				a_2 : \texttt{NAp} ~ a_1 ~ b_2        \\
				b_2 : \texttt{NNum} ~ n
			\end{array}
			\right]
	$      & $f$                                                                               \\
	       & $\Longrightarrow$ & $o ~ ++ ~ [n]$ & $b_2 : []$           & $[]$ & $h$      & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Print}は、出力\textit{o}に副作用があるため、かなり奇妙なスーパーコンビネータです。
\texttt{Print}は明らかに注意して使用する必要があります！
2番目のルールは、\texttt{Print}の最初の引数が評価されない場合に適用されます。
つまり、通常の方法で評価を開始します。
\vskip\baselineskip

\begin{tabular} {|c|l l r r l l|} \hline
	(2.13) &                   & $o$ & $a : a_1 : a_2 : []$ & $[]$              & $h\left[
			\begin{array}{l}
				a   : \texttt{NPrim} ~ \texttt{Print} \\
				a_1 : \texttt{NAp} ~ a ~ b_1          \\
				a_2 : \texttt{NAp} ~ a_1 ~ b_2
			\end{array}
			\right]
	$      & $f$                                                                                 \\
	       & $\Longrightarrow$ & $o$ & $b_1 : []$           & $(a_2 : []) : []$ & $h$      & $f$ \\ \hline
\end{tabular}
\vskip\baselineskip

ここで、\texttt{extraPreludeDefs}で次の追加関数を定義します。

\begin{verbatim}
        printList xs = caseList xs stop printCons
        printCons h t = print h (printList t)
\end{verbatim}

ここで、\texttt{print}は\texttt{primitives}によって\texttt{Print}プリミティブにバインドされ、\texttt{stop}は\texttt{Stop}にバインドされます。
\vskip\baselineskip
最後に、スタックに式(printList main)のアドレスが最初に含まれるように、\texttt{compile}関数を変更します。
これが正しいことをしていることを自分自身に納得させるのにそれほど時間はかからないはずです。

\begin{description}
	\item[演習 2.26] これらの変更を実装し、数値のリストを返すプログラムを作成して実装をテストします。
\end{description}
\newpage

\subsection{代替実装 \dag}

これらの演習では、私たちが行ったことに対するいくつかの代替実装について説明します。

\subsubsection{プリミティブの代替表現}

\textbf{プリミティブに対して行うのはそれを実行することだけ}なので、次のトリックを実行できます。
\texttt{primitive}をケース分析を実行する列挙型にする代わりに、\texttt{tiState}を\texttt{tiState}に変換する以下のような関数にすることができます。
\begin{verbatim}
Type Primitive = TiState -> TiState
\end{verbatim}
コンストラクターの\texttt{Add}、\texttt{Sub}などは完全に消滅しました。
これで、\texttt{primStep}によって実行される「ケース分析」はかなり簡単になりました。
関数を適用するだけです。
\texttt{primStep}とプリミティブの改訂された定義は次のとおりです。
\begin{verbatim}
primStep state prim = prim state
primitives = [ ("negate", primNeg),
               ("+", primArith (+)), ("-", primArith (-)),
               ("*", primArith (*)), ("/", primArith (/))
             ]
\end{verbatim}
これは、実際の実装では直接対応します。
プリミティブを区別するために\texttt{NPrim}ノードに小さな整数タグを格納する代わりに、
コードポインタを格納し、それにジャンプしてプリミティブを実行します。
\begin{description}
	\item[演習 2.27] この変更を実装してテストします。
\end{description}

\subsubsection{ダンプの代替表現}

現在、ダンプをスタックのスタックとして実装していますが、実際の実装では、古いスタックの上に新しいスタックを直接構築することは間違いありません。
ダンプには、スパインスタックのベースからのオフセットが含まれ、1つのサブスタックが終了し、次のサブスタックが開始する場所を示します。
\vskip\baselineskip
次の型宣言を使用して、これをマシンで直接モデル化できます。
\begin{verbatim}
type TiDump = Stack Num
\end{verbatim}
\begin{description}
	\item[演習 2.28] この変更を実装してテストします。
		引数の評価の開始と終了、および\texttt{tiFinal}の定義を処理する関数定義を変更する必要があります。
\end{description}

\subsubsection{データ値の代替表現}
\newpage

\subsection{ガベージコレクション}

実行が進むにつれて、ヒープに割り当てられるノードが増えるため、ヒープを表すMirandaデータ構造はますます大きくなります。
最終的に、Mirandaはスペースを使い果たします。
これは実際の実装に直接対応しているため、当然のことです。
ノードが割り当てられると、ヒープはどんどん大きくなり、最終的にはいっぱいになります。
スペースを解放するためにガベージコレクションを実行する必要があります。
\vskip\baselineskip

より具体的には、型も含めて関数\texttt{gc}を定義する必要があります。

\begin{verbatim}
  gc :: TiState -> TiState
\end{verbatim}

その結果の状態は、ヒープが(うまくいけば)小さいことを除いて、入力状態とまったく同じように動作します。
この小さなヒープには、マシン状態の他のコンポーネントから直接または間接的にアクセスできるすべてのノードが含まれています。
\texttt{gc}は、不要になったノードのアドレスで\texttt{hFree}を呼び出すことにより、ヒープを小さくします
(\texttt{hFree}の説明については、Appendix A.1を参照してください)。
\vskip\baselineskip

\texttt{doAdmin}関数は、各ステップの後に(\texttt{hSize}を使用して)ヒープサイズをチェックし、
指定されたサイズよりも大きい場合はガベージコレクタを呼び出すことができます。

\subsubsection{マークスキャンコレクション}

まず、マークスキャンコレクタを開発します。
これは3つのフェーズで機能します。

\begin{enumerate}
	\item 最初のフェーズでは、すべての\textbf{ルート}を識別します。 つまり、マシンの状態に含まれるすべてのヒープアドレスです。
	      そのようなアドレスはどこに潜んでいる可能性がありますか？
	      \texttt{addr}の出現について、マシンの状態に関係するタイプを調べることで簡単に見つけることができます。
	      答えは、アドレスがスタック、ダンプ、およびグローバルで発生する可能性があるということです。
	      したがって、次の関数が必要です。
	      \begin{verbatim}
          findStackRoots  :: TiStack   -> [Addr]
          findDumpRoots   :: TiDump    -> [Addr]
          findGlobalRoots :: TiGlobals -> [Addr]
        \end{verbatim}
	\item マークフェーズでは、アドレスがマシンのステートにある各ノードがマークされます。
	      ノードがマークされると、そのすべての子孫もマークされ、以下同様に再帰的にマークされます。
	      \texttt{markFrom}関数は、ヒープとアドレスを受け取り、そのアドレスからアクセス可能なすべてのノードがマークされた新しいヒープを返します。
	      \begin{verbatim}
          markFrom :: TiHeap -> Addr -> TiHeap
        \end{verbatim}
	\item スキャンフェーズでは、ヒープ内のすべてのノード(マークされているかどうかに関係なく)が検査されます。
	      マークされていないノードは解放され、マークされたノードはマーク解除されます。
	      \begin{verbatim}
          scanHeap :: TiHeap -> TiHeap
        \end{verbatim}
\end{enumerate}

\begin{description}
	\item[演習 2.30] \texttt{findRoots}、\texttt{markFrom}、\texttt{scanHeap}の観点から\texttt{gc}の定義を記述し、
		\texttt{doAdmin}から適切に呼び出します。
	\item[演習 2.31] \texttt{findRoots}の定義を記述します。
\end{description}

\texttt{markFrom}と\texttt{scanHeap}を実装する前に、ノードを\textbf{マーク}する方法が必要です。
実際の実装では、これはノードのビットを使用して、ノードがマークされているかどうかを示すことによって行われます。
次のように、新しいコンストラクタである\texttt{node}型を追加してこれをモデル化します。

\begin{verbatim}
  data Node = NAp Addr Addr -- Application
            | NSupercomb Name [Name] CoreExpr -- Supercombinator
            | NNum Int                        -- Number
            | NInd Addr                       -- Indirection
            | NPrim Name Primitive            -- Primitive
            | NData Int [Addr]                -- Tag, list of components
            | NMarked Node                    -- Marked node
\end{verbatim}

新しい種類のノードは\texttt{NMarked}ノードであり、マーキングが行われる前に存在していた\texttt{node}がその中に含まれています。
\texttt{NMarked}ノード内の\texttt{node}が別の\texttt{NMarked}ノードになることはありません。
\vskip\baselineskip

これで、\texttt{markFrom}を定義する準備が整いました。
アドレス$a$とヒープ$h$が与えられると、次のようになります。

\begin{enumerate}
	\item $h$で$a$を検索し、ノード$n$を与えます。
	      すでにマークされている場合、\texttt{markFrom}はすぐに戻ります。
	      これが、ヒープ内で循環構造に遭遇したときにマーキングプロセスが永久に続くのを防ぐものです。
	\item \texttt{hUpdate}を使用してノードをマークし、$\texttt{NMarked} ~ n$に置き換えます。
	\item $n$内から任意のアドレスを抽出し(そのようなアドレスは0個以上ある場合があります)、それぞれに対して\texttt{markFrom}を呼び出します。
\end{enumerate}

残っているのは\texttt{scanHeap}だけです。
\texttt{hAddresses}を使用して、ヒープで使用されているすべてのアドレスのリストを抽出し、それぞれを順番に調べます。
参照するノードがマークされていない場合(つまり、\texttt{NMarked}ノードではない場合)、\texttt{hFree}を呼び出してノードを解放します。
それ以外の場合は、\texttt{hUpdate}を使用してノードのマークを解除し、\texttt{NMarked}コンストラクタ内にあるノードに置き換えます。

\begin{description}
	\item[演習 2.32] \texttt{markFrom}と\texttt{scanHeap}の定義を記述します。
\end{description}

これで、マークスキャンガベージコレクタは完了です。
\vskip\baselineskip

ガベージコレクションを実行する方法はマークスキャンだけではありません。
さらに調査するためのいくつかの方向性を提案します。
ガベージコレクション手法の簡単な調査は、[Peyton Jones 1987]の第17章にあります。
より包括的なレビューは[Cohen 1981]です。

\subsubsection{間接参照の排除}

まず、開発したばかりのコレクタの最適化から始めます。
評価中に、間接ノードを導入する場合があります。
図2.2に示すように、ポインターを再調整することにより、間接ノードを排除すると便利です。
\vskip\baselineskip

\includegraphics*[scale=0.7]{Fig_2-2.png}

これを行うには、markFromの機能を少し変更する必要があります。
これで、アドレスとヒープを取得し、そのアドレスからアクセス可能なすべてのノードにマークを付け、
古いアドレスの代わりに使用する必要がある新しいアドレスとともに新しいヒープを返す必要があります。

\begin{verbatim}
  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
\end{verbatim}

図では、ノード(a)のアドレスを使用して\texttt{markFrom}を呼び出すと、ノード(c)をマークし(ノード(b)はマークしない)、
ノード(c)のアドレスを返す必要があります。
\vskip\baselineskip

\texttt{markFrom}から返されたアドレスをどのように利用しますか？
\texttt{markFrom}が呼び出されたアドレスの代わりに挿入する必要があります。
これを行う最も簡単な方法は、最初の2つのフェーズをマージすることです。
これにより、各ルートがマシン状態で識別されると、\texttt{markFrom}が呼び出され、返されたアドレスを使用して、マシン状態の元のルートが置き換えられます。
したがって、\texttt{findStackRoots}とそのコンパニオンを次のように置き換えます。
\vskip\baselineskip

\begin{verbatim}
  markFromStack   :: TiHeap -> TiStack   -> (TiHeap,TiStack)
  markFromDump    :: TiHeap -> TiDump    -> (TiHeap,TiDump)
  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap,TiGlobals)
\end{verbatim}

\begin{description}
	\vskip\baselineskip

	\item[演習 2.33] \texttt{markFrom}の改訂版を実装し、間接をマークせずに「スキップオーバー」し、再帰的に呼び出すときに各ノード内のアドレスを更新します。
		次に、\texttt{markFrom}の観点から他のマーキング関数を実装し、それらを新しいバージョンの\texttt{gc}で接着します。
		この新しいコレクタで取得したヒープサイズを以前に取得したヒープサイズと比較して、改善を測定します。
		(\texttt{markFrom}から\texttt{NInd}の特別な処理を削除することで、以前の状態に簡単に戻すことができます。)
\end{description}

\subsubsection{ポインタ反転}

ヒープ内のすべての$N$ノードがたまたま1つの長いリストにリンクされている場合、\texttt{markFrom}はそれ自体を$N$回再帰的に呼び出します。
実際の実装では、これはヒープが大きいのと同じくらい深いスタックを構築します。
非常にまれな状況で、ヒープと同じ大きさのスタックをカウントに割り当てる必要があるのは非常に面倒です。
\vskip\baselineskip

\textbf{ポインタ反転}と呼ばれる巧妙なトリックがあります。
これは、マークされているノードそのものをリンクすることでスタックを排除できます [Schorr and Waite1967]。
アルゴリズムによって課せられる唯一の追加要件は、マークされたノードが数ビットの追加の状態情報を必要とすることです。
これは、\texttt{NMarked}コンストラクターをいくらか拡張することで表現できます。

\begin{verbatim}
  data Node = NAp Addr Addr                   -- Application
            | NSupercomb Name [Name] CoreExpr -- Supercombinator
            | NNum Int                        -- Number
            | NInd Addr                       -- Indirection
            | NPrim Name Primitive            -- Primitive
            | NData Int [Addr]                -- Tag, list of components
            | NMarked MarkState Node          -- Marked node

  data markState = Done       -- Marking on this node finished
                 | Visits Int -- Node visited n times so far
\end{verbatim}

\texttt{markState}のコンストラクターの意味については、簡単に説明します。
\vskip\baselineskip

別の(まったく別の)）状態遷移システムを使用して、ポインタ反転アルゴリズムを説明できます。
マーキングマシンの状態には、フォワードポインタ、バックワードポインタ、およびヒープの3つのコンポーネント($f$, $b$, $h$)があります。
\texttt{markFrom}を呼び出すたびに、マシンの新しい実行が開始されます。
\texttt{markFrom}がアドレス$a$とヒープ$h_{init}$で呼び出されると、マシンは次の状態から開始されます。

\begin{center}
	($a$, \texttt{hNull}, $h_{init}$)
\end{center}

(\texttt{hNull}は、ヒープ内のオブジェクトをアドレス指定しない型\texttt{addr}の識別値であり、通常のアドレスと区別できます。)
マシンは、つぎの状態になると終了します。

\begin{center}
	($f$, \texttt{hNull}, $h$[$f$ : \texttt{NMarked Done} ~ $n$])
\end{center}

つまり、$f$がマークされたノードを指し、$b = \texttt{hNull}$の場合です。
($f$が指すノードがすでにマークされている場合は、初期状態も最終状態である可能性があります。)
\vskip\baselineskip

遷移規則は、マシンがマークされていないノードを処理する方法を説明することから始めます。
現在のところ、\texttt{NData}ノードは無視されます。
まず、関数適用の場合を扱います。
マークされていない関数適用に遭遇すると、最初のサブグラフに「降下」し、\texttt{NAp}ノードの最初のフィールドに古いバックポインタを記録します。
新しいフォワードポインタは最初のサブグラフをアドレス指定し、新しいバックポインタは関数適用ノード自体をアドレス指定します。
状態情報\texttt{Visits 1}は、バックポインタが\texttt{NAp}ノードの最初のフィールドに保持されているという事実を記録します。
\vskip\baselineskip

\begin{tabular} {|c|l l l l|} \hline
	(x.xx) &                   & $f$   & $b$ & $h[f : \texttt{NAp} ~ a_1 ~ a_2]$                                          \\
	       & $\Longrightarrow$ & $a_1$ & $f$ & $h[f : \texttt{NMarked} ~ (\texttt{Visits 1}) ~ (\texttt{NAp} ~ b ~ a_2)]$ \\ \hline
\end{tabular}
\vskip\baselineskip

それまでのフォワードポインタが指していたアドレスの内容を
NMarked (Visits 1) (NAp b a2)　※bは、それまでのバックワードポインタが指していたアドレスの値。
に書き換えて、ここをバックワードポインタが指すようにする。
\vskip\baselineskip

これを図2.3(a)および(b)に示します。
\vskip\baselineskip

\includegraphics*[scale=0.9]{Fig_2-3.png}

この図では、マークは「\texttt{Visits 1}」の場合は「\texttt{V1}」、「\texttt{Visits 2}」の場合は「\texttt{V2}」、
「\texttt{Done}」の場合は「\texttt{D}」と省略されています。
逆方向のポインタのチェーンが、アクセスされたアプリケーションノードに構築される方法に注意してください。
\vskip\baselineskip

次のルールは、\texttt{NMarked Done}コンストラクタを使用して、
マークされていない\texttt{NPrim}ノードを完了としてマークする必要があることを示しています(図2.3(c))。
\vskip\baselineskip

\begin{tabular} {|c|l l l l|} \hline
	(x.xx) &                   & $f$ & $b$ & $h[f : \texttt{NPrim} ~ p]$                           \\
	       & $\Longrightarrow$ & $f$ & $b$ & $h[f : \texttt{NMarked Done} ~ (\texttt{NPrim} ~ p)]$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{NSupercomb}ノードと\texttt{NNum}ノードは、それ以上のアドレスを含まないため、同様に扱われます。
\vskip\baselineskip

マークされていないノードについてはこれだけです。
マシンは、$f$がマークされたノードを指していることを検出すると、$b$が指しているノードを検査します。
\texttt{hNull}の場合、マシンは終了します。
(※フォワードポインタが指しているアドレスの中身が$\texttt{NMarked Done} ~ n$で
バックワードポインタが\texttt{hNull}の場合ということ？)
それ以外の場合は、マークされた\texttt{NAp}ノードである必要があります。
まず、状態情報が(\texttt{Visits 1})の場合、ノードが1回訪問されたとしましょう。
したがって、\texttt{NAp}ノードの最初のサブグラフのマーク付けが完了し、2番目のサブグラフをマークする必要があります。
これは、$f$をポイントにして、$b$を変更せずに、ノード($b'$)に保存されているバックポインタを最初のフィールドを2番目のフィールドに変更し、
状態情報を変更します(図2.3(d))。
\vskip\baselineskip

\begin{tabular} {|c|l l l l|} \hline
	(x.xx) &                   & $f$   & $b$ & $h\left[
			\begin{array}{l}
				f : \texttt{NMarked Done} ~ n \\
				b : \texttt{NMarked} ~ (\texttt{Visits 1}) ~ (\texttt{NAp} ~ b' ~ a_2)
			\end{array}
	\right]$                                                                                                             \\
	       & $\Longrightarrow$ & $a_2$ & $b$ & $h[b : \texttt{NMarked} ~ (\texttt{Visits 2}) ~ (\texttt{NAp} ~ f ~ b')]$ \\ \hline
\end{tabular}
\vskip\baselineskip

しばらくして、マシンは2番目のサブグラフのマーキングを完了します。
この場合、ノードを元の形式に復元し、バックポインタのチェーンを1段階バックアップできます(図2.3(e))。
\vskip\baselineskip

\begin{tabular} {|c|l l l l|} \hline
	(x.xx) &                   & $f$ & $b$  & $h\left[
			\begin{array}{l}
				f : \texttt{NMarked Done} ~ n \\
				b : \texttt{NMarked} ~ (\texttt{Visits 2}) ~ (\texttt{NAp} ~ a_1 ~ b')
			\end{array}
	\right]$                                                                                            \\
	       & $\Longrightarrow$ & $b$ & $b'$ & $h[b : \texttt{NMarked Done} ~ (\texttt{NAp} ~ a_1 ~ f)]$ \\ \hline
\end{tabular}
\vskip\baselineskip

最後に、間接処理を扱います。
$f$を変更することでスキップされますが、$b$は変更されません。
ヒープは変更されないままなので、間接参照自体はマークされません。
したがって、ガベージコレクションが完了すると、すべてのインダイレクションが再利用されます。
ご覧のとおり、このマーキングアルゴリズムを使用すると、ガベージコレクション中に間接参照を「ショートアウト」するのは非常に簡単です。
\vskip\baselineskip

\begin{tabular} {|c|l l l l|} \hline
	(x.xx) &                   & $f$ & $b$ & $h[f : \texttt{NInd} ~ a]$ \\
	       & $\Longrightarrow$ & $a$ & $b$ & $h$                        \\ \hline
\end{tabular}
\vskip\baselineskip

これで、ポインタ反転アルゴリズムの状態遷移が完了しました。

\begin{description}
	\item[演習 2.34] \texttt{NData}ノードのルールを追加します。
	\item[演習 2.35] アルゴリズムを実装します。
		必要な主な変更は、\texttt{node}型と\texttt{markFrom}関数です。
		\texttt{NMarked}コンストラクタの形式が変更されたため、\texttt{scan}は簡単な方法で変更する必要があります。
\end{description}

\subsubsection{2スペースガベージコレクション}

ガベージコレクションを実行するもう1つの非常に一般的な方法は、すべてのライブデータを1つのヒープから別のヒープにコピーすることです。
これは、[Fenichel and Yochelson 1969]によって発明されたいわゆる2スペースコレクタです([Baker 1978、Cheney 1970]も参照)。
コレクタは2つの段階で機能します。

\begin{enumerate}
	\item マシンの状態(スタック、ダンプなど)が指すすべてのノードは、
	      古いヒープ(\textit{from-space}と呼ばれる)から
	      最初は空だった新しいヒープ(\textit{to-space}と呼ばれる)に退避されます。
	      ノードは、そのコピーをto-spaceに割り当て、from-spaceのコピーを、
	      新しいノードのto-spaceアドレスを含む\textit{forwarding pointer}で上書きすることによって退避されます。
	      \texttt{markFrom}と同様に、退避ルーチンは新しいノードのto-spaceアドレスを返します。
	      これは、マシン状態の古いアドレスを置き換えるために使用されます。
	\item 次に、to-space内のすべてのノードが最初から線形にスキャンされ、それぞれが\textbf{scavengeされます}。
	      ノード$n$は、それが指すノードを退避させ、n内のそれらのアドレスを新しいto-spaceアドレスに置き換えることによってスカベンジされます。
	      スキャンポインタがallocation pointerに追いつくと、スキャンが停止します。
\end{enumerate}

これを実装するには、\texttt{node}型のさらに別のバリアントを追加する必要があります。
今回は、単一のアドレス(to-spaceアドレス)を含む\texttt{NForward}コンストラクタを使用します。
（このコレクターには\texttt{NMarked}は必要ありません。）
\texttt{markFromStack}の代わりに、次のタイプの\texttt{evacuateStack}が必要です。

\begin{verbatim}
  evacuateStack :: TiHeap -> TiHeap -> TiStack -> (TiHeap, TiStack)
\end{verbatim}

呼び出し(\texttt{evacuateStack} \textit{fromheap toheap stk})は、
\textit{stk}から\textit{toheap}に参照される\textit{fromheap}内のすべてのノードを退避させ、
新しい\textit{toheap}と新しい\textit{stk}を返します。
ダンプとグローバルにも同様の関数が必要です。
\vskip\baselineskip

最後に、関数が必要です。

\begin{verbatim}
  scavengeHeap :: TiHeap-> TiHeap-> TiHeap
\end{verbatim}

ここで、呼び出し(\texttt{scavengeHeap} \textit{fromheap toheap})は、\textit{toheap}内のノードをスカベンジし、
必要に応じて\textit{fromheap}から\textit{toheap}にノードを退避させます。

\begin{description}
	\item[演習 2.36] このガベージコレクターを実装します。
\end{description}
\newpage

\begin{verbatim}
  module GM where
  import Language
  import Utils
\end{verbatim}
\newpage

\section{Gマシン}

この章では、最初のコンパイラベースの実装であるGマシンを紹介します。
これは、スウェーデンのヨーテボリにあるチャルマース工科大学で、オーガストソンとジョンソンによって開発されました。
この章の内容は、彼らの一連の論文[Augustsson 1984、Johnsson 1984]に基づいており、博士論文[Augustsson 1987、Johnsson1987]で最高潮に達します。

\subsection{Gマシンの紹介}

テンプレートのインスタンス化マシンの基本的な操作は、\texttt{instantiate}関数によって実装されるスーパーコンビネータ本体のインスタンスを構築することでした。
\textbf{インスタンス化が実行されるたびに}、インスタンス化はテンプレートを再帰的にトラバースする必要があるため、これはかなり遅い操作です。
\texttt{instantiate}によって実行される機械語命令について考えると、テンプレートのトラバースに関係するものと、
実際にインスタンスを構築することに関係するものの 2 種類があることがわかります。
\vskip\baselineskip

Gマシンおよびその他のコンパイルされた実装の「大きなアイデア」は次のとおりです。

\begin{quotation}
	プログラムを実行する前に、各スーパーコンビネータ本体を一連の命令に変換し、実行時にスーパーコンビネータ本体のインスタンスを構築します。
\end{quotation}

このコードを実行すると、インスタンス化関数を呼び出すよりも高速になります。これは、すべての命令がインスタンスの構築に関係しているためです。
テンプレートをトラバースするために必要な指示はありません。これは、すべてが変換プロセス中に行われたためです。
したがって、プログラムの実行は 2 つの段階に分けられます。
最初の段階では、コンパイラを使用してプログラムの中間形式を生成します。 これは\textbf{コンパイルタイム}と呼ばれます。
第2段階では、中間形式が実行されます。 これは\textbf{ランタイム}と呼ばれます。
\vskip\baselineskip

スーパーコンビネータに対して行うことは、それをインスタンス化することだけなので、
変換が完了したら元のスーパーコンビネータを破棄して、コンパイルされたコードのみを保持できます。
\vskip\baselineskip

原則として、\textbf{Gマシンコンパイラ}を使用して、ソース言語のプログラムを一連の\textbf{機械語命令}に変換します。
多くの異なるハードウェア(68000ベース、またはVAXなど)に言語を実装したい場合があるため、\textbf{抽象マシン}があると便利です。
優れた抽象マシンには2つの特性があります。まず、具体的な機械語コード(たとえば68000アセンブラ)に簡単に変換できます。
2つ目は、ソースから抽象的な機械語コードを簡単に生成できることです。
\vskip\baselineskip

ここでトレードオフに直面していることに注意してください。
抽象マシンを実マシンと\textbf{同じ}にすることで、理想的には第1の性質(具体的なコード生成の容易さ)を満たすことができます。
しかし、これにより、2番目のプロパティを満たすことがはるかに難しくなります。
したがって、抽象マシンは、ソース言語と特定の機械語コードの間の足がかりです。

\subsubsection{例}

Gマシンコンパイラが動作している小さな例を次に示します。次の関数を考えます。
\vskip\baselineskip

\begin{verbatim}
        f g x = K (g x)
\end{verbatim}
\vskip\baselineskip

これは、一連の G コード命令にコンパイルされます。
\vskip\baselineskip

\begin{verbatim}
        Push 1
        Push 1
        Mkap
        Pushglobal K
        Mkap
        Slide 3
        Unwind
\end{verbatim}

図 3.1 に、このコードがどのように実行されるかを示します。
各ダイアグラムの左側にはスタックがあり、下に向かって成長します。
各図の残りの部分はヒープです。
アプリケーション ノードは @ 文字で表され、式は小文字でラベル付けされ、スーパーコンビネータは大文字でラベル付けされます。
\vskip\baselineskip

図 3.1 の図 (a) では、\texttt{f}の一連の命令を実行する前のマシンの状態を示しています。
テンプレート具体化マシンと同じように、スパインがほどかれています。
スタックの上位2つの項目は関数適用ノードへのポインタであり、その右側の部分は\texttt{g}と\texttt{x}にバインドされる式です。
\vskip\baselineskip

\texttt{Push}命令は、スタックのトップに相対的なアドレス指定を使用します。
スーパーコンビネータノード\texttt{f}へのポインタを無視すると、
最初のスタック アイテムは\texttt{0}、次は\texttt{1}というように番号が付けられます。
次の図(b)は、\texttt{Push 1}命令を実行した後の変更されたスタックを示しています。
これにより、式\texttt{x}へのポインターがスタックにプッシュされます。
\texttt{x}は、スタックの2つ下のスタック アイテムです。
\vskip\baselineskip

別の\texttt{Push 1}の後、スタックの一番上に\texttt{g}へのポインタがあります。
前の命令が新しいポインタをスタックにプッシュしたため、これはスタックの2つ下のスタックアイテムです。
新しい図は(c)です。
\vskip\baselineskip

図(d)は、\texttt{Mkap}命令が実行されるとどうなるかを示しています。
スタックから2つのポインタを取得し、それらから関数適用ノードを作成します。
スタック上の結果へのポインタを残します。
\vskip\baselineskip

図(e)では、\texttt{Pushglobal K}命令を実行し、\texttt{K}スーパーコンビネータへのポインタをプッシュします。
\vskip\baselineskip

図(f)に示すように、別の\texttt{Mkap}命令が\texttt{f}の本体のインスタンス化を完了します。
\vskip\baselineskip

元の式\texttt{f g x}を新しくインスタンス化されたボディ\texttt{K (g x)}に置き換えることができます。
Gマシンの最初のバージョン (これはlazyではありません) では、本体をスタックの3つの場所にスライドさせ、そこにあった3つのポインタを破棄します。
これは、図(g)に示すように、\texttt{Slide 3}の指示を使用して実現されます。
最終\texttt{Unwind}命令により、マシンは評価を続行します。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-1.png}

これで、Gマシンの実行の概要を簡単に説明しました。

\subsubsection{さらなる最適化}

これまでに説明したように、テンプレートをトラバースする際の解釈のオーバーヘッドをなくすことで、適度なパフォーマンスの向上を実現できます。
ただし、コンパイルは、テンプレートインスタンス化マシンでは利用できない多くのショートカットと最適化への扉を開くことも判明しています。
たとえば、次の定義を考えてみましょう。
\vskip\baselineskip

\begin{verbatim}
  f x = x + x
\end{verbatim}
\vskip\baselineskip

テンプレートインスタンス化マシンは\texttt{x}を2回評価します。
2 回目の場合はもちろん、すでに評価されていることがわかります。
コンパイルされた実装は、コンパイル時に\texttt{x}が既に評価されていることを発見し、評価ステップを省略できます。
\newpage

\subsection{テンプレートを構築するためのコード シーケンス}

テンプレートインスタンス化マシンは次のように動作することを思い出してください。

\begin{itemize}
	\item スタックの一番上にある単一のアイテムが整数へのポインタである場合、マシンは終了しました。
	\item そうでない場合は、スーパーコンビネータノードに到達するまで、遭遇した関数適用ノードを巻き戻します。
	      次に、スーパーコンビネータ本体のコピーをインスタンス化し、その引数を置換します。
\end{itemize}

Mark 1 テンプレートインスタンス化マシンの中心にあるのは、
59ページと60ページで定義されている2つの関数\texttt{scStep}と\texttt{instanceiate}です。
\texttt{scStep}と\texttt{instantiate}の定義を見てみると、スーパーコンビネータをインスタンス化する操作について次のように説明できます。

\begin{enumerate}
	\item 変数名の\textbf{ローカル環境}をヒープ内のアドレスに構築します。
	\item このローカル環境を使用して、ヒープ内にスーパーコンビネータ本体のインスタンスを作成します。
	      変数はコピーされません。 代わりに、対応するアドレスが使用されます。
	\item 関数適用ノードとスーパーコンビネータノードへのポインタをスタックから削除します。
	\item スーパーコンビネータの新しく作成されたインスタンスのアドレスをスタックにプッシュします。
\end{enumerate}

テンプレートインスタンス化では、スーパーコンビネータのインスタンスを作成するには、
スーパーコンビネータの本体である式のツリー構造をトラバースする必要があります。
式は再帰的に定義されるため、ツリートラバーサル関数\texttt{instantiate}は再帰的に定義されます。
たとえば、\texttt{EAp e1 e2}の場合の\texttt{instantiate}の定義(58ページ)を参照してください。
最初に\texttt{e1}に対して、次に\texttt{e2}に対して\texttt{instanceiate}を呼び出し、各サブ式のグラフのアドレスを保持します。
最後に、グラフに関数適用ノードを作成して、2つのアドレスを結合します。
\vskip\baselineskip

命令の線形シーケンスをコンパイルして、式をインスタンス化する操作を実行したいと考えています。

\subsubsection{算術の後置評価}

式をインスタンス化する命令の線形シーケンスを構築したいという欲求は、算術式の後置評価を連想させます。
Gマシンに戻る前に、このアナロジーをさらに調べます。
\vskip\baselineskip

算術式の言語は、数、加算、および乗算で構成されます。
この言語を\texttt{aExpr}型として表すことができます。

\begin{verbatim}
  data AExpr = Num Int
             | Plus AExpr AExpr
             | Mult AExpr AExpr
\end{verbatim}

言語は「明白な」意味を持つべきであることが意図されています。 関数\texttt{aInterpret}を使用してこれを与えることができます。

\begin{verbatim}
  aInterpret :: AExpr -> Int
  aInterpret (Num n)      = n
  aInterpret (Plus e1 e2) = aInterpret e1 + aInterpret e2
  aInterpret (Mult e1 e2) = aInterpret e1 * aInterpret e2
\end{verbatim}

あるいは、式を演算子(または命令)の後置シーケンスにコンパイルすることもできます。
式を評価するには、コンパイルされた演算子と値のスタックを使用します。
たとえば、算術式$2 + 3 \times 4$は、以下のシーケンスとして表されます。

\[
	[\texttt{INum 2}, \texttt{INum 3}, \texttt{INum 4}, \texttt{IMult}, \texttt{IPlus}]
\]

後置マシンの命令は、aInstruction型として指定できます。

\begin{verbatim}
  data AInstruction = INum Int
                    | IPlus
                    | IMult
\end{verbatim}

評価器の状態は、一連の演算子と数値のスタックであるペアです。
コードシーケンスの意味は、次の遷移規則で与えられます。
\vskip\baselineskip

\begin{tabular} {|c|l r r|} \hline
	(3.1) &                   & $[]$ & $[n]$ \\
	      & $\Longrightarrow$ &      & $n$   \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r r|} \hline
	(3.2) &                   & $\texttt{INum} ~ n:i$ & $ns$   \\
	      & $\Longrightarrow$ & $i$                   & $n:ns$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r r|} \hline
	(3.3) &                   & $\texttt{IPlus} ~ n:i$ & $n_0:n_1:ns$     \\
	      & $\Longrightarrow$ & $i$                    & $(n_1 + n_0):ns$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r r|} \hline
	(3.4) &                   & $\texttt{IMult} ~ n:i$ & $n_0:n_1:ns$          \\
	      & $\Longrightarrow$ & $i$                    & $(n_1 \times n_0):ns$ \\ \hline
\end{tabular}
\vskip\baselineskip

これらの遷移規則をMirandaに翻訳すると、次のようになります。

\begin{verbatim}
  aEval :: ([AInstruction], [Int]) -> Int
  aEval ([], [n]) = n
    -- 遷移規則 (3.1)
  aEval (INum n : is, s) = aEval (is, n: s)
    -- 遷移規則 (3.2)
  aEval (IPlus : is, n0 : n1 : s) = aEval (is, n1+n0 : s)
    -- 遷移規則 (3.3)
  aEval (IMult : is, n0 : n1 : s) = aEval (is, n1*n0 : s)
    -- 遷移規則 (3.4)
\end{verbatim}

式の後置コードのシーケンスを生成するには、コンパイラを定義する必要があります。
これは式を取り、実行時に式の値を計算する一連の命令を配信します。

\begin{verbatim}
  aCompile :: AExpr -> [AInstruction]
  aCompile (Num n)      = [INum n]
  aCompile (Plus e1 e2) = aCompile e1 ++ aCompile e2 ++ [IPlus]
  aCompile (Mult e1 e2) = aCompile e1 ++ aCompile e2 ++ [IMult]
\end{verbatim}

これからの重要なアイデアは、\texttt{aCompile}関数の型によって与えられます。
命令のリストを返します。

\begin{quotation}
	式の後置表現は、式ツリーをフラット化または線形化する方法であり、式をフラットな一連の演算子で表すことができます。
\end{quotation}

\begin{description}
	\item[演習 3.1.] 構造帰納法を使用するか、またはその他の方法で、算術式の後置評価が式のツリー評価と同じ結果になることを証明します。
		つまり、型\texttt{aExpr}のすべての式 e に対して、
		\begin{verbatim}
      aInterpret e = aEval (aCompile e, [])
    \end{verbatim}
		これは一致証明の例です。
	\item[演習 3.2.] 関数\texttt{aInterpret}、\texttt{aCompile}、および\texttt{aEval}を拡張して、\texttt{let}式を処理します。
		\texttt{aExpr}型の\texttt{e}のすべての式について、これらの新しい関数が次の関係を満たすことを証明します。
		\begin{verbatim}
      aInterpret e = aEval (aCompile e, [])
    \end{verbatim}
		\texttt{letrec}式など、さらに複雑な式に言語を拡張できますか?
		これらの拡張機能を正しく実装したことを証明できますか?
\end{description}

\subsubsection{後置コードを使用してグラフを作成する}

同じテクニックを使用して、スーパーコンビネータ本体のインスタンスを作成できます。
この場合、スタック上の「値」は、インスタンス化される式の部分のアドレスになります。
\vskip\baselineskip

テンプレート構築命令の操作は、上記の算術例で見たものとは異なります。
通常、命令にはヒープにノードを割り当てるという副作用があります。
例として、\texttt{Mkap}命令の導入を検討してください。
この命令は、スタックの上位2つのアドレスからヒープ内に関数適用ノードを作成します。
完了すると、この新しいノードへのポインタがスタックに残されます。
\vskip\baselineskip

テンプレートインスタンス化マシンには既にそのようなスタックがあるため、アドレスの新しい評価スタックを創案する理由はありません。
ただし、このスタックを使用する場合は、覚えておくべき重要な点があります。

\begin{quotation}
	スタックからオブジェクトをポップおよびプッシュすると、変数名に対応するスタックの場所のマップが変化します。
	したがって、式をコンパイルするときは、これを追跡する必要があります。
\end{quotation}

スタック内のアイテムへのアクセスは、スタックの一番上を基準にしています。
そのため、アイテムが追加されると、そのアイテムに到達するまでのオフセットが1増加します。
同様に、アイテムがポップされると、オフセットは1だけ減少します。

\subsubsection{インスタンス化が行われた後はどうなりますか?}

スーパーコンビネータ本体のインスタンス化が完了したら、スタックを整理し、評価プロセスの継続を手配する必要があります。
$n$ 個の引数を持つスーパーコンビネータの後置シーケンスの評価が完了すると、スタックは次の形式になります。

\begin{itemize}
	\item 一番上には、新しくインスタンス化された本体\texttt{e}のヒープ内のアドレスがあります。
	\item 次に、$n + 1$個のポインタがあります。これらから、インスタンス化プロセスで使用される引数にアクセスできます。
	\item $n + 1$個のポインタの最後は、インスタンス化したばかりの式のルートを指します。
\end{itemize}

これを図3.2に示します。

\includegraphics*[scale=0.5]{Fig_3-2.png}

redexを新しくインスタンス化された本体に置き換え、\texttt{Slide}命令を使用して$n$個のアイテムをスタックからポップする必要があります。
次のスーパーコンビネータを見つけるには、\texttt{Unwind}命令を使用して、再び巻き戻しを開始する必要があります。
後置演算子シーケンスに整理と巻き戻しを行う操作を追加することで、テンプレートインスタンス化マシンをを Mark 1 Gマシンに変換しました。
\vskip\baselineskip

関数\texttt{f x1 ... xn = e}のコードは次のとおりです。
\vskip\baselineskip

\begin{verbatim}
  <code to construct an instance of e>
  Slide n+1
  Unwind
\end{verbatim}
\newpage

\subsection{Mark 1: 最小限のGマシン}

ここで、完全なGマシンとそのコンパイラのコードを示します。
更新(セクション\ref{sec:gmachinelazy}で紹介)や算術演算(セクション\ref{sec:gmachineadprim}で紹介)は実行しません。

\subsubsection{全体構造}

最上位では、G-machine はテンプレート インスタンシエーターに非常に似ています。
いつものように、システム全体が実行機能と一緒に編まれています。

\begin{verbatim}
  -- The function run is already defined in gofers standard.prelude
  runProg :: [Char] -> [Char]
  runProg = showResults . eval . compile . parse
\end{verbatim}

アクセスする必要があるため、パーサのデータ構造と関数が含まれています。

\begin{verbatim}
  -- :a language.lhs -- parser data types
\end{verbatim}

\subsubsection{データ型の定義}

グラフ簡約実装手法の基本はグラフです。
とりわけ、Appendix A で提供されているユーティリティの\texttt{heap}データ型を使用します。

\begin{verbatim}
  -- :a util.lhs -- heap data type and other library functions
\end{verbatim}

Mark 1 G マシンは、状態として 5 タプル \texttt{gmState} を使用します。
\texttt{gmState} は、コンパイルされたプログラムの実行中に必要なすべての情報を保持します。

\begin{verbatim}
  type GmState
    = (GmCode,    -- Current instruction stream
       GmStack,   -- Current stack
       GmHeap,    -- Heap of nodes
       GmGlobals, -- Global addresses in heap
       GmStats)   -- Statistics
\end{verbatim}

G マシンの説明では、ステート \textbf{アクセス関数}を使用して、ステートのコンポーネントにアクセスします。
このアプローチの利点は、新しいコンポーネントに対応するために状態を変更するときに、作成した元のコードのほとんどを再利用できることです。
接頭辞 \texttt{get} を使用して状態からコンポーネントを取得するアクセス関数を示し、
接頭辞 \texttt{put} を使用して状態内のコンポーネントを置き換えます。
\vskip\baselineskip

状態の 5 つのコンポーネントのそれぞれの型定義と、それらのアクセス関数を順に検討します。

\begin{itemize}
	\item 命令ストリームは \texttt{gmCode} 型で、単なる\texttt{instruction}のリストです。

	      \begin{verbatim}
    type GmCode = [Instruction]
  \end{verbatim}

	      コードへの便利なアクセスを取得するために、後で状態が追加のコンポーネントで拡張されるときに、
	      \texttt{getCode} と \texttt{putCode} の 2 つの関数を定義します。


	      \begin{verbatim}
    getCode :: GmState -> GmCode
    getCode (i, stack, heap, globals, stats) = i
  
    putCode :: GmCode -> GmState -> GmState
    putCode i' (i, stack, heap, globals, stats)
      = (i', stack, heap, globals, stats)
  \end{verbatim}

	      最初は 6 つの命令しかありません。
	      これらについては、サブセクション 3.3.3 で詳しく説明します。

	      \begin{verbatim}
    data Instruction
      = Unwind
      | Pushglobal Name
      | Pushint Int
      | Push Int
      | Mkap
      | Slide Int
      instance Eq Instruction
        where
          Unwind == Unwind = True
          Pushglobal a == Pushglobal b = a == b
          Pushint a == Pushint b = a == b
          Push a == Push b = a == b
          Mkap == Mkap = True
          Slide a == Slide b = a == b
          _ == _ = False
  \end{verbatim}

	\item G マシン スタック \texttt{gmStack} は、ヒープ内のアドレスのリストです。

	      \begin{verbatim}
    type GmStack = [Addr]
  \end{verbatim}

	      スタックへの便利なアクセスを取得するために、後で状態が追加のコンポーネントで拡張されたときに、
	      \texttt{getStack} と \texttt{putStack} の 2 つの関数を定義します。

	      \begin{verbatim}
    getStack :: GmState -> GmStack
    getStack (i, stack, heap, globals, stats) = stack

    putStack :: GmStack -> GmState -> GmState
    putStack stack' (i, stack, heap, globals, stats)
      = (i, stack', heap, globals, stats)
  \end{verbatim}

	\item テンプレート インスタンシエーターの場合と同様に、\texttt{utils} のヒープ データ構造を使用してヒープを実装します。

	      \begin{verbatim}
    type GmHeap = Heap Node
  \end{verbatim}

	      繰り返しますが、状態のこのコンポーネントにアクセスするには、アクセス関数を定義します。

	      \begin{verbatim}
    getHeap :: GmState -> GmHeap
    getHeap (i, stack, heap, globals, stats) = heap
    putHeap :: GmHeap -> GmState -> GmState
    putHeap heap' (i, stack, heap, globals, stats)
      = (i, stack, heap', globals, stats)
  \end{verbatim}

	      最小限の G マシンには、次の 3 種類のノードしかありません。
	      数\texttt{NNum}、関数適用\texttt{NAp}、そしてグローバル\texttt{NGlobal}です。

	      \begin{verbatim}
    data Node
      = NNum    Int         -- Numbers
      | NAp     Addr Addr   -- Applications
      | NGlobal Int  GmCode -- Globals
  \end{verbatim}

	      数 ノードには関連する番号が含まれます。
	      関数適用 ノードは、最初のアドレスの関数を 2 番目のアドレスの式に適用します。
	      \texttt{NGlobal} ノードには、グローバルが期待する引数の数と、そのときに実行されるコード シーケンスが含まれています。
	      グローバルには十分な引数があります。
	      これは、アリティとコードの代わりにテンプレートを保持していたテンプレート インスタンシエーターの \texttt{NSupercomb} ノードを置き換えます。

	\item 後で遅延実装を作成するため、各グローバルに対して 1 つのノードのみが存在することが重要です。
	      グローバルのアドレスは、連想リスト \texttt{gmGlobals} でその値を検索することによって決定できます。
	      これは、テンプレート マシンの \texttt{tiGlobals} コンポーネントに対応します。

	      \begin{verbatim}
    type GmGlobals = ASSOC Name Addr
  \end{verbatim}

	      使用するアクセス関数は \texttt{getGlobals} です。
	      Mark 1 マシンでは、このコンポーネントは一定であるため、対応する put 関数は必要ありません。

	      \begin{verbatim}
    getGlobals :: GmState -> GmGlobals
    getGlobals (i, stack, heap, globals, stats) = globals
  \end{verbatim}

	\item 状態の統計コンポーネントは、抽象データ型として実装されます。

	      \begin{verbatim}
    statInitial  :: GmStats
    statIncSteps :: GmStats -> GmStats
    statGetSteps :: GmStats -> Int
  \end{verbatim}

	      \texttt{gmStats} の実装が提供されるようになりました。

	      \begin{verbatim}
    type GmStats = Int
    statInitial    = 0
    statIncSteps s = s + 1
    statGetSteps s = s
  \end{verbatim}

	      このコンポーネントにアクセスするには、\texttt{getStats} と \texttt{putStats} を定義します。

	      \begin{verbatim}
    getStats :: GmState -> GmStats
    getStats (i, stack, heap, globals, stats) = stats
    putStats :: GmStats -> GmState -> GmState
    putStats stats' (i, stack, heap, globals, stats)
      = (i, stack, heap, globals, stats')
  \end{verbatim}
\end{itemize}

\subsubsection{評価器}

G マシン評価器 \texttt{eval} は、状態のリストを生成するように定義されています。
最初のものは、コンパイラによって構築されたものです。
最後の状態がある場合、評価の結果は最後の状態のスタック コンポーネントの一番上になります。

\begin{verbatim}
  eval :: GmState -> [GmState]
  eval state = state: restStates
    where
    restStates | gmFinal state = []
               | otherwise = eval nextState
    nextState = doAdmin (step state)
\end{verbatim}

関数 \texttt{doAdmin} は \texttt{statIncSteps} を使用して、状態の統計コンポーネントを変更します。

\begin{verbatim}
  doAdmin :: GmState -> GmState
  doAdmin s = putStats (statIncSteps (getStats s)) s
\end{verbatim}

評価器の重要な部分は、関数 \texttt{gmFinal} とこれから見ていく \texttt{step} です。
\vskip\baselineskip

\textbf{最終状態のテスト}
\vskip\baselineskip

実行中のコード シーケンスが空の場合、G マシン インタープリターは終了しています。
この状態を \texttt{gmFinal} 関数で表現します。

\begin{verbatim}
  gmFinal :: GmState -> Bool
  gmFinal s = case (getCode s) of
              []        -> True
              otherwise -> False
\end{verbatim}

\textbf{ステップを進める}
\vskip\baselineskip

\texttt{step}関数は、実行中の命令に基づいて状態遷移を行うように定義されています。

\begin{verbatim}
  step :: GmState -> GmState
  step state = dispatch i (putCode is state)
               where (i : is) = getCode state
\end{verbatim}

現在の命令 \texttt{i} を\texttt{dispatch}し、現在のコード シーケンスをコード シーケンス \texttt{is} に置き換えます。
これは、実機でプログラムカウンタを進めることに相当します。

\begin{verbatim}
  dispatch :: Instruction -> GmState -> GmState
  dispatch (Pushglobal f) = pushglobal f
  dispatch (Pushint    n) = pushint n
  dispatch Mkap           = mkap
  dispatch (Push       n) = push n
  dispatch (Slide      n) = slide n
  dispatch Unwind         = unwind
\end{verbatim}

ご覧のとおり、\texttt{dispatch}関数は実行する状態遷移を選択するだけです。
\vskip\baselineskip

後置命令の遷移規則を調べることから始めましょう。
\texttt{instruction}内の構文オブジェクトごとに 1 つ存在します。
まず、\texttt{Pushglobal} 命令から始めます。
この命令は、状態のグローバル コンポーネントを使用して、グローバル $f$ を保持する\texttt{heap}内の一意の \texttt{NGlobal} ノードを見つけます。
見つからない場合は、適切なエラー メッセージが出力されます。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.5) &                   & \texttt{Pushglobal}  $f$ : $i$ & $s$       & $h$ & $m$[$f$ : $a$] \\
	      & $\Longrightarrow$ & $i$                            & $a$ : $s$ & $h$ & $m$            \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{pushglobal} 関数を使用してこのルールを実装します。

\begin{verbatim}
  pushglobal :: Name -> GmState -> GmState
  pushglobal f state
    = putStack (a: getStack state) state
      where a = aLookup (getGlobals state) f (error ("Undeclared global " ++ f))
\end{verbatim}

残りの遷移は、スーパーコンビネータの本体を構築するためのものです。
\texttt{Pushint} の遷移は、整数ノードをヒープに配置します。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.6) &                   & \texttt{PushInt}  $n$ : $i$ & $s$       & $h$                          & $m$ \\
	      & $\Longrightarrow$ & $i$                         & $a$ : $s$ & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

対応する関数は \texttt{pushint} です。
数は、アドレス \texttt{a} の新しいヒープ \texttt{heap'} に配置されます。
次に、ヒープとスタックを元の状態に戻します。

\begin{verbatim}
  pushint :: Int -> GmState -> GmState
  pushint n state
    = putHeap heap' (putStack (a: getStack state) state)
      where (heap', a) = hAlloc (getHeap state) (NNum n)
\end{verbatim}

\texttt{Mkap} 命令は、スタックの最上部にある 2 つのアドレスを使用して、ヒープ内に関数適用ノードを構築します。
次の遷移規則があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.7) &                   & \texttt{Mkap}  $a_1$ : $a_2$ : $i$ & $s$       & $h$                                 & $m$ \\
	      & $\Longrightarrow$ & $i$                                & $a$ : $s$ & $h$[$a$ : \texttt{NAp} $a_1$ $a_2$] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

このトランジションが \texttt{mkap} になります。
ここでも、\texttt{heap'} と \texttt{a} は、それぞれ新しいヒープと新しいノードのアドレスです。

\begin{verbatim}
  mkap :: GmState -> GmState
  mkap state
    = putHeap heap' (putStack (a:as') state)
      where (heap', a) = hAlloc (getHeap state) (NAp a1 a2)
            (a1:a2:as') = getStack state
\end{verbatim}

\texttt{Push} 命令は、関数に渡された引数のコピーを取得するために使用されます。
これを行うには、スタックからポイントされている関数適用ノードを「調べる」必要があります。
また、スタック上にあるスーパーコンビネータ ノードをスキップすることも忘れないでください。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.8) &                   & \texttt{Push}  $n$ : $i$ & $a_0$ : $\ldots$ : $a_{n+1}$ : $s$          & $h$[$a_{n+1}$ : \texttt{NAp} $a_n$ $a_n'$] & $m$ \\
	      & $\Longrightarrow$ & $i$                      & $a_n'$ : $a_0$ : $\ldots$ : $a_{n+1}$ : $s$ & $h$                                        & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{verbatim}
  push :: Int -> GmState -> GmState
  push n state
    = putStack (a:as) state
      where as = getStack state
            a  = getArg (hLookup (getHeap state) (as !! (n+1)))
\end{verbatim}

これは、補助関数 \texttt{getArg} を使用して、アプリケーション ノードから必要な式を選択します。

\begin{verbatim}
  getArg :: Node -> Addr
  getArg (NAp a1 a2) = a2
\end{verbatim}

\begin{quote}
	スタック構造のため、\texttt{Push} 命令のアドレッシング モードを [Peyton Jones 1987] で使用されていたものから変更しました。
\end{quote}

次に、スーパーコンビネータがインスタンス化された後、アンワインドを続行する前に発生するスタックの整理が、\texttt{Slide} 命令によって実行されます。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.9) &                   & \texttt{Slide}  $n$ : $i$ & $a_0$ : $\ldots$ : $a_n$ : $s$ & $h$ & $m$ \\
	      & $\Longrightarrow$ & $i$                       & $a_0$ :                    $s$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{verbatim}
  slide :: Int -> GmState -> GmState
  slide n state
  = putStack (a: drop n as) state
    where (a:as) = getStack state
\end{verbatim}

\texttt{Unwind}は、テンプレート インスタンス化子の外側のループを置き換えるため、最も複雑な命令です。
\texttt{Unwind} 命令は、次のセクションで説明するように、常にシーケンスの最後の命令です。
構築された \texttt{newState} は、スタックの一番上の項目に依存します。
これは、スタックの一番上にあるアイテムにも依存する、最初の遷移ルールに依存します。

\begin{verbatim}
  unwind :: GmState -> GmState
  unwind state
    = newState (hLookup heap a)
      where
        (a:as) = getStack state
        heap = getHeap state
\end{verbatim}

まず、スタックの一番上に数値がある場合を考えます。
この場合、これで終了です。 G マシンが終了したことを示すために、コード コンポーネントに [] を配置します。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.10) &                   & [\texttt{Unwind}] & $a$ : $s$ & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\
	       & $\Longrightarrow$ & []                & $a$ : $s$ & $h$                          & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{verbatim}
        newState (NNum n) = state
\end{verbatim}

スタックの一番上に関数適用ノードがある場合は、次のノードからアンワインドを続行する必要があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.11) &                   & [\texttt{Unwind}] & $a$ : $s$         & $h$[$a$ : \texttt{NAp} $a_1$ $a_2$] & $m$ \\
	       & $\Longrightarrow$ & [\texttt{Unwind}] & $a_1$ : $a$ : $s$ & $h$                                 & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{verbatim}
        newState (NAp a1 a2) = putCode [Unwind] (putStack (a1:a:as) state)
\end{verbatim}

最も複雑なルールは、スタックの一番上にグローバル ノードがある場合に発生します。
スーパーコンビネータの適用を減らすのに十分な引数があるかどうかに応じて、考慮すべき 2 つのケースがあります。
\vskip\baselineskip

第 1 に、スーパーコンビネータ アプリケーションを削減するのに十分な引数がない場合、プログラムの型が正しくありません。
Mark 1 Gマシン については、このケースを無視します。
あるいは、十分な引数がある場合、スーパーコンビネータのコードに「ジャンプ」することで、スーパーコンビネータを減らすことができます。
遷移規則では、これはスーパーコンビネータ コードをマシンのコード コンポーネントに移動することによって表現されます。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{SC} \llbracket d \rrbracket$は、スーパーコンビネータ定義 $d$ の G マシン コードです。                                                                 \\
	$\mathcal{SC} \llbracket f ~ x_1 \ldots x_n = e \rrbracket = \mathcal{R} \llbracket e \rrbracket ~ \left[ x_1 \mapsto 0, \ldots, x_n \mapsto n - 1 \right] ~ n$ \\ \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$ は、アリティ $d$ のスーパーコンビネータのために、                                                              \\
	環境 $\rho$ で式 $e$ をインスタンス化するコードを生成し、                                                                                                       \\
	結果のスタックの巻き戻しに進みます。                                                                                                                            \\
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d = \mathcal{C} \rho \texttt{++} [\texttt{Slide} ~ d + 1, ~ \texttt{Unwind}]$                                     \\ \hline
	$\mathcal{C} \llbracket e \rrbracket ~ \rho$ は、環境 $\rho$ で $e$ のグラフを構築するコードを生成し、                                                          \\
	それへのポインターをスタックの一番上に残します。                                                                                                                \\
	\begin{tabular}{r c l l}
		$\mathcal{C} \llbracket f \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Pushglobal} ~ f \right]$                                                                                                                      & ここで、$f$ はスーパーコンビネータです。        \\
		$\mathcal{C} \llbracket x \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Push} ~ (\rho ~ x) \right]$                                                                                                                   & ここで、$x$ はローカル変数です。                \\
		$\mathcal{C} \llbracket i \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Pushint} ~ i \right]$                                                                                                                         &                                                 \\
		$\mathcal{C} \llbracket e_0 ~ e_1 \rrbracket ~ \rho$ & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \mathcal{C} \llbracket e_0 \rrbracket ~ \rho^{+1} ~ \texttt{++} ~ \left[\texttt{Mkap} \right]$ & ここで、$\rho^{+n} ~ x = (\rho ~ x) + n$ です。 \\ \hline
	\end{tabular}
\end{tabular}
\vskip\baselineskip

\subsubsection{プログラムのコンパイル}

一連のコンパイル スキームを使用してコンパイラを説明します。
各スーパーコンビネータの定義は、コンパイル スキーム $\mathcal{SC}$ を使用してコンパイルされます。
各スーパーコンビネータ用に生成されたコンパイル済みコードは、図 3.3 に定義されています。
コンパイル スキーム $\mathcal{SC}$、$\mathcal{R}$、および $\mathcal{C}$ に対応するのは、
\textbf{コンパイラ関数} \texttt{compileSc}、\texttt{compileR}、および \texttt{compileC} です。
これらのそれぞれを順番に検討します。
\vskip\baselineskip

\texttt{compile}関数は、プログラムを G マシンの初期状態にします。
最初のコード シーケンスは、グローバルな \texttt{main} を見つけて評価します。
ヒープは、宣言された各グローバルのノードが含まれるように初期化されます。
\texttt{globals} には、グローバル名からそれらに提供される \texttt{NGlobal} ノードへのマップが含まれます。

\begin{verbatim}
  compile :: CoreProgram -> GmState
  compile program
    = (initialCode, [], heap, globals, statInitial)
      where (heap, globals) = buildInitialHeap program
\end{verbatim}

初期ヒープを構築し、定義された各グローバルのグローバル ノードのマップを提供するために、\texttt{buildInitialHeap} を使用します。
これは、テンプレート マシンの場合とまったく同じです。

\begin{verbatim}
  buildInitialHeap :: CoreProgram -> (GmHeap, GmGlobals)
  buildInitialHeap program
    = mapAccuml allocateSc hInitial compiled
      where compiled = map compileSc (preludeDefs ++ program) ++
                       compiledPrimitives
      --where
      --  compiled = map compileSc program
\end{verbatim}

\texttt{buildInitialHeap} 関数は \texttt{mapAccuml} を使用して、コンパイルされた各グローバルにノードを割り当てます。
型 [\texttt{gmCompiledSC}] を持つコンパイル済みで (必要に応じて) 発生するコンパイル。

\begin{verbatim}
  type GmCompiledSC = (Name, Int, GmCode)
\end{verbatim}

関数 \texttt{allocateSc} は、コンパイルされたスーパーコンビネータ引数に新しいグローバルを割り当て、
新しいヒープとグローバルが格納されているアドレスを返します。

\begin{verbatim}
  allocateSc :: GmHeap -> GmCompiledSC -> (GmHeap, (Name, Addr))
  allocateSc heap (name, nargs, instns)
    = (heap', (name, addr))
      where (heap', addr) = hAlloc heap (NGlobal nargs instns)
\end{verbatim}

初期状態では、マシンにプログラムの値を評価してもらいたい。
これは単にグローバル \texttt{main}の値であることを思い出してください。

\begin{verbatim}
  initialCode :: GmCode
  initialCode = [Pushglobal "main", Unwind]
\end{verbatim}

各スーパーコンビネータは、図 3.3 の $\mathcal{SC}$ スキームを実装する \texttt{compileSc} を使用してコンパイルされます。
これは、スーパーコンビネータ名、スーパーコンビネータが簡約される前に必要な引数の数、
およびスーパーコンビネータに関連付けられたコード シーケンスを含むトリプルを返します。

\begin{verbatim}
  compileSc :: (Name, [Name], CoreExpr) -> GmCompiledSC  -- SCスキーム
  compileSc (name, env, body)
    = (name, length env, compileR body (zip2 env [0..]))
\end{verbatim}

これは、図 3.3 の $\mathcal{R}$ スキームに対応する \texttt{compileR} を使用します。

\begin{verbatim}
  compileR :: GmCompiler  -- Rスキーム
  compileR e env = compileC e env ++ [Slide (length env + 1), Unwind]
  --compileR e env = compileC e env ++ [Slide (length env + 1), Unwind]
\end{verbatim}

各コンパイラ スキームには、同じ型 \texttt{gmCompiler} があります。

\begin{verbatim}
  type GmCompiler = CoreExpr -> GmEnvironment -> GmCode
\end{verbatim}

コンパイルスキームから写像 $\rho$ を連想リストとして表すことができるという事実を使用します。
このリストから変数のオフセットを検索できるだけでなく、スタックにある引数の数を計算することもできます。
これは、\texttt{Slide} 命令で絞り出すスタック要素の数を調べるために \texttt{compileR} で使用されます。
リストのタイプは \texttt{gmEnvironment} で、次のように定義されています。

\begin{verbatim}
  type GmEnvironment = ASSOC Name Int
\end{verbatim}

これは、図 3.3 の $\mathcal{C}$ スキームに対応する \texttt{compileC} を使用して、スーパーコンビネータ本体のインスタンス化を構築します。

\begin{verbatim}
  compileC :: GmCompiler  -- Cスキーム
  compileC (EVar v) env
    | elem v (aDomain env) = [Push n]
    | otherwise = [Pushglobal v]
    where n = aLookup env v (error "Can't happen")
  compileC (ENum n) env = [Pushint n]
  compileC (EAp e1 e2) env = compileC e2 env ++ compileC e1 (argOffset 1 env) ++ [Mkap]
\end{verbatim}

関数 \texttt{argOffset} を使用して、スタック オフセットを変更できます。
\texttt{env} が $\rho$ を実装する場合、 \texttt{(argOffset n env)} は $\rho^{+n}$ を実装します。

\begin{verbatim}
  argOffset :: Int -> GmEnvironment -> GmEnvironment
  argOffset n env = [(v, n + m) | (v, m) <- env]
\end{verbatim}
\vskip\baselineskip

\textbf{コンパイル例}
\vskip\baselineskip

\texttt{K} コンビネータのコンパイルを見てみましょう。
この関数をコンパイルするとき、次の式を評価することから始めます。

\begin{verbatim}
  compileSc ("K", ["x", "y"], EVar "x")
\end{verbatim}

タプルの最初の要素は名前 (この場合は \texttt{K}) です。
2 番目は引数リストです (この場合、\texttt{x} と \texttt{y} の 2 つの変数があります)。
タプルの 3 番目のコンポーネントは、スーパーコンビネータの本体です (この例では、変数 \texttt{x} だけです)。
\vskip\baselineskip

この式を書き直すと、次のようになります。

\begin{verbatim}
  ("K", 2, compileR (EVar "x") [("x", 0), ("y", 1)])
\end{verbatim}

結果のトリプルは、名前 (\texttt{K})、スーパーコンビネータを削減するために必要な引数の数 (この場合は 2 つ)、
およびインスタンス化を実行するためのコード シーケンスで構成されます。
この式を書き直すと、このスーパーコンビネータのコード シーケンスが生成されます。
環境は式 \texttt{[("x", 0), ("y", 1)]} で表されることに注意してください。
これは、本体をインスタンス化すると、\texttt{x} へのポインターが引数スタックの一番上にあり、
\texttt{y} へのポインターがスタックの \texttt{x} のすぐ下にあることを示しています。

\begin{verbatim}
  ("K", 2, compileC (EVar "x") [("x", 0), ("y", 1)] ++ [Slide 3, Unwind])
\end{verbatim}

\texttt{compileR} 関数は、\texttt{compileC} を使用して本体をコンパイルし、
最後に \texttt{Slide} および \texttt{Unwind} 命令を追加するように定義されています。
\vskip\baselineskip

本体をコンパイルするには、\texttt{x} を検索し、それがスタックの一番上にあることを確認します。
\texttt{Push 0} を使用して、スタックのトップのコピーを作成するコードを生成します。

\begin{verbatim}
  ("K", 2, [Push 0, Slide 3, Unwind])
\end{verbatim}

\begin{description}
	\item[演習 3.3] プレリュードの定義から \texttt{S} コンビネータの変換の同等のシーケンスを書き出します。
		\texttt{S} が次のように定義されていることを思い出してください。

		\begin{verbatim}
    S f g x = f x (g x)
        \end{verbatim}

		Appendix B に示す単純なプログラムのいずれかでコンパイラとマシンを実行して、最終結果を確認してください
		(\texttt{S} は標準プレリュードにあります)。
\end{description}

\textbf{プリミティブ}
\vskip\baselineskip

この最小限の G マシンにはプリミティブがないため、実装するものは何もありません。

\begin{verbatim}
  compiledPrimitives :: [GmCompiledSC]
  compiledPrimitives = []
\end{verbatim}

\subsubsection{結果の表示}

多くの状態コンポーネントは抽象データ型である (したがって、直接出力できない) ため、マシンが生成する状態のプリティ プリンターを定義する必要があります。
一度に表示すると出力が膨大になり、あまり参考にならないことも事実です。
印刷は、\texttt{showResults} によって制御されます。
スーパーコンビネータ コード シーケンス、状態遷移、および最終統計の 3 つの出力が生成されます。

\begin{verbatim}
  showResults :: [GmState] -> [Char]
  showResults states
    = iDisplay (iConcat [iStr "Supercombinator definitions", iNewline,
                         iInterleave iNewline (map (showSC s) (getGlobals s)),
                         iNewline, iNewline,
                         iStr "State transitions", iNewline, iNewline,
                         iLayn (map showState states),
                         iNewline, iNewline,
                         showStats (last states)])
      where (s:ss) = states
\end{verbatim}

これらのそれぞれを順番に取り上げて、\texttt{showSC} から始めます。
これにより、グローバルに関連付けられた一意のグローバル ヒープ ノードでスーパーコンビネータのコードが検出され、
\texttt{showInstructions} を使用してコード シーケンスが出力されます。

\begin{verbatim}
  showSC :: GmState -> (Name, Addr) -> Iseq
  showSC s (name, addr)
    = iConcat [ iStr "Code for ", iStr name, iNewline,
                showInstructions code, iNewline, iNewline]
      where (NGlobal arity code) = (hLookup (getHeap s) addr)
\end{verbatim}

次に、\texttt{showInstructions} を使用してコード シーケンスを出力します。

\begin{verbatim}
  showInstructions :: GmCode -> Iseq
  showInstructions is
    = iConcat [iStr " Code:{",
               iIndent (iInterleave iNewline (map showInstruction is)),
               iStr "}", iNewline]
\end{verbatim}

個々の命令の出力は、\texttt{showInstruction} によって提供されます。

\begin{verbatim}
  showInstruction :: Instruction -> Iseq
  showInstruction Unwind         = iStr "Unwind"
  showInstruction (Pushglobal f) = (iStr "Pushglobal ") `iAppend` (iStr f)
  showInstruction (Push n)       = (iStr "Push ")       `iAppend` (iNum n)
  showInstruction (Pushint n)    = (iStr "Pushint ")    `iAppend` (iNum n)
  showInstruction Mkap           = iStr "Mkap"
  showInstruction (Slide n)      = (iStr "Slide ")      `iAppend` (iNum n)
\end{verbatim}

出力の次の主要な部分は状態遷移です。 これらは、\texttt{showState} を使用して個別に処理されます。

\begin{verbatim}
  showState :: GmState -> Iseq
  showState s
    = iConcat [showStack s, iNewline,
               showInstructions (getCode s), iNewline]
\end{verbatim}

ダイアグラムに対応するために、印刷されたスタックの一番下にスタックの一番上を配置したいと考えています。
この目的のために、スタックを逆にします。

\begin{verbatim}
  showStack :: GmState -> Iseq
  showStack s
    = iConcat [iStr " Stack:[",
               iIndent (iInterleave iNewline
                       (map (showStackItem s) (reverse (getStack s)))),
               iStr "]"]
\end{verbatim}

スタック アイテムは、\texttt{showStackItem} を使用して表示されます。
スタックに格納されているアドレスと、それが指すヒープ内のオブジェクトを出力します。

\begin{verbatim}
  showStackItem :: GmState -> Addr -> Iseq
  showStackItem s a
    = iConcat [iStr (showaddr a), iStr ": ",
               showNode s a (hLookup (getHeap s) a)]
\end{verbatim}

関数 \texttt{showNode} は、グローバル名とヒープ アドレスの関連リストを逆にして、検出されたグローバル ノードを表示する必要があります。

\begin{verbatim}
  showNode :: GmState -> Addr -> Node -> Iseq
  showNode s a (NNum n) = iNum n
  showNode s a (NGlobal n g) = iConcat [iStr "Global ", iStr v]
                               where v = head [n | (n,b) <- getGlobals s, a==b]
  showNode s a (NAp a1 a2) = iConcat [iStr "Ap ", iStr (showaddr a1),
                                      iStr " ", iStr (showaddr a2)]
\end{verbatim}

最後に、\texttt{showStats} を使用して、累積された統計を出力します。

\begin{verbatim}
  showStats :: GmState -> Iseq
  showStats s
    = iConcat [ iStr "Steps taken = ", iNum (statGetSteps (getStats s))]
\end{verbatim}

以上で基本的なGマシンの説明を終わります。
今後は、より洗練されたものにする方法を検討していきます。

\subsubsection{Mark 1 Gマシンの改良}

\begin{description}

	\item[演習 3.4] プログラム\texttt{main = S K K 3}を実行します。
		何ステップかかりますか？
		テンプレートインスタンス化マシンで取得した値と異なるのはなぜですか?
		取られたステップを比較することは、マシンの公平な比較だと思いますか?

	\item[演習 3.5] Appendix B の他のプログラムを実行してみてください。
		この単純な機械には算術がないことを思い出してください。

	\item[演習 3.6] \texttt{Pushglobal}で使用したのと同じトリックを使用して\texttt{Pushint}を実装することができます:
		個別の数値ごとに、ヒープ内に一意のノードを作成します。
		たとえば、最初に\texttt{Pushint 2}を実行するとき、
		ノード\texttt{NNum 2}のヒープ内のアドレスに\texttt{"2"}を関連付けるように\texttt{gmGlobals}を更新します。

		遷移規則では、$n$ という名前のグローバルが既に存在する場合、このグローバル ノードを再利用できます。
		\vskip\baselineskip

		\begin{tabular} {|c|l r r l l|} \hline
			(3.13) &                   & \texttt{Pushint} $n$ : $i$ & $s$       & $h$ & $m$[$n$ : $a$] \\
			       & $\Longrightarrow$ & $i$                        & $a$ : $s$ & $h$ & $m$            \\ \hline
		\end{tabular}
		\vskip\baselineskip

		そうでない場合は、新しいノードを作成してグローバル マップに追加します。
		\vskip\baselineskip

		\begin{tabular} {|c|l r r l l|} \hline
			(3.14) &                   & \texttt{Pushint} $n$ : $i$ & $s$       & $h$                          & $m$            \\
			       & $\Longrightarrow$ & $i$                        & $a$ : $s$ & $h$[$a$ : \texttt{NNum} $n$] & $m$[$n$ : $a$] \\ \hline
		\end{tabular}
		\vskip\baselineskip

		このスキームの利点は、Pushint が実行されるたびにヒープ内の同じ番号のノードを再利用できることです。
		Pushint 命令のこの新しい遷移 pushint を実装します。
		グローバル コンポーネントのアクセス関数を定義して、putGlobals と呼ぶ必要があります。

\end{description}
\newpage

\subsection{Mark 2: 遅延評価させる} \label{sec:gmachinelazy}

Mark 1 Gマシンを遅延評価させるために、いくつかの小さな変更を加えます。
巻き戻す前に元の式のルートノードを上書きしないため、Mark 1 マシンは現時点では遅延評価していません。
この更新については、セクション 2.1.5 で説明します。
Mark 2 マシンでは、スーパーコンビネータの本体をインスタンス化した後、
元の redex のルートを、新しく構築されたインスタンスを指す間接ノードで上書きするという考え方です。
その効果は、マシンが前回のredex簡約の際にインスタンス化された値を「覚えている」ため、それを再計算する必要がないということです。
\vskip\baselineskip

この変更を次のように実装します。
Mark 1 マシンでは、各スーパーコンビネータのコードは [\texttt{Slide} ($n$ + 1); \texttt{Unwind}]で終了していました。
更新をキャプチャするには、これを [\texttt{Update} $n$; \texttt{Pop} $n$; \texttt{Unwind}]に置き換えます。
これを次の図に示します。
この図では、\texttt{\#} を使用して間接ノードを表しています。
\vskip\baselineskip

\includegraphics*[scale=0.6]{Fig_3-4.png}

図 3.4 は、Mark 1 マシンが \texttt{Slide} $n$ +1 命令を実行する方法を示しています。

\includegraphics*[scale=0.5]{Fig_3-5.png}

図 3.5 では、Mark 2 マシンがシーケンス [\texttt{Update} $n$; \texttt{Pop} $n$;] を実行しています。
これは、[\texttt{Slide} $n$ +1] の遅延置換として使用することを提案するシーケンスです。
\texttt{Update} 命令は、スーパーコンビネータ本体の新しく作成されたインスタンスでルートノードを上書きする役割を果たします。
\texttt{Pop} 命令は、引数が不要になったため、スタックから引数を削除するために使用されます。
\vskip\baselineskip

まず、データ構造に必要な変更を考えてみましょう。

\subsubsection{データ構造}

前回生成した単一の命令 \texttt{Slide} $n$ + 1 の代わりに、一連の命令 [\texttt{Update} $n$, \texttt{Pop} $n$] を生成します。
したがって、これらの命令を新しい命令セットに含める必要があります。

\begin{verbatim}
  data Instruction
   = Unwind
   | Pushglobal Name
   | Pushint Int
   | Push Int
   | Mkap
   | Update Int  -- Mark2で追加
   | Pop Int
  instance Eq Instruction
    where
      Unwind       == Unwind       = True
      Pushglobal a == Pushglobal b = a == b
      Pushint    a == Pushint    b = a == b
      Push       a == Push       b = a == b
      Mkap         == Mkap         = True
      Update     a == Update     b = a == b
      _            == _            = False
\end{verbatim}

\begin{description}
	\item[演習 3.7] 関数 \texttt{showInstruction} を変更して、新しい命令が表示されるようにします。
\end{description}

間接ノードを実装するには、ヒープに新しいノード タイプが必要です: 間接ノードに使用する \texttt{NInd} です。

\begin{verbatim}
  data Node
    = NNum    Int         -- Numbers
    | NAp     Addr Addr   -- Applications
    | NGlobal Int  GmCode -- Globals
    | NInd    Addr        -- Indirections  -- Mark2で追加
  instance Eq Node
    where
      NNum    a   == NNum    b   = a == b -- needed to check conditions
      NAp     a b == NAp     c d = False  -- not needed
      NGlobal a b == NGlobal c d = False  -- not needed
      NInd    a   == NInd    b   = False  -- not needed
\end{verbatim}

ここでも、データ型の拡張を反映するように、表示関数 \texttt{showNode} を再定義する必要があります。

\begin{description}
	\item[演習 3.8] \texttt{showNode} に必要な変更を加えます。
\end{description}

2 つの新しい命令のセマンティクスはまだ与えていません。
これは以下で行われます。

\subsubsection{評価器}

\texttt{Update} $n$ 命令の効果は、$n$ + 1 番目のスタック項目を、スタックの一番上にある項目への間接指定で上書きすることです。
このアドレッシングモードは、[Peyton Jones 1987] で使用されているものとは異なることに注意してください。
この命令の意図した関数適用では、$a_1, \ldots, a_n$ はスパインを形成する $n$ 個の関数適用ノードであり、$a_0$ は関数ノードです。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.15) &                   & \texttt{Update} $n$ : $i$ & $a$ : $a_0$ : $\ldots$ : $a_n$ : $s$ & $h$                            & $m$ \\
	       & $\Longrightarrow$ & $i$                       & $a_0$ : $\ldots$ : $a_n$ : $s$       & $h$[$a_n$ : \texttt{NInd} $a$] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Pop} $n$ 命令は、$n$ 個のスタック項目を単純に削除します。
繰り返しますが、Mark 2 Gマシンでは、$a_1, \ldots, a_n$ は redex のスパインを形成する関数適用ノードです。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.16) &                   & \texttt{Pop} $n$ : $i$ & $a_1$ : $\ldots$ : $a_n$ : $s$ & $h$ & $m$ \\
	       & $\Longrightarrow$ & $i$                    & $s$                            & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

スタックアイテムのトップが間接の場合、\texttt{Unwind} の遷移も定義する必要があります。
その結果、現在のスタックアイテムが間接参照が指すアイテムに置き換えられます。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.17) &                   & [\texttt{Unwind}] & $a_0$ : $s$ & $h$[$a_0$ : \texttt{NInd} $a$] & $m$ \\
	       & $\Longrightarrow$ & [\texttt{Unwind}] & $a$ : $s$   & $h$                            & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 3.9] Mark 1 マシンの\texttt{dispatch}関数を変更して、新しい命令を組み込みます。
		新しい遷移規則を実装します。
\end{description}

\subsubsection{コンパイラ}

コンパイラに対する唯一の変更点は、$\mathcal{R}$ スキームによって生成されたコードにあります。
新しい定義を図 3.6 に示します。
\vskip\baselineskip

\begin{tabular}{|l|} \hline
	$\mathcal{R}\llbracket e \rrbracket ~ \rho ~ d$ は、アリティ $d$ のスーパーコンビネータのために、                                                                          \\
	環境 $\rho$ で式 $e$ をインスタンス化するコードを生成し、                                                                                                                  \\
	次に、結果のスタックの巻き戻しに進みます。                                                                                                                                 \\
	\\
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d = \mathcal{C} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ [\texttt{Update} ~ d, ~ \texttt{Pop} ~ d, ~ \texttt{Unwind}]$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 3.10] \texttt{compileR} を変更して、新しい $\mathcal{R}$ スキームを実装します。

	\item[演習 3.11] 次のプログラムで遅延評価を実行します。
		\begin{verbatim}
    twice f x = f (f x)
    id x = x
    main = twice twice id 3
  \end{verbatim}
		何ステップかかりますか？
		Mark1マシンで取得した値と異なるのはなぜですか?
		マシンのステップ数を比較するのは公正ですか?
\end{description}
\newpage

\subsection{Mark 3: let(rec) 式}

本体に \texttt{let(rec)} \textbf{バインド変数}を含むスーパーコンビネータをコンパイラが受け入れるように、言語を拡張します。
これらは、コンストラクタ \texttt{Elet} によってデータ型 \texttt{coreExpr} で表されます。
3 つの引数を取ります。定義を再帰的に処理するかどうかを示すブール フラグ、定義自体、および定義を使用する式です。
\vskip\baselineskip

ローカル定義を追加してマシンを拡張する前に、スタックをもう一度見てみましょう。
特に、変数のより効率的な\textbf{アクセス方法}を定義しようとします。
効率の引数に加えて、ローカルにバインドされた変数へのアクセスを、関数パラメータのバインドに使用されるものと同じにしたいと考えています。
\vskip\baselineskip

\textbf{スタックからの引数アクセス}
\vskip\baselineskip

巻き戻しプロセスがスーパーコンビネータノード \texttt{f} に到達し、スーパーコンビネータが $n$ 個の引数を取るとします。
Mark 1 マシンでは、スタックは図 3.7 の左側の図に示す状態になります。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-7.png}

スーパーコンビネータ \texttt{f} に到達したので、Mark 3 G マシンでは、スタックがわずかに変更されています。
同等の Mark 3 スタックを図 3.7 の右側の図に示します。 上位 $n$ 要素は式 \texttt{e1} ... \texttt{en} を直接指しています。
ここで重要な点は、変数へのアクセスが高速になることです (変数が少なくとも 1 回アクセスされる場合)。
これは、右側の引数を取得するために、関数適用ノードを 1 回しか見ていないためです。
\vskip\baselineskip

これにより、スーパーコンビネータで仮パラメータに代入される式へのアクセス効率が向上します。

Mark1マシンに関して:

\begin{itemize}
	\item \texttt{Push} 命令で関数 \texttt{getArg} はもう必要ありません。
	\item しかし、十分な引数でスーパーコンビネータを \texttt{Unwind} するときは、スタックを再配置する必要があります。
\end{itemize}

\texttt{Update} を実行できるように、redex のルートへのポインターを保持していることに注意してください。
\vskip\baselineskip

\textbf{命令への影響}
\vskip\baselineskip

新しいスタックレイアウトを使用することを選択した場合、対処するために特定のマシン命令を変更する必要があります。
影響を受ける命令は、\texttt{Push} と \texttt{Unwind} です。
引数を取得するために関数適用ノードを「調べる」必要がないため、\texttt{Push} 命令を変更する必要があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.18) &                   & \texttt{Push}  $n$ : $i$ & $a_0$ : $\ldots$ : $a_n$ : $s$         & $h$ & $m$ \\
	       & $\Longrightarrow$ & $i$                      & $a_n$ : $a_0$ : $\ldots$ : $a_n$ : $s$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

新しいスタックレイアウトに必要なその他の変更は、\texttt{Unwind} がスタックを再配置する必要があることです。
十分な引数を持つスーパーコンビネータがスタックの一番上にある場合は常に、この再配置が必要です。
\texttt{Unwind} の新しい遷移規則は次のとおりです。

\vskip\baselineskip

\begin{tabular} {|c|l r r l l|} \hline
	(3.19) &                   & [\texttt{Unwind}] & $a_0 : \ldots : a_n : s$         & $h\left[\begin{array}{l}
				                                                                                            a_0 : \texttt{NGlobal} ~ \textit{n} ~ \textit{c} \\
				                                                                                            a_1 : \texttt{NAp} ~ a_0 ~ a_1'                  \\
				                                                                                            $\ldots$                                         \\
				                                                                                            a_n : \texttt{NAp} ~ a_{n-1} ~ a_n'
			                                                                                            \end{array}\right]$ & $m$  \\
	       & $\Longrightarrow$ & c                 & $a_1' : \ldots : a_n' : a_n : s$ & $h$                                                 & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Unwind} のこの定義は、$n$ がゼロの場合に適切に機能することに注意してください。

\begin{description}
	\item[演習 3.12] \texttt{dispatch}関数と新しい命令セットの新しい遷移を書き直します。
		スタックを再配置するには、\texttt{rearrange} 関数を使用する必要があります。
		\begin{verbatim}
    rearrange :: Int -> GmHeap -> GmStack -> GmStack
    rearrange n heap as
      = take n as' ++ drop n as
        where as' = map (getArg . hLookup heap) (tl as)
        \end{verbatim}

	\item[演習 3.13] Appendix B のいくつかのサンプルプログラムでコンパイラと新しい抽象マシンをテストし、実装が引き続き機能することを確認します。
\end{description}

\subsubsection{ローカルにバインドされた変数}

ここで、最初に非再帰的なケースを考慮して、\texttt{let(rec)} 式の実装に戻ります。
式 $\texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e$ の
変数 $x_1 ~ \ldots ~ x_n$ は、式 $e_1 ~ \ldots ~ e_n$ が作成されると、スーパーコンビネータへの引数と同じ方法で処理できます。
つまり、変数 $x_1 ~ \ldots ~ x_n$ にオフセットを介してスタックにアクセスし、環境を使用してそれらの位置を記録します。
\vskip\baselineskip

ローカル定義を構築するためのコードが\texttt{Code}であると仮定すると、図 3.8 に示す一連のアクションが必要になります。
最初に、スタックにはスーパーコンビネータへの引数へのポインタが含まれます。
ローカル定義を構築するコードが実行されると、スタック上に $n$ 個の新しいポインタができます。
$x_i$ を $e_i$ へのポインタにマップする新しい環境で、 \texttt{let} 式の本体の作成に進むことができます。
最後に、式 $e_1 ~ \ldots ~ e_n$ へのポインタをスタックから捨てる必要があります。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-8.png}

$n$ 個の新しい変数をスタック $(x_1 \ldots x_n )$ に追加したため、$e$ をコンパイルするために使用する変数マップでこの事実に注意する必要があります。
ローカルバインディングを構築するコード (\texttt{Code}と呼びます) は、単純に各式 $e_1 \ldots e_n$ のグラフを作成し、グラフの断片のアドレスをスタックに残します。
\vskip\baselineskip

変数 $x_1 \ldots x_n$ のいずれかを使用する本体式 $e$ を作成した後、スタックから $e_1 \ldots e_n$ へのポインタを削除する必要があります。
これは、\texttt{Slide}命令を使用して達成されます。
非再帰的なローカル定義をコンパイルするための完全なスキームは、図 3.10 (p.109) に示されています。
\vskip\baselineskip

再帰的なローカル定義の状況はより複雑です。変数 $x_1 ~ \ldots ~ x_n$ がスコープ内にあるように、
式 $e_1 ~ \ldots ~ e_n$ のそれぞれをコンパイルする必要があります。
これを行うには、グラフに空のノードを作成し、それらへのポインタをスタックに残します。
次に、各式 $e_1 ~ \ldots ~ e_n$ は、非再帰ケースの本体のコンパイルに使用したのと同じ変数マップを使用してコンパイルされます。
各式のコンパイル済みコードの最後に、空のノードを正しいグラフで上書きする \texttt{Update} 命令を配置します。
これを行うには、\texttt{n} 個の空のグラフノードを作成する新しい命令 \texttt{Alloc n} が1つ必要です。
図 3.9 では、空のグラフノードは \texttt{?} 記号で表されます。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-9.png}

図 3.9 に示すプロセスは、各式 $e_1 ~ \ldots ~ e_n$ が処理されるまで繰り返す必要があります。
本体 $e$ のコードのコンパイルは、非再帰的なローカル定義の前のケースと同じです。
Mark3マシン用の新しいデータ型を追加します。

\subsubsection{データ構造}

命令データ型には、新しい \texttt{Alloc} 命令と Mark1 マシンからの \texttt{Slide} 命令を含む、Mark2 マシンのすべての命令が含まれます。

\begin{description}
	\item[演習 3.14] \texttt{Alloc} と \texttt{Slide} が含まれるように、データ型\texttt{instruction}を変更します。
		また、これらの新しい命令に対応するために、関数 \texttt{showInstruction} を変更する必要があります。
\end{description}

\subsubsection{評価器}

Mark3 G マシンの場合、ヒープ内に $n$ 個の場所を作成する \texttt{Alloc} 命令を追加する必要があります。
これらの場所を使用して、ローカルにバインドされた式を保存する場所をマークします。
これらのノードは、無効なヒープアドレス \texttt{hNull} を指す間接ノードとして最初に作成されます。
\texttt{Alloc} によって作成されたこれらのノードは上書きされるため、それらにどの値を割り当てるかは問題ではありません。

\texttt{Alloc} 命令の遷移関数である \texttt{alloc} を実装するには、補助関数 \texttt{allocNodes} を使用します。
必要なノード数と現在のヒープを指定すると、変更されたヒープと間接ノードのアドレスのリストで構成されるペアが返されます。

\begin{verbatim}
  allocNodes :: Int -> GmHeap -> (GmHeap, [Addr])
  allocNodes 0 heap = (heap, [])
  allocNodes (n+1) heap = (heap2, a:as)
                          where (heap1, as) = allocNodes n heap
                                (heap2, a) = hAlloc heap1 (NInd hNull)
\end{verbatim}

\begin{description}
	\item[演習 3.15] 新しい命令のケースを使用して、\texttt{dispatch}関数を拡張します。
		\texttt{AllocNodes} を使用して、\texttt{Alloc} 命令の遷移関数である \texttt{alloc} を実装する必要があります。
\end{description}

\subsubsection{コンパイラ}

コンパイラに対する唯一の変更点は、$\mathcal{C}$ スキームがコードをコンパイルできるケースが2つ増えたことです。
\texttt{compileC} への変更は簡単です。
より広い範囲の \texttt{coreExpr} に対応できるようになりました。
\texttt{compileLetrec} と \texttt{compileLet} という 2 つの新しい関数が必要です。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{C} \llbracket e \rrbracket ~ \rho$ は、環境 $\rho$ で $e$ のグラフを構築するコードを生成し、 \\
	それへのポインターをスタックの一番上に残します。                                                       \\
	\begin{tabular}{l c l l}
		$\mathcal{C} \llbracket f \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Pushglobal} ~ f \right]$                                                         & ここで、$f$ はスーパーコンビネータです。                                                             \\
		$\mathcal{C} \llbracket x \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Push} ~ (\rho ~ x) \right]$                                                      & ここで、$x$ はローカル変数です。                                                                     \\
		$\mathcal{C} \llbracket i \rrbracket ~ \rho$         & $=$ & $\left[\texttt{Pushint} ~ i \right]$                                                            &                                                                                                      \\
		$\mathcal{C} \llbracket e_0 ~ e_1 \rrbracket ~ \rho$ & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++}$                                    &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e_0 \rrbracket ~ \rho^{+1} ~ \texttt{++} ~ \left[\texttt{Mkap} \right]$ & ここで、$\rho^{+n} ~ x = (\rho ~ x) + n$ です。                                                      \\
		\multicolumn{4}{l}{$\mathcal{C} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                      \\
		                                                     & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+0} ~ \texttt{++}$                               &                                                                                                      \\
		                                                     &     & $\ldots$                                                                                        &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho^{+(n - 1)} ~ \texttt{++}$                         &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$   & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。 \\
		\multicolumn{4}{l}{$\mathcal{C} \llbracket \texttt{letrec} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                   \\
		                                                     & $=$ & $\left[\texttt{Alloc} ~ n\right] ~ \texttt{++}$                                                 &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho' ~ \texttt{++}$                                   &                                                                                                      \\
		                                                     &     & $\left[\texttt{Update} ~ n - 1\right] ~ \texttt{++}$                                            &                                                                                                      \\
		                                                     &     & $\ldots$                                                                                        &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho' ~ \texttt{++}$                                   &                                                                                                      \\
		                                                     &     & $\left[\texttt{Update} ~ 0\right] ~ \texttt{++}$                                                &                                                                                                      \\
		                                                     &     & $\mathcal{C} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$   & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。 \\ \hline
	\end{tabular}
\end{tabular}
\vskip\baselineskip

\begin{verbatim}
  compileC :: GmCompiler
  compileC (EVar v) args
    | elem v (aDomain args) = [Push n]
    | otherwise             = [Pushglobal v]
    where n = aLookup args v (error "")
  compileC (ENum n)    env = [Pushint n]
  compileC (EAp e1 e2) env = compileC e2 env ++
                             compileC e1 (argOffset 1 env) ++
                             [Mkap]
  compileC (ELet recursive defs e) args
    | recursive = compileLetrec compileC defs e args
    | otherwise = compileLet    compileC defs e args
\end{verbatim}

\texttt{compileLet} の定義は、図 3.10 の仕様に従います。
引数として、本体 \texttt{e} のコンパイルスキーム \texttt{comp}、定義 \texttt{defs}、および現在の環境 \texttt{env} を受け取ります。
マシンの新しいバージョンでこの関数を書き直す必要がないように、コンパイラパラメータを提供しました。

\begin{verbatim}
  compileLet :: GmCompiler -> [(Name, CoreExpr)] -> GmCompiler
  compileLet comp defs expr env
    = compileLet' defs env ++ comp expr env' ++ [Slide (length defs)]
      where env' = compileArgs defs env
\end{verbatim}

新しい定義のコンパイルは、関数 \texttt{compileLet'} によって実行されます。

\begin{verbatim}
  compileLet' :: [(Name, CoreExpr)] -> GmEnvironment -> GmCode
  compileLet' [] env = []
  compileLet' ((name, expr):defs) env
    = compileC expr env ++ compileLet' defs (argOffset 1 env)
\end{verbatim}

\texttt{compileLet} はまた、\texttt{compileArgs} を使用して、本体のコンパイル用のスタックへのオフセットを変更します。
\vskip\baselineskip

\begin{verbatim}
  compileArgs :: [(Name, CoreExpr)] -> GmEnvironment -> GmEnvironment
  compileArgs defs env
    = zip (map first defs) [n-1, n-2 .. 0] ++ argOffset n env
      where n = length defs
\end{verbatim}

\textbf{例}
\vskip\baselineskip

この例では、不動点コンビネータ \texttt{Y} のコードがどのようにコンパイルされるかを示します。
使用する定義は次のとおりです。

\begin{verbatim}
  Y f = letrec x = f x in x
\end{verbatim}

これは、いわゆる「結び目」不動点コンビネータです。 結果のコードを実行すると、なぜこの名前になっているのかがわかります。
上記の定義がコンパイルされると、\texttt{compileSc} 関数は
スーパーコンビネータのコードを作成する必要があります。

\begin{verbatim}
  compileSc ("Y", ["f"], ELet True [("x", EAp (EVar "f") (EVar "x"))] (EVar "x"))
\end{verbatim}

これは、変数 \texttt{f} の環境で \texttt{compileR} 関数を呼び出します。
最初にスーパーコンビネータの名前 (\texttt{Y}) とその引数の数 (\texttt{1}) を作成しました。

\begin{verbatim}
  ("Y", 1, compileR e [("f", 0)])
  where e = ELet True [("x", EAp (EVar "f") (EVar "x"))] (EVar "x")
\end{verbatim}

便宜上、式の本体を \texttt{e} と呼びます。
関数 \texttt{compileR} は \texttt{compileC} を呼び出し、最後に片付けコードを配置します。

\begin{verbatim}
  ("Y", 1, compileC e [("f", 0)] ++ [Update 1, Pop 1, Unwind])
\end{verbatim}

図 3.10 のコンパイルスキームを参照すると、\texttt{letrec} をコンパイルするには、最初に新しい環境を作成することがわかります。
図では、これは $\rho'$ と呼ばれます。 この例では、\texttt{p} と呼びます。
これは初期環境の拡張であり、ローカル変数 \texttt{x} にスタックの場所も与えます。

\begin{verbatim}
  ("Y", 1, [Alloc1] ++
           compileC (EAp (EVar "f") (EVar "x")) p ++ [Update 0] ++
           compileC (EVar "x") p ++ [Slide 1] ++
           [Update 1, Pop 1, Unwind])
           where p = [("x", 0), ("f", 1)]
\end{verbatim}

コード生成は、コンパイルスキームと同じ方法でレイアウトされます。
\texttt{compileC} を含む式を単純化すると、次のようになります。

\begin{verbatim}
  ("Y", 1, [Alloc 1] ++
           [Push 0, Push 2, Mkap] ++ [Update 0] ++
           [Push 0] ++ [Slide 1] ++
           [Update 1, Pop 1, Unwind])
\end{verbatim}

これにより、次のコードシーケンスが得られます。

\begin{verbatim}
  ("Y", 1, [Alloc 1, Push 0, Push 2, Mkap, Update 0, Push 0,
            Slide 1, Update 1, Pop 1, Unwind])
\end{verbatim}

このコードがどのように実行されるかは、図 3.11 で確認できます。
\texttt{Y} スーパーコンビネータのこの定義は、5番目の命令として \texttt{Update 0} を実行するときにグラフに結び目を作るため、「結び目」と呼ばれます。
演習 3.18 として残されているため、残りの手順は示していません。

\includegraphics*[scale=0.5]{Fig_3-11.png}

\begin{description}
	\item[演習 3.16] \texttt{letrec} のコンパイルは、図 3.10 で定義されています。
		この操作を実行するには、関数 \texttt{compileLetrec} を実装します。

	\item[演習 3.17] 新しいコンパイラと命令セットが適切に動作することを示すために、どのテスト プログラムを使用しますか?

	\item[演習 3.18] スーパーコンビネータ \texttt{Y} 用に生成されたコードを実行するか、そうでない場合は、残りの状態遷移を図 3.11 のスタイルで描画します。

	\item[演習 3.19] スーパーコンビネータ \texttt{Y} の短い代替コードシーケンスを指定します。
		それはまだ「結び目」バージョンを構築する必要があります。

	\item[演習 3.20] 言語に \texttt{letrec} 構文がない場合、不動点コンビネータ \texttt{Y} をどのように定義しますか?
		この定義は、例で使用した定義とどう違うのでしょうか?
\end{description}
\newpage

\subsection{Mark 4: プリミティブの追加} \label{sec:gmachineadprim}

このセクションでは、基本的な操作をGマシンに追加します。これは便利です。
基本演算とは、加算、乗算などの演算を意味します。
このセクションでは、実行例として足し算を使用します。
\vskip\baselineskip

加算命令は\texttt{Add}と呼ばれます。ヒープから2つの数値を追加し、結果をヒープ内の新しいノードに配置します。
2つの引数のアドレスはスタックの一番上にあります。
これは、結果のアドレスがその後配置される場所です。
次の遷移規則があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.21) &                   & \texttt{Add} : $i$ & $a_0$ : $a_1$ : $s$ & $d$ & $h$[$a_0$ : \texttt{NNum} $n_0$, ~ $a_1$ : \texttt{NNum} $n_1$] & $m$ \\
	       & $\Longrightarrow$ & $i$                & $a$ : $s$           & $d$ & $h$[$a$ : \texttt{NNum} ($n_0 ~ + ~ n_1$)]                      & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

必要な残りの操作を実装するために、他の命令でGマシンを拡張し続けることができますが、
その前に、ここで何か見逃していないかどうかを検討するために一時停止しましょう。
問題は、スタックの一番上にある2つのオブジェクトが数値である場合にのみルールが適用されることです。
遅延評価をサポートするマシンで作業しているため、これが常に当てはまると想定する正当な理由はありません。
テンプレートマシンで\texttt{Add}は、その引数が評価されることを確認しました。
Gマシンでは、命令を単純に保ちたいので、引数が既に評価されていることが保証されている状況でのみ\texttt{Add}を使用します。
\vskip\baselineskip

代わりに、\texttt{Eval}命令を使用して命令セットをさらに拡張します。
これは、次の制約を満たします。
\vskip\baselineskip

\begin{quote}
	次の状態にあるとします。

	\begin{center}
		\begin{tabular} {|c c c c|} \hline
			\texttt{Eval} : $i$ & $a$ : $s$ & $h$ & $m$ \\ \hline
		\end{tabular}
	\end{center}

	命令シーケンス$i$で実行が再開されるたびに、状態は次のようになります。

	\begin{center}
		\begin{tabular} {|c c c c|} \hline
			$i$ & $a$ : $s$ & $h'$ & $m$ \\ \hline
		\end{tabular}
	\end{center}

	スタックの一番上にあるアイテムは WHNF になります。
	\texttt{Eval} が終了しない可能性もあります。 これは、スタックの一番上から指されたノードに WHNF がない場合に当てはまります。
\end{quote}
\vskip\baselineskip

アドレスがスタックの一番上にあるノードが既に WHNF にある場合、\texttt{Eval} 命令は何もしません。
実行するリダクションがある場合、\texttt{Eval} のアクションは WHNF に対する評価を実行することです。
この呼び出しが終了すると、ヒープ コンポーネント以外は何も変更されずに実行が再開されます。
これは、プログラミング言語の実装で伝統的に使用されているサブルーチンの呼び出しと戻りの構造に似ています。
この機能を実装する古典的な方法は、スタックを使用することです。
スタックは、サブルーチン呼び出しが完了したときに再開できるように、マシンの現在のコンテキストを十分に保存します。
\vskip\baselineskip

Mark 4 G マシンでは、このスタックは\textbf{ダンプ}と呼ばれ、
最初のコンポーネントがコード シーケンスで、2 番目のコンポーネントがスタックであるペアのスタックです。
これは、元のコード シーケンスと元のスタックを復元する必要があることを除いて、テンプレート マシンのダンプ (セクション 2.6 を参照) に似ています。
したがって、両方のコンポーネントがダンプに保持されます。

\subsubsection{データ構造}

ダンプコンポーネントを追加して、Gマシンの状態を拡張します。
前に説明したように、これは評価器への再帰呼び出しを実装するために使用されます。

\begin{verbatim}
  type GmState = ( GmCode, -- current Instruction
                   GmStack, -- current Stack
                   GmDump, -- current Dump
                   GmHeap, -- Heap of Nodes
                   GmGlobals, -- Global adresses in Heap
                   GmStats) -- Statistics
\end{verbatim}

ダンプ自体は、\texttt{dumpItem}のスタックです。
これらはそれぞれ、元の計算を再開するときに使用する命令ストリームとスタックで構成されるペアです。

\begin{verbatim}
  type GmDump = [GmDumpItem]
  type GmDumpItem = (GmCode, GmStack)
\end{verbatim}

この新しいコンポーネントを追加するときは、以前に指定したすべてのアクセス機能を変更する必要があります。
ダンプ用のアクセス機能も追加する必要があります。

\begin{verbatim}
  getDump :: GmState -> GmDump
  getDump (i, staxk, dump, heap, globals, stats) = dump

  putDump :: GmDump -> GmState -> GmState
  putDump dump' (i, stack, dump, heap, globals, stats)
    = (i, stack, dump', heap, globals, stats)
\end{verbatim}

Gマシンの状態でパターンマッチングを行ったのはアクセス関数のみであることに注意してください。
新しいコンポーネントを状態に追加した結果としての他の関数への変更は、もはや必要ありません。

\begin{description}
	\item[演習 3.21] 他のアクセス機能に関連する変更を加えます。
\end{description}

状態の新しい定義に加えて、いくつかの新しい指示も必要です。
Mark3マシンからのすべての命令を再利用します。

\begin{verbatim}
  data Instruction
    = Slide Int
    | Alloc Int
    | Update Int
    | Pop Int
    | Unwind
    | Pushglobal Name
    | Pushint Int
    | Push Int
    | Mkap
\end{verbatim}

さらに、Eval 命令を含めます。

\begin{verbatim}
    | Eval
\end{verbatim}

次の算術命令:

\begin{verbatim}
    | Add | Sub | Mul | Div | Neg
\end{verbatim}

および次の比較命令:

\begin{verbatim}
    | Eq | Ne | Lt | Le | Gt | Ge
\end{verbatim}

また、\texttt{Cond} 命令にはプリミティブ形式の条件分岐も含まれています。

\begin{verbatim}
    | Cond GmCode GmCode
\end{verbatim}

\begin{description}
	\item[演習 3.22] ケースを\texttt{showInstruction} に追加して、新しい指示をすべて出力します。
\end{description}

\subsubsection{状態の表示}

これを機に showState の定義を見直し、dump コンポーネントを表示するようにしました。

\begin{verbatim}
  showState :: GmState -> Iseq
  showState s
    = iConcat [showStack s, iNewline,
               showDump s, iNewline,
               showInstructions (getCode s), iNewline]
\end{verbatim}

したがって、\texttt{showDump} を定義する必要があります。

\begin{verbatim}
  showDump :: GmState -> Iseq
  showDump s
    = iConcat [iStr " Dump:[",
               iIndent (iInterleave iNewline (map showDumpItem (reverse (getDump s)))),
               iStr "]"]
\end{verbatim}

これには、関数 \texttt{showDumpItem} が必要です。

\begin{verbatim}
  showDumpItem :: GmDumpItem -> Iseq
  showDumpItem (code, stack)
    = iConcat [iStr "<",
               shortShowInstructions 3 code, iStr ", ",
               shortShowStack stack, iStr ">"]
\end{verbatim}

関数 \texttt{shortShowInstructions} を使用して、命令ストリームの最初の 3 つの命令のみをダンプ項目に出力します。
これは通常、計算が再開される場所を示すのに十分です。

\begin{verbatim}
  shortShowInstructions :: Int -> GmCode -> Iseq
  shortShowInstructions number code
    = iConcat [iStr "{", iInterleave (iStr "; ") dotcodes, iStr "}"]
      where codes = map showInstruction (take number code)
            dotcodes | length code > number = codes ++ [iStr "..."]
                     | otherwise            = codes
\end{verbatim}

同様に、ダンプ アイテムのスタック コンポーネントの完全な詳細も必要ないため、\texttt{shortShowStack} を使用します。

\begin{verbatim}
  shortShowStack :: GmStack -> Iseq
  shortShowStack stack
    = iConcat [iStr "[",
               iInterleave (iStr ", ") (map (iStr . showaddr) stack),
               iStr "]"]
\end{verbatim}

\subsubsection{新しい命令遷移} \label{sec_3_6_3}

\textbf{評価命令}
\vskip\baselineskip

実際には、ダンプを操作する命令はほとんどありません。
まず、\texttt{Eval} 自体があり、スタックの最上位のノードが WHNF にない場合は常に新しいダンプ項目を作成します。
2 つ目は、評価が完了したときにダンプ項目をポップする \texttt{Unwind} 命令への変更です。
\vskip\baselineskip

まず、新しい \texttt{Unwind} 命令について説明します。
スタックに保持されている式が WHNF にある場合、\texttt{Unwind} はダンプから古いコンテキストを復元し、
復元された古いスタックにスタック内の最後のアドレスを配置できます。
これは、数値の場合の遷移で明確にわかります。\footnote{ルールは、ダンプが空でない場合にのみ適用されます。 ダンプが空の場合、マシンは終了しています。}
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.22) &                   & [\texttt{Unwind}] & $a$ : $s$  & $\langle i', ~ s' \rangle$ : $d$ & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\
	       & $\Longrightarrow$ & $i'$              & $a$ : $s'$ & $d$                              & $h$                          & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

アドレス $a$ の式は整数であるため WHNF にあるため、古い命令シーケンス $i'$ を復元すると、スタックはアドレス $a$ を先頭にした古いスタック $s'$ になります。
\texttt{Unwind} の他のすべてのトランジションは、Mark 3 マシンの場合と同じままです (ダンプ コンポーネントがその状態にあることを除いて)。
\vskip\baselineskip

これで、\texttt{Eval} のルールを指定できるようになりました。 スタック $s$ の残りと残りの命令 $i$ をダンプ項目としてダンプに保存します。
新しいコード シーケンスはちょうど巻き戻されており、新しいスタックにはシングルトン $a$ が含まれています。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.23) &                   & \texttt{Eval} : $i$ & $a$ : $s$ & $d$                            & $h$ & $m$ \\
	       & $\Longrightarrow$ & [\texttt{Unwind}]   & [$a$]     & $\langle i, ~ s \rangle$ : $d$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\textbf{算術命令}
\vskip\baselineskip

すべての2項算術演算子には、次の一般的な遷移規則があります。
実装したい算術演算子が $\odot$ であると仮定しましょう。 命令の遷移規則は次のとおりです。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.24) &                   & $\odot$ : $i$ & $a_0$ : $a_1$ : $s$ & $d$ & $h$[$a_0$ : \texttt{NNum} $n_0$, ~ $a_1$ : \texttt{NNum} $n_1$] & $m$ \\
	       & $\Longrightarrow$ & $i$           & $a$ : $s$           & $d$ & $h$[$a$ : \texttt{NNum} ($n_0 ~ \odot ~ n_1$)]                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

何が起こったかというと、スタックの一番上にある2つの数値に2項演算子$\odot$が適用されています。
ヒープに入力された結果のアドレスは、スタックに配置されます。
\texttt{Neg} 命令は、スタックの一番上にある数値を否定するため、遷移規則があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.25) &                   & \texttt{Neg} : $i$ & $a$ : $s$  & $d$ & $h$[$a$ : \texttt{NNum} $n$]     & $m$ \\
	       & $\Longrightarrow$ & $i$                & $a'$ : $s$ & $d$ & $h$[$a'$ : \texttt{NNum} (-$n$)] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

すべての二項演算がいかに類似しているかに注目してください。
最初にヒープから 2 つの数値を抽出し、次に演算を実行し、最後に答えをヒープに戻します。
これは、ヒープからの抽出 (値の「ボックス化解除」と呼びます) をパラメーター化する高階関数を作成する必要があることを示唆しています。
そして、実行したい特定の操作とともに、ヒープに挿入します (これを値の「ボクシング」と呼びます)。
\vskip\baselineskip

最初にボクシング操作を書きましょう。
\texttt{boxInteger} は数値と初期状態を取り、数値がヒープに配置された新しい状態と、スタックの一番上に残されたこの新しいノードへのポインターを返します。

\begin{verbatim}
  boxInteger :: Int -> GmState -> GmState
  boxInteger n state
    = putStack (a: getStack state) (putHeap h' state)
      where (h', a) = hAlloc (getHeap state) (NNum n)
\end{verbatim}

ステートからアドレス $a$ の整数を抽出するには、\texttt{unboxInteger} を使用します。

\begin{verbatim}
  unboxInteger :: Addr -> GmState -> Int
  unboxInteger a state
    = ub (hLookup (getHeap state) a)
      where ub (NNum i) = i
            ub n        = error "Unboxing a non-integer"
\end{verbatim}

一般的なモナド演算子は、ボックス化関数 \texttt{box}、ボックス化解除関数 \texttt{unbox}、
およびボックス化されていない値に対する演算子 \texttt{op} に関して指定できるようになりました。

\begin{verbatim}
  primitive1 :: (b -> GmState -> GmState) -- boxing function
                -> (Addr -> GmState -> a) -- unbixing function
                -> (a -> b)               -- operator
                -> (GmState -> GmState)   -- state transition
  primitive1 box unbox op state
    = box (op (unbox a state)) (putStack as state)
      where (a:as) = getStack state
\end{verbatim}

汎用二項演算子は、\texttt{primitive2} を使用して同様の方法で実装できるようになりました。

\begin{verbatim}
  primitive2 :: (b -> GmState -> GmState) -- boxing function
                -> (Addr -> GmState -> a) -- unbixing function
                -> (a -> a -> b)          -- operator
                -> (GmState -> GmState)   -- state transition
  primitive2 box unbox op state
    = box (op (unbox a0 state) (unbox a1 state)) (putStack as state)
      where (a0:a1:as) = getStack state
\end{verbatim}

もっと明確に言うと、\texttt{arithmetic1} はすべての単項算術を実装し、\texttt{arithmetic2} はすべての二項算術を実装します。

\begin{verbatim}
  arithmetic1 :: (Int -> Int)            -- arithmetic operator
                 -> (GmState -> GmState) -- state transition
  arithmetic1 = primitive1 boxInteger unboxInteger

  arithmetic2 :: (Int -> Int -> Int)     -- arithmetic operation
                 -> (GmState -> GmState) -- state transition
  arithmetic2 = primitive2 boxInteger unboxInteger
\end{verbatim}

注意深い読者が予想するように、これらの関数の一般性をこの章の後半で利用します。

\begin{description}
	\item[演習 3.23] マシンの新しい命令遷移をすべて実装します。
		\texttt{dispatch}関数を変更して、新しい命令を処理します。
		高階関数の\texttt{primitive1} と\texttt{primitive2} を使用して、演算子を実装する必要があります。
	\item[演習 3.24] \texttt{Eval} 命令の完了時に間接ノードがスタックの一番上に残らないのはなぜですか?
\end{description}

\textbf{比較命令}
\vskip\baselineskip

すべての\textbf{比較演算子}には、次の一般的な遷移規則があります。
実装したい比較演算子が $\odot$ であると仮定すると、命令 $\odot$ の遷移規則は次のようになります。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.26) &                   & $\odot$ : $i$ & $a_0$ : $a_1$ : $s$ & $d$ & $h$[$a_0$ : \texttt{NNum} $n_0$, ~ $a_1$ : \texttt{NNum} $n_1$] & $m$ \\
	       & $\Longrightarrow$ & $i$           & $a$ : $s$           & $d$ & $h$[$a$ : \texttt{NNum} ($n_0 ~ \odot ~ n_1$)]                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

スタックの一番上にある2つの数値には、2項演算子 $\odot$ が適用されています。
ヒープに入力された結果のアドレスは、スタックに配置されます。
これは算術演算とほぼ同じです
\vskip\baselineskip

違いは、たとえば \texttt{==} という操作は、整数ではなくブール値を返すことです。
これを修正するために、次のルールを使用してブール値を整数に変換します。

\begin{itemize}
	\item \texttt{True} を整数 \texttt{1} で表します。
	\item \texttt{False} は整数 \texttt{0} で表します。
\end{itemize}

\texttt{Primitive2} の使用を可能にするために、\texttt{boxBoolean} を定義します。

\begin{verbatim}
  boxBoolean :: Bool -> GmState -> GmState
  boxBoolean b state
    = putStack (a: getStack state) (putHeap h' state)
      where (h',a) = hAlloc (getHeap state) (NNum b')
            b' | b         = 1
               | otherwise = 0
\end{verbatim}

この定義を使用して、\texttt{comparison}と呼ばれる一般的な比較関数を書くことができます。
この関数は、ブール値のボックス化関数、整数のボックス化解除関数 (\texttt{unboxInteger})、および比較演算子を取ります。
そして状態遷移を返します。

\begin{verbatim}
  comparison :: (Int -> Int -> Bool) -> GmState -> GmState
  comparison = primitive2 boxBoolean unboxInteger
\end{verbatim}

最後に、\texttt{if} 関数のコンパイルに使用する \texttt{Cond} 命令を実装します。
次の2つの遷移規則があります。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.27) &                   & \texttt{Cond} ~ $i_1$ ~ $i_2$ : $i$ & $a$ : $s$ & $d$ & $h$[$a$ : \texttt{NNum 1}] & $m$ \\
	       & $\Longrightarrow$ & $i_1$ \texttt{++} $i$               & $s$       & $d$ & $h$                        & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

最初のケース (スタックの一番上に数字の \texttt{1} がある場合) では、最初の分岐を取ります。
これは、命令 $i$ の実行を続ける前に、命令 $i_1$ を実行することを意味します。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.28) &                   & \texttt{Cond} ~ $i_1$ ~ $i_2$ : $i$ & $a$ : $s$ & $d$ & $h$[$a$ : \texttt{NNum 0}] & $m$ \\
	       & $\Longrightarrow$ & $i_2$ \texttt{++} $i$               & $s$       & $d$ & $h$                        & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

あるいは、スタックの一番上の番号が \texttt{0} の場合、最初に命令シーケンス $i_2$ を実行し、次にシーケンス $i$ を実行します。

\begin{description}
	\item[演習 3.25] 比較命令と \texttt{Cond} 命令の遷移を実装します。
\end{description}

\subsubsection{コンパイラ}

これらの新しい命令を利用して算術式をコンパイルするには、最終的にコンパイラを変更する必要があります。
現時点では、最小限の変更のみを行います。
苦労して追加した算術命令を使用できるようになります。
まず、\texttt{compile}関数は、初期ダンプが空で、初期コード シーケンスがこれまでに使用したものとは異なる新しい初期状態を作成する必要があります。

\begin{verbatim}
  compile :: CoreProgram -> GmState
  compile program
    = (initialCode, [], [], heap, globals, statInitial)
      where (heap, globals) = buildInitialHeap program

  initialCode :: GmCode
  initialCode = [Pushglobal "main", Eval]
\end{verbatim}

\begin{description}
	\item[演習 3.26] 最初の命令シーケンスが変更されたのはなぜですか?
		古いものを保持するとどうなりますか？
\end{description}

コンパイラを拡張する最も簡単な方法は、新しい組み込み関数ごとにGマシン コードを\texttt{compiledPrimitives}に追加することです。
シーケンスの最初の4つの命令により、引数が整数に評価されることが保証されます。

\begin{verbatim}
  compiledPrimitives :: [GmCompiledSC]
  compiledPrimitives
    = [("+", 2, [Push 1, Eval, Push 1, Eval, Add, Update 2, Pop 2, Unwind]),
       ("-", 2, [Push 1, Eval, Push 1, Eval, Sub, Update 2, Pop 2, Unwind]),
       ("*", 2, [Push 1, Eval, Push 1, Eval, Mul, Update 2, Pop 2, Unwind]),
       ("/", 2, [Push 1, Eval, Push 1, Eval, Div, Update 2, Pop 2, Unwind]),
\end{verbatim}

否定関数も追加する必要があります。
これは 1 つの引数しかとらないため、1 つの引数のみを評価します。

\begin{verbatim}
       ("negate", 1, [Push 0, Eval, Neg, Update 1, Pop 1, Unwind]),
\end{verbatim}

比較操作は次のように実装されます。

\begin{verbatim}
       ("==", 2, [Push 1, Eval, Push 1, Eval, Eq, Update 2, Pop 2, Unwind]),
       ("~=", 2, [Push 1, Eval, Push 1, Eval, Ne, Update 2, Pop 2, Unwind]),
       ("<",  2, [Push 1, Eval, Push 1, Eval, Lt, Update 2, Pop 2, Unwind]),
       ("<=", 2, [Push 1, Eval, Push 1, Eval, Le, Update 2, Pop 2, Unwind]),
       (">",  2, [Push 1, Eval, Push 1, Eval, Gt, Update 2, Pop 2, Unwind]),
       (">=", 2, [Push 1, Eval, Push 1, Eval, Ge, Update 2, Pop 2, Unwind]),
\end{verbatim}

\texttt{if} 関数は、分岐に \texttt{Cond} を使用するようにコンパイルされます。

\begin{verbatim}
       ("if", 3, [Push 0, Eval, Cond [Push 1] [Push 2],
                  Update 3, Pop 3, Unwind])]
\end{verbatim}

\begin{description}
	\item[演習 3.27] 新しい命令とコンパイラが機能することを確認するために、Appendix B のどのテストプログラムを使用しますか?
\end{description}
\newpage

\subsection{Mark 5: 算術演算のより良い処理に向けて}

現時点でのGマシンの実装方法では、各演算子はコンパイルされたプリミティブの1つを経由して呼び出されます。
この配置を改善するために、しばしば算術演算子を直接呼び出すことができることを観察することができます。
例えば、次のような簡単なプログラムを考えてみよう。

\begin{verbatim}
  main = 3+4*5
\end{verbatim}

これにより、現在のコンパイラを使用した場合、以下のようなコードが生成されます。

\begin{verbatim}
  [Pushint 5, Pushint 4, Pushglobal "*", Mkap, Mkap,
   Pushint 3, Pushglobal "+", Mkap, Mkap, Eval]
\end{verbatim}

このコードを実行すると、33ステップを要し、11ヒープノードを使用することになります。
最初に思いつくのは、関数 `\texttt{+}' と `\texttt{*}' の呼び出しの代わりに、
\texttt{Add}と\texttt{Mul}という命令を使えばいいのでは、ということでしょう。
これは次のような改善されたコードにつながります。

\begin{verbatim}
  [Pushint 5, Pushint 4, Mul, Pushint 3, Add]
\end{verbatim}

これは、わずか5ステップで実行され、5つのヒープノードを使用します

\subsubsection{問題点}

次の例題のプログラムを考えるとき、考えられる問題が発生します。

\begin{verbatim}
  main = K 1 (1/0)
\end{verbatim}

これにより、以下のようなコードが生成されます。

\begin{verbatim}
  [Pushint 0, Pushint 1, Pushglobal "/", Mkap, Mkap,
   Pushint 1, Pushglobal "K", Mkap, Mkap, Eval]
\end{verbatim}

前の例のパターンでいくと、以下のようなコードを生成してみることができるかもしれません。

\begin{verbatim}
  [Pushint 0, Pushint 1, Div,
   Pushint 1, Pushglobal "K", Mkap, Mkap, Eval]
\end{verbatim}

問題は、\texttt{K}を簡約する\textbf{前に}除算演算子が適用され、その結果、\textbf{ゼロ除算のエラー}が発生することです。
正しいコンパイラは、このようなエラーを出さないようなコードを生成しなければなりません。
\vskip\baselineskip

何が起こったかというと、私たちのコードが厳しすぎるのです。
その結果、評価する必要のない式が評価され、本来は発生しないはずのエラーが発生しています。
同じような問題は、終端でない式が不用意に評価されたときにも起こります。

\subsubsection{解決策}

この問題を解決するには、ある表現が出現する文脈を記録しておくことです。
ここでは、2つのコンテキスト\footnote{より多くのコンテクストを区別することが可能です。
投影法 [Wadler 1987] と評価変換器 [Burn 1991] はこのための2つの方法である。}を区別します。

\begin{description}
	\item[Strict] 式の値はWHNFで要求されます。
	\item[Lazy] 式の値は、WHNFで要求されるかもしれないし、されないかもしれません。
\end{description}

各コンテキストに対応するコンパイルスキームがあり、式 をGマシンの命令列にコンパイルするスキームがあります。
Strictなコンテキストでは、このコンパイルスキームは$\mathcal{E}$スキームであり、
Lazyなコンテキストでは、すでに見た$\mathcal{C}$スキームを使用することになります。
\vskip\baselineskip

できるだけ多くのStrictなコンテキストを見つけたいです。
なぜなら、これらのコンテキストはより良いコードを生成することを可能にするからです。
スーパーコンビネータがインスタンス化されるときは常に、その値をWHNFで評価したいからです。
このことから、スーパーコンビネータの本体は常にStrictなコンテキストで評価することができると結論づけられます。
また、式がWHNFで評価されれば、いくつかの部分式がWHNFで評価されることが分かっている式もあります。
\vskip\baselineskip

Strictなコンテキストの式のクラスは、再帰的に記述することができます。

\begin{itemize}
	\item スーパーコンビネータ定義の本体中の式は、Strictなコンテキストにある。
	\item $e_0 ~ \odot ~ e_1$がStrictなコンテキストで出現し、ここで$\odot$が算術演算子または比較演算子である場合、
	      式$e_0$と$e_1$もStrictなコンテキストにあります。
	\item もし$\texttt{negate} ~ e$がStrictなコンテキストで発生した場合、$e$という式もStrictなコンテキストになる。
	\item $\texttt{if} ~ e_0 ~ e_1 ~ e_2$という式がStrictなコンテキストで出現する場合、$e_0, ~ e_1, ~ e_2$という式もStrictなコンテキストになる。
	\item もし$\texttt{let(rec)} ~ \Delta ~ \texttt{in} ~ e$がStrictなコンテキストで現れたら、式$e$もStrictなコンテキストにあることになります。
\end{itemize}

例として、次のスーパーコンビネータ\texttt{f}の本体を考えてみると、このことがよくわかるでしょう。

\begin{verbatim}
  f x y = (x+y) + g (x*y)
\end{verbatim}

\texttt{(x+y)}と\texttt{g (x*y)}はどちらもStrictなコンテキストで評価されます。
なぜならスーパーコンビネータの本体はStrictなコンテキストで評価されるからです。
最初のケースでは、\texttt{+}がStrictなコンテキストを伝播するので、\texttt{x}と\texttt{y}はStrictなコンテキストで評価されます。
2番目の式では、ユーザー定義のスーパーコンビネータ\texttt{g}が存在するため、部分式\texttt{x*y}は評価されないものとしてコンパイルされる。
\vskip\baselineskip

このことは、Strictコンテキストコンパイラ$\mathcal{E}$を再帰的な方法で実装できることを示唆しています。
各スーパーコンビネータの本体はStrictコンテキストで評価されるので、
$\mathcal{R}$スキームから$\mathcal{E}$スキームの関数を呼び出す必要があります。
これは上記の第一の点を満たしています。
また、コンテキスト情報を部分式に伝達するために、算術式に対して$\mathcal{E}$スキームを再帰的に呼び出します。
\vskip\baselineskip

新しいコンパイラのスキームは図3.12に定義されています。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{R}\llbracket e \rrbracket ~ \rho ~ d$ は、アリティ $d$ のスーパーコンビネータに対して、                                                                          \\
	式$e$を環境$\rho$でインスタンス化し、その結果のスタックを巻き戻すコードを生成します。                                                                                      \\
	\\
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d = \mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ [\texttt{Update} ~ d, ~ \texttt{Pop} ~ d, ~ \texttt{Unwind}]$ \\ \hline
	$\mathcal{E} \llbracket e \rrbracket ~ \rho$は，環境$\rho$において式$e$をWHNFに評価するコードをコンパイルし、                                                              \\
	スタックの先頭に式へのポインタを残します。                                                                                                                                 \\
	\begin{tabular}{r c l}
		$\mathcal{E} \llbracket i \rrbracket ~ \rho$                             & $=$ & $\left[\texttt{Pushint} ~ i \right]$                                                                                                                                                         \\
		\multicolumn{3}{l}{$\mathcal{E} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                                \\
		                                                                         & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+0} ~ \texttt{++}$                                                                                                                            \\
		                                                                         &     & $\ldots$                                                                                                                                                                                     \\
		                                                                         &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho^{+(n - 1)} ~ \texttt{++}$                                                                                                                      \\
		                                                                         &     & $\mathcal{E} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$                                                                                                \\
		                                                                         &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		\multicolumn{3}{l}{$\mathcal{E} \llbracket \texttt{letrec} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                             \\
		                                                                         & $=$ & $\left[\texttt{Alloc} ~ n\right] ~ \texttt{++}$                                                                                                                                              \\
		                                                                         &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ n - 1\right] ~ \texttt{++}$                                                                           \\
		                                                                         &     & $\ldots$                                                                                                                                                                                     \\
		                                                                         &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ 0\right] ~ \texttt{++}$                                                                               \\
		                                                                         &     & $\mathcal{E} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$                                                                                                \\
		                                                                         &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		$\mathcal{E} \llbracket e_0 ~ \texttt{+} ~ e_1 \rrbracket ~ \rho$        & $=$ & $\mathcal{E} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \mathcal{E} \llbracket e_0 \rrbracket ~ \rho^{+1} ~ \texttt{++} ~ \left[\texttt{Add} \right]$                                  \\
		                                                                         &     & 他の算術式や比較式についても同様。                                                                                                                                                           \\
		$\mathcal{E} \llbracket \texttt{negate} ~ e \rrbracket ~ \rho$           & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Neg} \right]$                                                                                                      \\
		$\mathcal{E} \llbracket \texttt{if} ~ e_0 ~ e_1 ~ e_2 \rrbracket ~ \rho$ & $=$ & $\mathcal{E} \llbracket e_0 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Cond} ~ (\mathcal{E} \llbracket e_1 \rrbracket ~ \rho) ~ (\mathcal{E} \llbracket e_2 \rrbracket ~ \rho) \right]$ \\
		$\mathcal{E} \llbracket e \rrbracket ~ \rho$                             & $=$ & $\mathcal{C} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Eval} \right]$                                                                                                     \\
		                                                                         &     & デフォルトケース                                                                                                                                                                             \\ \hline
	\end{tabular}
\end{tabular}
\vskip\baselineskip

新しいスキームを使ってコンパイルできる組み込み演算子のセットを簡単に拡張できるように、\texttt{builtInDyadic}を採用しました。

\begin{verbatim}
  builtInDyadic :: ASSOC Name Instruction
  builtInDyadic
    = [("+", Add), ("-", Sub), ("*", Mul), ("div", Div),
       ("==", Eq), ("~=", Ne), (">=", Ge),
       (">", Gt), ("<=", Le), ("<", Lt)]
\end{verbatim}

\begin{description}
	\item[演習 3.28] 既存のコンパイラ関数\texttt{compileR}と\texttt{compileE}を、
		図 3.12 の$\mathcal{R}$スキームと$\mathcal{E}$スキームを実装するように修正します。
		\texttt{builtInDyadic}を使用する必要があります。
\end{description}

時折、新しいコンパイラを使うとマシンが失敗することがあります。
必要なのは、\texttt{Unwind}命令に対して新しいルールを導入することです。
\vskip\baselineskip

\begin{tabular} {|c|l r r r l l|} \hline
	(3.29) &                   & [\texttt{Unwind}] & [$a_0, ~ \ldots, ~ a_k$] & $\langle i, ~ s \rangle$ : $d$ & $h$[$a_0$ : \texttt{NGlobal} $n$ $c$] & $m$                 \\
	       & $\Longrightarrow$ & $i$               & $a_k$ : $s$              & $d$                            & $h$                                   & $m$ ($k < n$のとき) \\ \hline
\end{tabular}
\vskip\baselineskip

これにより、\texttt{Eval}を使って数値だけでなく、あらゆるオブジェクトをWHNFに評価することができるようになりました。

\begin{description}
	\item[演習 3.29] \texttt{Unwind}の新しい遷移規則を実装してください。
		新しい\texttt{Unwind}の遷移規則がないと失敗するプログラムを書いてください。
	\item[演習 3.30] 冒頭で使用したサンプルプログラムの実行を、Mark4マシンでの実行と比較してみてください。
		\begin{verbatim}
    main = 3+4*5
  \end{verbatim}
		Appendix Bの他のプログラムも試してみてください。
\end{description}

Strictなコンテキストをコンパイラに実装する方法は、コンパイラの理論から継承される属性の簡単な例である。
Strictコンテキストを式の属性と見なすと、部分式はその親となる式からStrictコンテキストを継承する。
一般的な理論は [Aho et al. 1986] で述べられている。
\vskip\baselineskip

残念ながら、ある式をStrictなコンテキストでコンパイルすべきかどうかをコンパイル時に判断することは、一般的には不可能です。
したがって、妥協点を受け入れるしかありません。
本書では、限られた式の集合である算術式だけを特別な方法で扱いました。
この解析をより一般的な式に拡張する研究が盛んに行われています [Burn 1991]。
\newpage

\subsection{Mark 6: データ構造の追加}

本節では、Gマシンを拡張して、任意のデータ構造を扱えるようにします。
第1章で述べたように、データ構造を含むプログラムには、\textbf{コンストラクタ}\texttt{EConstr}と、
\textbf{case式}\texttt{ECase}という2つの新しいコア言語コンストラクタが必要です。
Mark6マシンの目標は、これらの式に対応したコードをコンパイルすることです。

\subsubsection{概要}

\ref{sec_1_1_4}節で、タグ\texttt{t}とアリティ\texttt{a}を持つコンストラクタはコア言語では\texttt{Pack\{t, a\}}と表現されることを見ました。
例えば、通常のリストデータ型は2つのコンストラクタを持っています。\texttt{Pack\{1, 0\}}と\texttt{Pack\{2, 2\}}です。
これらはそれぞれMirandaの[]と(:)に相当します。
\vskip\baselineskip

Mirandaでは直接対応するものがない\texttt{case}式は、コンストラクタに保持される値を検査するために使用されます。
例えば、リストの長さを求める関数を次のように書きます。

\begin{verbatim}
  length xs = case xs of
                     <1>      -> 0;
                     <2> y ys -> 1 + length ys
\end{verbatim}

\texttt{case}式の実行の仕方を見てみると、参考になることがあります。

\begin{enumerate}
	\item \texttt{case}式を評価するために、まず\texttt{xs}をWHNFに評価します。
	\item この評価が行われると、どの選択肢を取るべきかがわかるようになります。
	      評価された式のタグ（構造化データ・オブジェクトでなければなりません）が、どの選択肢を取るかを決定します。
	      上の例では、長さについて
	      \begin{itemize}
		      \item \texttt{xs}のコンストラクタのタグが\texttt{1}の場合、リストは空であり、最初の選択肢を取ります。
		            従って、\texttt{0}を返します。
		      \item タグが\texttt{2}であれば、リストは空でないことになります。
		            今回はコンストラクタのコンポーネント（\texttt{y}と\texttt{ys}）があります。
		            リストの長さは\texttt{ys}の長さより1つ多くなります。
	      \end{itemize}
\end{enumerate}

ここでは、コンストラクタを解体しようとするときはいつでも、正しい数の引数に適用されていると仮定します。
このような状態のコンストラクタは\textbf{充足状態}であるといいます。
例として、セクション\ref{sec_1_1_3}で\texttt{Cons}は2つの引数を取るように定義されているので、2つの式に適用されると充足状態になります。
\vskip\baselineskip

また、コア言語プログラムは、構造化データオブジェクトである結果を返すことができるようになったことにも注目します。
Mark5 Gマシンは、構造化データオブジェクトを遅延評価スタイルで表示できるようにしなければなりません。
まず、Mark5マシンのデータ構造にどのような追加をする必要があるかを考えてみましょう。

\subsubsection{データ構造}

マシンが単なる数値ではない値を返すことができればいいのです。
コンストラクタからなる値を返せるようにしたいのです。
そのためには、構造体の構成要素を再帰的に評価し、その値を返す必要があります。
そのためには、さらに別のコンポーネント、\texttt{gmOutput}を状態に追加する必要があります。
これは、プログラムの結果を保持するためのものです。

\begin{verbatim}
  type GmState =
    (GmOutput,  -- Current Output
     GmCode,    -- Current Instruction Stream
     GmStack,   -- Current Stack
     GmDump,    -- The Dump
     GmHeap,    -- Heap of Nodes
     GmGlobals, -- Global addresses in Heap
     GmStats)   -- Statistics
\end{verbatim}

このコンポーネントは、文字列として定義されます。

\begin{verbatim}
  type GmOutput = [Char]
\end{verbatim}

アクセス関数は、当たり前のように書けばいいのです。

\begin{verbatim}
  getOutput :: GmState -> GmOutput
  getOutput (o, i, stack, dump, heap, globals, stats) = o

  putOutput :: GmOutput -> GmState -> GmState
  putOutput o' (o, i, stack, dump, heap, globals, stats)
    = (o', i, stack, dump, heap, globals, stats)
\end{verbatim}

\begin{description}
	\item[演習 3.31] 残りのアクセス機能を適切に変更します。
\end{description}

ヒープ内のコンストラクタノードをサポートするために、\texttt{node}型を\texttt{NConstr}で拡張します。
これは、タグを表す正の数と、コンポーネントのリストを取ります。
コンポーネントのリストはヒープ内のノードのアドレスのリストとして表されます。

\begin{verbatim}
  data Node
    = NNum Int -- Numbers
    | NAp Addr Addr -- Applications
    | NGlobal Int GmCode -- Globals
    | NInd Addr
    | NConstr Int [Addr]
  instance Eq Node
    where
      NNum a      == NNum b      = a == b -- needed to check conditions
      NAp a b     == NAp cd      = False  -- not needed
      NGlobal a b == NGlobal c d = False  -- not needed
      NInd a      == NInd b      = False  -- not needed
      NConstr a b == NConstr c d = False  -- not needed
\end{verbatim}

\subsubsection{結果の表示}

表示したい新しい状態コンポーネントがあるため、関数\texttt{showState}を再定義する必要があります。

\begin{verbatim}
  showState :: GmState -> Iseq
  showState s
    = iConcat [showOutput s,                 iNewline,
               showStack s,                  iNewline,
               showDump s,                   iNewline,
               showInstructions (getCode s), iNewline]
\end{verbatim}

出力コンポーネントはすでに文字列であるため、\texttt{showOutput}関数は簡単です。

\begin{verbatim}
  showOutput :: GmState -> Iseq
  showOutput s = iConcat [iStr "Output:\"", iStr (getOutput s), iStr "\""]
\end{verbatim}

他の唯一の変更(新しい命令セットの\texttt{showInstruction}の変更を除く)は、
コンストラクタノードを含めるようにデータ型を拡張したため、\texttt{showNode}で発生します。

\begin{verbatim}
  showNode :: GmState -> Addr -> Node -> Iseq
  showNode s a (NNum n)      = iNum n
  showNode s a (NGlobal n g) = iConcat [iStr "Global ", iStr v]
                                 where v = head [n | (n,b) <- getGlobals s, a==b]
  showNode s a (NAp a1 a2)   = iConcat [iStr "Ap ", iStr (showaddr a1),
                                        iStr " ", iStr (showaddr a2)]
  showNode s a (NInd a1)     = iConcat [iStr "Ind ", iStr (showaddr a1)]
  showNode s a (NConstr t as)
    = iConcat [iStr "Cons ", iNum t, iStr " [",
               iInterleave (iStr ", ") (map (iStr.showaddr) as), iStr "]"]
\end{verbatim}

\subsubsection{命令セット}

新しい命令セットが定義されました。
Mark4マシンに4つの新しい命令を追加するだけです。

\begin{verbatim}
  data Instruction
    = Slide Int
    | Alloc Int
    | Update Int
    | Pop Int
    | Unwind
    | Pushglobal Name
    | Pushint Int
    | Push Int
    | Mkap
    | Eval
    | Add | Sub | Mul | Div
    | Neg
    | Eq | Ne | Lt | Le | Gt | Ge
    | Cond GmCode GmCode
\end{verbatim}

マシンに追加された4つの新しい命令は次のとおりです。

\begin{verbatim}
    | Pack Int Int
    | Casejump [(Int, GmCode)]
    | Split Int
    | Print
\end{verbatim}

\begin{description}
	\item[演習 3.32] 新しい命令セットに一致するように\texttt{showInstruction}を拡張します。
\end{description}

\texttt{Pack}命令は単純です。 \textbf{充足したコンストラクタ}を構築するのに十分な引数がスタックにあると想定しています。
存在する場合は、充足したコンストラクタの作成に進みます。 十分な引数がない場合、命令は未定義です。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.30) &                   & $o$ & $\texttt{Pack} ~ t ~ n$ : $i$ & $a_1$ : $\ldots$ : $a_n$ : $s$ & $d$ & $h$                                                  & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                           & $a$ : $s$                      & $d$ & $h$[$a$ : \texttt{NConstr} $t$ [$a_1, \ldots, a_n$]] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Casejump}の遷移ルールは、
\begin{description}
	\item[(a)] スタックの一番上のノードがWHNFにあること
	\item[(b)] ノードが構造化データ オブジェクトであること
\end{description}
を想定しています。
このオブジェクトのタグを使用して、選択肢の命令シーケンスの1つを選択すると、現在の命令ストリームの前に、選択された特定の選択肢のコードが追加されます。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.31) &                   & $o$ & $\texttt{Casejump} ~ [\ldots, t \texttt{->} i', \ldots]$ : $i$ & $a$ : $s$ & $d$ & $h$[$a$ : \texttt{NConstr} $t$ $ss$] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i'$ \texttt{++} $i$                                           & $a$ : $s$ & $d$ & $h$                                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

これは、多方向へのジャンプと結合を指定する簡単な方法です。
つまり、選択肢コード$i'$のコードによって現在のコード$i$を事前に修正することで、最初に選択肢のコードを実行し、
次に主な式の残りのコードが必要とするもので再開するという効果を達成します。
\footnote{\texttt{Casejump}を使用したコードシーケンスはフラットではないことに注意してください。
	ただし、各選択肢にラベルを付けて、ラベル付けされたコードアドレスにジャンプすることにより、必要なフラットコードシーケンスを構築できます。
	コード生成が不必要に複雑になるため、これは行っていません。}
\vskip\baselineskip

各選択肢のコードは、\texttt{Split} $n$命令で始まり、\texttt{Slide} $n$命令で終了します。
$n$の値は、コンストラクタ内のコンポーネントの数によって決まります。
\texttt{Split}命令は、コンストラクタのコンポーネントにアクセスするために使用されます。
\vskip\baselineskip

\texttt{length}関数用に生成されたコードシーケンスを考えてみましょう。

\begin{verbatim}
  [Push 0, Eval,
   Casejump [1 -> [Pushint 0]
             2 -> [Split 2, Push 1, Pushglobal "length", Mkap,
                   Eval, Pushint 1, Add, Slide 2]],
   Update 1,
   Pop 1,
   Unwind]
\end{verbatim}

このパターンの実行を図3.13に示します。
ここでは、現在のローカルバインディングのセットを拡張するために、\texttt{Slide}および\texttt{Split}命令が一時的に使用されていることがわかります。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-13.png}

\texttt{length}関数がnil以外のノードに適用されたと仮定すると、\texttt{Casejump}命令を実行するときに、\texttt{2}というラベルの付いた選択肢が取られます。
これが最初の図(a)です。

\texttt{Split 2}命令は、コンストラクタノードをスタックに「unpack」します。これを図(b)に示します。

選択肢の本体、つまりコードシーケンス
\begin{verbatim}
  [Push 1, Pushglobal "length", Mkap, Eval, Pushint 1, Add]
\end{verbatim}
を完成させた後、この\texttt{length}の呼び出しに対するリスト引数の長さがスタックの一番上になります。図(c)で\texttt{l}とラベル付けされています。

実行を完了するには、\texttt{head}と\texttt{tail}へのポインタを削除します。これを図(d)に示します。

\texttt{Split}の遷移規則は簡単です。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.32) &                   & $o$ & $\texttt{Split} ~ n$ : $i$ & $a$ : $s$                      & $d$ & $h$[$a$ : \texttt{NConstr} $t$ $[a_1, \ldots, a_n]$] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                        & $a_1$ : $\ldots$ : $a_n$ : $s$ & $d$ & $h$                                                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

次に、\texttt{Print}の遷移規則について説明します。
\texttt{Print}には2つの遷移規則があります。コンストラクタと数値にそれぞれ1つずつです。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.33) &                   & $o$                   & \texttt{Print} : $i$ & $a$ : $s$ & $d$ & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\
	       & $\Longrightarrow$ & $o$ \texttt{++} [$n$] & $i$                  & $s$       & $d$ & $h$                          & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

コンストラクタのルールは、コンストラクタの各コンポーネントをプリントするように調整する必要があるため、より複雑です。
簡単にするために、コンポーネントのみをプリントします。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.34) &                   & $o$ & \texttt{Print} : $i$ & $a$ : $s$                      & $d$ & $h$[$a$ : \texttt{NConstr} $t$ [$a_1, \ldots, a_n$]] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i'$ \texttt{++} $i$ & $a_1$ : $\ldots$ : $a_n$ : $s$ & $d$ & $h$                                                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

コード$i'$は次のとおりです。

\[
	\underbrace{[\texttt{Eval}, \texttt{Print}, \ldots, \texttt{Eval}, \texttt{Print}]}_{n}
\]

最後に、\texttt{Unwind}の新しいルールを追加する必要があります。
これは、\texttt{NNum}のルールと同様に、\texttt{NConstr}を巻き戻すときに戻るように指示します。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.35) &                   & $o$ & [\texttt{Unwind}] & $a$ : $s$  & $\langle i', ~ s' \rangle$ : $d$ & $h$[$a$ : \texttt{NConstr} $n$ $as$] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i'$              & $a$ : $s'$ & $d$                              & $h$                                  & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 3.33] 新しい遷移規則を実装し、\texttt{dispatch}関数を変更します。
\end{description}

\subsubsection{コンパイラ}

図3.14では、$\mathcal{E}$および$\mathcal{C}$コンパイルスキームの新しいケースが示されています。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{E} \llbracket e \rrbracket ~ \rho$は、式$e$を環境$\rho$のWHNFに評価するコードをコンパイルし、 \\
	式へのポインタをスタックの一番上に残します。                                                            \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{E} \llbracket \texttt{case} ~ e ~ \texttt{of} ~ alts \rrbracket ~ \rho$                          & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Casejump} ~ \mathcal{D} \llbracket alts \rrbracket ~ \rho \right]$                                                         \\
		$\mathcal{E} \llbracket \texttt{Pack\{} t \texttt{,} a \texttt{\}} ~ e_1 ~ \ldots ~ e_a \rrbracket ~ \rho$ & $=$ & $\mathcal{C} \llbracket e_a \rrbracket ~ \rho^{+0} ~ \texttt{++} ~ \cdots ~ \texttt{++} ~ \mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+(a-1)} ~ \texttt{++} ~ \left[\texttt{Pack} ~ t ~ a \right]$ \\
	\end{tabular}
	\\ \hline
	$\mathcal{C} \llbracket e \rrbracket ~ \rho$は、環境$\rho$で$e$のグラフを構築するコードを生成し、       \\
	それへのポインタをスタックの一番上に残します。                                                          \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{C} \llbracket \texttt{Pack\{} t \texttt{,} a \texttt{\}} ~ e_1 ~ \ldots ~ e_a \rrbracket ~ \rho$ & $=$ & $\mathcal{C} \llbracket e_a \rrbracket ~ \rho^{+0} ~ \texttt{++} ~ \cdots ~ \texttt{++} ~ \mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+(a-1)} ~ \texttt{++} ~ \left[\texttt{Pack} ~ t ~ a \right]$ \\
	\end{tabular}
	\\ \hline
	$\mathcal{D} \llbracket alts \rrbracket ~ \rho$は、\texttt{case}式の選択肢のリストをコンパイルします。  \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{D} \llbracket alt_1 ~ \ldots ~ alt_n \rrbracket ~ \rho$ & $=$ & $\left[\mathcal{A} \llbracket alt_1 \rrbracket ~ \rho ~ , \ldots , \mathcal{A} \llbracket alt_n \rrbracket ~ \rho \right]$ \\
	\end{tabular}
	\\ \hline
	$\mathcal{A} \llbracket alt \rrbracket ~ \rho$は、\texttt{case}式の各選択肢のコードをコンパイルします。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{A} \llbracket \texttt{<} t \texttt{>} ~ x_1 ~ \ldots ~ x_n ~ \texttt{->} ~ body \rrbracket ~ \rho$ & $=$ & $t ~ \texttt{->} ~ \left[\texttt{Split} ~ n \right] ~ \texttt{++} ~ \mathcal{E} \llbracket body \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n \right]$ \\
		                                                                                                             &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ 0, ~ \ldots , ~ x_n ~ \mapsto ~ n - 1\right]$ です。                                                                 \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{case}式で選択される可能性のある選択肢を処理するために、補助的なコンパイルスキーム$\mathcal{D}$および$\mathcal{A}$が必要です。
関数\texttt{compileAlts}($\mathcal{D}$スキームに対応) は、現在の環境を使用して選択肢のリストをコンパイルし、タグ付きコードシーケンスのリストを生成します。
また、comp引数($\mathcal{A}$に対応)を使用して、各選択肢の本体をコンパイルします。
現時点では、この引数は常に\texttt{compileE'}になります。

\begin{verbatim}
  compileAlts :: (Int -> GmCompiler) -- compiler for alternative bodies
                 -> [CoreAlt]        -- the list of alternatives
                 -> GmEnvironment    -- the current environment
                 -> [(Int, GmCode)]  -- list of alternative code sequences
  compileAlts comp alts env
    = [(tag, comp
               (length names)
               body
               (zip names [0..] ++ argOffset (length names) env))
      | (tag, names, body) <- alts]
\end{verbatim}

\texttt{compileE'}スキームは、\texttt{compileE}スキームを少し変更したものです。
通常の\texttt{compileE}スキームによって生成されたコードの周りに\texttt{Split}と\texttt{Slide}を配置するだけです。

\begin{verbatim}
  compileE' :: Int -> GmCompiler
  compileE' offset expr env
    = [Split offset] ++ compileE expr env ++ [Slide offset]
\end{verbatim}

\begin{description}
	\item[演習 3.34] 関連する変更を\texttt{compile}に加え、\texttt{initialCode}を変更して最後に\texttt{Print}命令を追加します。
	\item[演習 3.35] 新しいケースをコンパイラ関数\texttt{compileE}および\texttt{compileC}に追加します。
	\item[演習 3.36] 出力を「構造化された形式」で出力するには、どのような変更が必要ですか。
		これは、整数だけでなく、コンストラクタと括弧を出力コンポーネント\texttt{gmOutput}に配置することを意味します。
\end{description}

\subsubsection{比較における新しい論理表現の使用}

このセクションでは、構築したMark6マシンを変更して、ブール値の新しい表現を使用する方法を示します。
最初に、ブール値を構造化データオブジェクトとして実装できることを確認します。
\texttt{True}と\texttt{False}は、アリティがゼロでタグが2と1のコンストラクタとして表されます。
\vskip\baselineskip

条件式をどのように実装しますか?
これは、\texttt{if}のプログラムに新しい定義を追加することで実行できます。
最初の引数に応じて、2番目または3番目の引数のいずれかを返します。

\begin{verbatim}
  if c t f = case c of
                  <1> -> f;
                  <2> -> t
\end{verbatim}

必要な最初の変更は、比較操作にあります。
これらには、次の一般的な遷移規則があります。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.36) &                   & $o$ & $\odot$ : $i$ & $a_0$ : $a_1$ : $s$ & $d$ & $h$[$a_0$ : \texttt{NNum} $n_0$, ~ $a_1$ : \texttt{NNum} $n_1$] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$           & $a$ : $s$           & $d$ & $h$[$a$ : \texttt{Constr} ($n_0 ~ \odot ~ n_1$) ~ []]           & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

たとえば、\texttt{Eq}命令では、2つの数値$n_0$と$n_1$が同じ場合は\texttt{2}(\texttt{True}のタグ)を返し、
そうでない場合は\texttt{1}(\texttt{False}のタグ)を返す関数に置き換えます。
\vskip\baselineskip

Mark4マシン用に開発したコードの一部を再利用することで、遷移規則をすばやく実装できます。
セクション\ref{sec_3_6_3}では、一般的な算術演算子と比較演算子を表す方法を見てきました。
実際、比較関数の定義を構築した方法により、ブール値の新しい表現をほとんどすぐに使用できます。
\vskip\baselineskip

ボックス化関数\texttt{boxBoolean}は、比較演算と、スタックの一番上に2つの整数がある状態を取ります。
スタックの一番上にある 2 つの整数を比較したブール値の結果がある新しい状態を返します。

\begin{verbatim}
  boxBoolean :: Bool -> GmState -> GmState
  boxBoolean b state
    = putStack (a: getStack state) (putHeap h' state)
      where (h',a) = hAlloc (getHeap state) (NConstr b' [])
            b' | b = 2         -- 2 is tag of True
               | otherwise = 1 -- 1 is tag of False
\end{verbatim}

\begin{description}
	\item[演習 3.37] Appendix Bのサンプルプログラムをいくつか実行します。たとえば、階乗プログラムを試してください。
		\begin{verbatim}
    fac n = if (n==0) 1 (n * fac (n-1))
  \end{verbatim}
\end{description}

\subsubsection{使用可能な言語の拡大}

賢明な読者はお気づきかもしれませんが、コンパイラが失敗する\texttt{ECase}と\texttt{EConstr}に関するいくつかの正当な表現があります。
コンパイルできない合法的な表現は、次の2つのクラスに分類されます。

\begin{enumerate}
	\item Strictでないコンテキスト(つまり、$\mathcal{C}$スキームによってコンパイルされた式)での\texttt{ECase}の出現。
	\item 適用される引数が少なすぎる式での\texttt{EConstr}の出現。
\end{enumerate}

どちらの問題も、プログラム変換手法を使用して解決できます。
\texttt{ECase}の解決策は、問題のある式をスーパーコンビネータにして、自由変数に適用することです。
たとえば、次のプログラム

\begin{verbatim}
  f x = Pack{2,2} (case x of <1> -> 1; <2> -> 2) Pack{1,0}
\end{verbatim}

は以下の同等のプログラムに変換できます。

\begin{verbatim}
  f x = Pack{2,2} (g x) Pack{1,0}
  g x = case x of <1> -> 1; <2> -> 2
\end{verbatim}

\texttt{EConstr}の解決策は、コンストラクタごとにスーパーコンビネータを作成することです。
これは、コンストラクタを充足させるのに十分な自由変数で生成されます。
ここに例があります。

\begin{verbatim}
  prefix p xs = map (Pack{2,2} p) xs
\end{verbatim}

これは次のように変換されます。

\begin{verbatim}
  prefix p xs = map (f p) xs
  f p x = Pack{2,2} p x
\end{verbatim}

この問題を解決する別の方法は、\texttt{Pushglobal}命令を変更して、
「\texttt{Pack\{t,a\}}」という形式の名前を持つ関数に対して機能するようにすることです。
そうすれば、上記の例の\texttt{f}のようなコンストラクタ関数を、状態のグローバルコンポーネントから探すだけでよいのです。
関数がまだ存在しない場合は、その関数に関連付ける新しいグローバルノードを作成することができます。
このノードは特に単純な構造持っているからです。

\begin{verbatim}
  NGlobal a [Pack t a, Update 0, Unwind]
\end{verbatim}

新しい遷移規則は、最初に、関数が既に存在する場合:
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.37) &                   & $o$ & $\texttt{Pushglobal Pack\{} t \texttt{,} n \texttt{\}}$ : $i$ & $s$       & $d$ & $h$ & $m$[$\texttt{Pack\{} t \texttt{,} n \texttt{\}}$ : $a$] \\
	       & $\Longrightarrow$ & $o$ & $i$                                                           & $a$ : $s$ & $d$ & $h$ & $m$                                                     \\ \hline
\end{tabular}
\vskip\baselineskip

第二に、それがまだ存在しない場合:
\vskip\baselineskip

\begin{tabular} {|c|l l r r r l l|} \hline
	(3.38) &                   & $o$ & $\texttt{Pushglobal Pack\{} t \texttt{,} n \texttt{\}}$ : $i$ & $s$       & $d$ & $h$                               & $m$                                                     \\
	       & $\Longrightarrow$ & $o$ & $i$                                                           & $a$ : $s$ & $d$ & $h$[$a$ : $\texttt{gNode}_{t,n}$] & $m$[$\texttt{Pack\{} t \texttt{,} n \texttt{\}}$ : $a$] \\ \hline
\end{tabular}
\vskip\baselineskip

ここで$\texttt{gNode}_{t,n}$は以下の通りです。

\[
	\texttt{NGlobal} ~ n ~ [\texttt{Pack} ~ t ~ n, ~ \texttt{Update} ~ 0, ~ \texttt{Unwind}]
\]

その後、コンパイラは、未充足のコンストラクタノードを含む式のコードを直接生成できます。
これは、不充足コンストラクタに対して次のコードを生成することによって行われます。

\[
	\mathcal{C} \llbracket \texttt{Pack\{} t \texttt{,} a \texttt{\}} \rrbracket ~ \rho = \left[\texttt{Pushglobal "Pack\{} t \texttt{,} a \texttt{\}"} \right]
\]

\begin{description}
	\item[演習 3.38] \texttt{Pushglobal}命令の\texttt{pushglobal}関数に拡張機能を実装し、コンパイラを変更します。
\end{description}
\newpage

\subsection{Mark 7: さらなる改善}

Mark 5コンパイラの開発時に見たサンプルプログラムをもう一度考えてみましょう。

\begin{verbatim}
  main = 3+4*5
\end{verbatim}

これにより、Mark 6コンパイラを使用した場合、以下のようなコードが生成されます。

\begin{verbatim}
  [Pushint 5, Pushint 4, Mul, Pushint 3, Add]
\end{verbatim}

このコードを実行すると、ヒープノードが1つ使用されます。
これをさらに減らすことは可能でしょうか？
\vskip\baselineskip

答えはイエスです。
演算の中間値を表す数値のスタックを使用することで、演算のためのヒープアクセス数をさらに減らすことができるのです。
Mark 7マシンでは、これらの値はVスタックと呼ばれる新しいステートコンポーネントに保持されます。
問題は、実機では数値をヒープに入れたり取り出したりするのは高くつく操作であることです。
マシンのレジスタセットやスタックを利用する方がはるかに効率的です。
Mark 7 Gマシンではスタックを使うので、レジスタが足りなくなる心配はありません。
\vskip\baselineskip

プログラム

\begin{verbatim}
  main = 3+4*5
\end{verbatim}

の新しいコードは、前回生成したコードと非常によく似ています。

\begin{verbatim}
  [Pushbasic 5, Pushbasic 4, Mul, Pushbasic 3, Add, Mkint]
\end{verbatim}

最初の命令\texttt{Pushbasic 5}は、\texttt{5}をVスタックの一番上に置きます。
次に\texttt{4}をVスタックにプッシュし、その後に乗算を行います。
この命令は、その引数がVスタックにあることを想定しています。
これは、同様にVスタックに答えを配置します。
次の2つの命令は、Vスタックの一番上にある値に\texttt{3}を足します。
最後の命令\texttt{Mkint}は、Vスタックの一番上の値を取って、ヒープ内の数値ノードに入れ、この新しいノードへのポインタをSスタックの一番上に残します。

\subsubsection{Vスタックによる階乗関数の実行}

まず、Mark7マシンを例にとって調べてみます。
ここでは、次のように定義された階乗関数の実行を見ることにします。

\begin{verbatim}
  fac n = if (n==0) 1 (n * fac (n-1))
\end{verbatim}

Mark 7コンパイラを使って、スーパーコンビネータ本体に以下のようなコード列を生成します。

\begin{verbatim}
  [Pushbasic 0, Push 0, Eval, Get, Eq,
   Cond [Pushint 1, Update 1, Pop 1, Unwind]
        [Pushint 1, Push 1, Pushglobal "-", Mkap, Mkap, Pushglobal "fac", Mkap,
         Eval, Get, Push 0, Eval, Get, Mul, Mkint, Update 1, Pop 1, Unwind]
\end{verbatim}

このコードが実行されるとき、V スタックは空であり、通常のスタックには 1 つのアイテムがあります。
この2種類のスタックを区別するために、以後後者をSスタックと呼ぶことにします。
\vskip\baselineskip

\includegraphics*[scale=0.6]{Fig_3-15.png}

図3.15の(a)図から、Sスタックの上に\texttt{fac}の引数へのポインタがある初期状態を見ることができます。
図(b)では、\texttt{Pushbasic}命令が実行されたときに、整数がVスタックにプッシュされる様子を示しています。
図(c)では、\texttt{fac}への引数が評価され、図(d)では、\texttt{Get}命令の効果が示されています。
ヒープ内のノードから値を取り出し、Vスタックに格納したものです。
\vskip\baselineskip

\includegraphics*[scale=0.6]{Fig_3-16.png}

図(e)(図3.16)は、\texttt{Eq}命令が実行された後の状態を示しています。
Vスタックの2つの項目を比較した結果、両者が等しくないことを発見しました。
Mark 7 G-machineは、Vスタックのブール値\texttt{False}を\texttt{1}として表現しています。
図(f)では、\texttt{Cond}命令がこの値を検査し、どの分岐を実行するかを選択しています。
\vskip\baselineskip

\includegraphics*[scale=0.5]{Fig_3-17.png}

図(g)（図 3.17）は \texttt{fac (1-1)} を構築し評価した後の状態です．
次の命令は、新しく評価された値をVスタックにフェッチする\texttt{Get}です。
図(i)では、ノード1から評価し、Vスタックに値をフェッチしていることがわかります。
図(j)では、\texttt{Mul}命令によってVスタック内の2つの値が乗算され、その結果がスタックに戻されています。
図(k)では、\texttt{Mkint}命令により、この結果をVスタックからヒープに移動し、Sスタックに新しく生成されたノードのアドレスを記録しています。
\vskip\baselineskip

ヒープにオブジェクトを作成しアクセスすることが、スタックにオブジェクトを保持することと比較して性能上のペナルティがあるマシンでは、
V-stackの使用は改善されると期待されます。
Vスタックがどのように機能するかを見た後、Mark 7マシンを実装するためにGマシンに小さな修正を加えます。

\subsubsection{データ構造}

Vスタックを使用することで、Gマシンの各状態には、新しい状態コンポーネント\texttt{gmVStack}がその状態に追加されます。

\begin{verbatim}
  type GmState = (GmOutput,  -- Current output
                  GmCode,    -- Current instruction stream
                  GmStak,    -- Current stack
                  GmDump,    -- Current dump
                  GmVStack,  -- Current V-stack
                  GmHeap,    -- Heap of nodes
                  GmGlobals, -- Global addresses in heap
                  GmStats)   -- Statistics
\end{verbatim}

すでに述べたように、この新しいコンポーネントは数のスタックとして動作します。

\begin{verbatim}
  type GmVStack = [Int]
\end{verbatim}

このコンポーネントのアクセス関数を追加します。

\begin{verbatim}
  getVStack :: GmState -> GmVStack
  getVStack (o, i, stack, dump, vstack, heap, globals, stats) = vstack

  putVStack :: GmVStack -> GmState -> GmState
  putVStack vstack' (o, i, stack, dump, vstack, heap, globals, stats)
    = (o, i, stack, dump, vstack', heap, globals, stats)
\end{verbatim}

\begin{description}
	\item[演習 3.39] その他のアクセス関数を変更します。
\end{description}

\textbf{状態を表示する}
\vskip\baselineskip

関数\texttt{showState}は、V-stackコンポーネントを表示するように変更されています。

\begin{verbatim}
  showState :: GmState -> Iseq
  showState s
    = iConcat [showOutput s, iNewline,
               showStack s, iNewline,
               showDump s, iNewline,
               showVStack s, iNewline,
               showInstructions (getCode s), iNewline]
\end{verbatim}

そのために、関数\texttt{showVStack}を使用します。

\begin{verbatim}
  showVStack :: GmState -> Iseq
  showVStack s
    = iConcat [iStr "Vstack:[",
               iInterleave (iStr ", ") (map iNum (getVStack s)),
               iStr "]"]
\end{verbatim}

\subsubsection{命令セット}

最初の要件は、各算術演算の遷移が、通常のスタックの代わりに、Vスタックから値を取得し、
その結果を返すように修正されなければならないことであることは明らかです。
まず、ダイアディックプリミティブの場合を考えてみましょう。
この操作$\odot$の一般的な遷移は以下の通りです。
これはV-stackから2つの引数を取り、演算$\odot$の結果をV-stackに戻します。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.39) &                   & $o$ & $\odot$ : $i$ & $s$ & $d$ & $n_0$ : $n_1$ : $v$   & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$           & $s$ & $d$ & $n_0 \odot n_1$ : $v$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Neg}命令は、Vスタックの先頭の数をその-1倍に置き換えるだけで、次のように遷移します。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.40) &                   & $o$ & \texttt{Neg} : $i$ & $s$ & $d$ & $n$ : $v$    & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                & $s$ & $d$ & $(-n)$ : $v$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

また、ヒープとVスタック間で値を移動させる命令も必要です。
まず、整数$n$をVスタックにプッシュする\texttt{Pushbasic}から始めます。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.41) &                   & $o$ & \texttt{Pushbasic} $n$ : $i$ & $s$ & $d$ & $v$       & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                          & $s$ & $d$ & $n$ : $v$ & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

Vスタックからヒープに値を移動するには、2つの命令を使用します。\texttt{Mkbool}と\texttt{Mkint}です。
これらは、Vスタックの上にある整数をそれぞれブール値と整数値として扱います。
まず、\texttt{Mkbool}から。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.42) &                   & $o$ & \texttt{Mkbool} : $i$ & $s$       & $d$ & $t$ : $v$ & $h$                                & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                   & $a$ : $s$ & $d$ & $v$       & $h$[$a$ : \texttt{NConstr} $t$ []] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Mkint}の遷移規則は、ヒープに新しい整数ノードを作成することを除けば、\texttt{Mkbool}に似ています。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.43) &                   & $o$ & \texttt{Mkint} : $i$ & $s$       & $d$ & $n$ : $v$ & $h$                          & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                  & $a$ : $s$ & $d$ & $v$       & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

逆演算を行うには、\texttt{Get}を使用します。
これは2つの遷移規則で定義されています。
最初の遷移規則では、\texttt{Get} がスタックの一番上にあるブール値をどのように扱うかを見ています。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.44) &                   & $o$ & \texttt{Get} : $i$ & $a$ : $s$ & $d$ & $v$       & $h$[$a$ : \texttt{NConstr} $t$ []] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                & $s$       & $d$ & $t$ : $v$ & $h$                                & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

2つ目は、\texttt{Get}が数をどのように扱うかを見ることです。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.45) &                   & $o$ & \texttt{Get} : $i$ & $a$ : $s$ & $d$ & $v$       & $h$[$a$ : \texttt{NNum} $n$] & $m$ \\
	       & $\Longrightarrow$ & $o$ & $i$                & $s$       & $d$ & $n$ : $v$ & $h$                          & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

最後に、Vスタック上のブーリアン演算を利用するために、
Vスタックを検査してどの命令ストリームを使用するかを決定する単純化された\texttt{Casejump}命令を使用します。
この新しい命令は\texttt{Cond}と呼ばれ、次の2つの遷移規則で定義されます。
最初の遷移規則では、V-stackの一番上の値がtrueのとき、最初のコードシーケンス$t$を選択します。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.46) &                   & $o$ & \texttt{Cond} $t$ $f$ : $i$ & $s$ & $d$ & $2$ : $v$ & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & $t$ \texttt{++} $i$         & $s$ & $d$ & $v$       & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

2番目の遷移規則では、Vスタックの最上位の値がfalseであるため、\texttt{Cond}はその2番目の符号列$f$を選択することがわかります。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.47) &                   & $o$ & \texttt{Cond} $t$ $f$ : $i$ & $s$ & $d$ & $1$ : $v$ & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & $f$ \texttt{++} $i$         & $s$ & $d$ & $v$       & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 3.40] 命令データ型の拡張、\texttt{showInstruction}関数の再定義、新しい命令遷移の実装、\texttt{dispatch}関数の修正。
\end{description}

次に、コンパイラの改造（かなり大掛かりなもの）について考えてみましょう。

\subsubsection{コンパイラ}

状態コンポーネントが追加されたため、\texttt{compile}関数はVスタックコンポーネントを空に初期化する必要があります。

\begin{verbatim}
  compile :: CoreProgram -> GmState
  compile program
    = ([], initialCode, [], [], [], heap, globals, statInitial)
      where (heap, globals) = buildInitialHeap program
\end{verbatim}

厳密に言えば、これだけでマシンは動くのですが、Vスタックを導入したのは、
算術関数を「インライン」でコンパイルできるようにするためで、
私たちのコードはこれを意図しているのです。

\begin{verbatim}
  buildInitialHeap :: CoreProgram -> (GmHeap, GmGlobals)
  buildInitialHeap program
    = mapAccuml allocateSc hInitial compiled
      where compiled = map compileSc (preludeDefs ++ program ++ primitives)
\end{verbatim}

プリミティブ命令の遷移規則を変更したため、コンパイルしたプリミティブごとにコードを変更する必要があります。
Mark 6マシンで行ったように、このコードを手作業でコンパイルする代わりに、コンパイラにこの仕事を任せることができます。
もちろんこれは、コンパイラが生成するコードを最適化できるほど賢ければの話ですが、そうでなければ、\texttt{Add}命令は生成されません。

\begin{verbatim}
  primitives :: [(Name,[Name],CoreExpr)]
  primitives
    = [("+", ["x","y"], (EAp (EAp (EVar "+") (EVar "x")) (EVar "y"))),
       ("-", ["x","y"], (EAp (EAp (EVar "-") (EVar "x")) (EVar "y"))),
       ("*", ["x","y"], (EAp (EAp (EVar "*") (EVar "x")) (EVar "y"))),
       ("/", ["x","y"], (EAp (EAp (EVar "/") (EVar "x")) (EVar "y"))),
\end{verbatim}

また、ネゲーション関数を追加する必要があります。

\begin{verbatim}
       ("negate", ["x"], (EAp (EVar "negate") (EVar "x"))),
\end{verbatim}

比較関数は、二項演算関数とほぼ同じです。

\begin{verbatim}
       ("==", ["x","y"], (EAp (EAp (EVar "==") (EVar "x")) (EVar "y"))),
       ("~=", ["x","y"], (EAp (EAp (EVar "~=") (EVar "x")) (EVar "y"))),
       (">=", ["x","y"], (EAp (EAp (EVar ">=") (EVar "x")) (EVar "y"))),
       (">",  ["x","y"], (EAp (EAp (EVar ">")  (EVar "x")) (EVar "y"))),
       ("<=", ["x","y"], (EAp (EAp (EVar "<=") (EVar "x")) (EVar "y"))),
       ("<",  ["x","y"], (EAp (EAp (EVar "<")  (EVar "x")) (EVar "y"))),
\end{verbatim}

最後に、条件付き関数と、ブール値を表現するスーパーコンビネータを入れましょう。

\begin{verbatim}
       ("if", ["c","t","f"],
              (EAp (EAp (EAp (EVar "if") (EVar "c")) (EVar "t")) (EVar "f"))),
       ("True",  [], (EConstr 2 0)),
       ("False", [], (EConstr 1 0))]
\end{verbatim}

\textbf{コンパイルスキーム$\mathcal{B}$}
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{B} \llbracket e \rrbracket ~ \rho$は，環境$\rho$において式$e$をWHNFに評価するコードをコンパイルし、 \\
	結果をVスタックに残します。                                                                                   \\
	\begin{tabular}{r c l}
		$\mathcal{B} \llbracket i \rrbracket ~ \rho$                             & $=$ & $\left[\texttt{Pushbasic} ~ i \right]$                                                                                                                                                       \\
		\multicolumn{3}{l}{$\mathcal{B} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                                \\
		                                                                         & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+0} ~ \texttt{++}$                                                                                                                            \\
		                                                                         &     & $\ldots$                                                                                                                                                                                     \\
		                                                                         &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho^{+(n - 1)} ~ \texttt{++}$                                                                                                                      \\
		                                                                         &     & $\mathcal{B} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Pop} ~ n\right]$                                                                                                  \\
		                                                                         &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		\multicolumn{3}{l}{$\mathcal{B} \llbracket \texttt{letrec} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                             \\
		                                                                         & $=$ & $\left[\texttt{Alloc} ~ n\right] ~ \texttt{++}$                                                                                                                                              \\
		                                                                         &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ n - 1\right] ~ \texttt{++}$                                                                           \\
		                                                                         &     & $\ldots$                                                                                                                                                                                     \\
		                                                                         &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ 0\right] ~ \texttt{++}$                                                                               \\
		                                                                         &     & $\mathcal{B} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Pop} ~ n\right]$                                                                                                  \\
		                                                                         &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		$\mathcal{B} \llbracket e_0 ~ \texttt{+} ~ e_1 \rrbracket ~ \rho$        & $=$ & $\mathcal{B} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \mathcal{B} \llbracket e_0 \rrbracket ~ \rho^{+1} ~ \texttt{++} ~ \left[\texttt{Add} \right]$                                  \\
		                                                                         &     & 他の算術式についても同様。                                                                                                                                                                   \\
		$\mathcal{B} \llbracket e_0 ~ \texttt{==} ~ e_1 \rrbracket ~ \rho$       & $=$ & $\mathcal{B} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \mathcal{B} \llbracket e_0 \rrbracket ~ \rho^{+1} ~ \texttt{++} ~ \left[\texttt{Eq} \right]$                                   \\
		                                                                         &     & 他の比較式についても同様。                                                                                                                                                                   \\
		$\mathcal{B} \llbracket \texttt{negate} ~ e \rrbracket ~ \rho$           & $=$ & $\mathcal{B} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Neg} \right]$                                                                                                      \\
		$\mathcal{B} \llbracket \texttt{if} ~ e_0 ~ e_1 ~ e_2 \rrbracket ~ \rho$ & $=$ & $\mathcal{B} \llbracket e_0 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Cond} ~ (\mathcal{B} \llbracket e_1 \rrbracket ~ \rho) ~ (\mathcal{B} \llbracket e_2 \rrbracket ~ \rho) \right]$ \\
		$\mathcal{B} \llbracket e \rrbracket ~ \rho$                             & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Get} \right]$                                                                                                      \\
		                                                                         &     & デフォルトケース                                                                                                                                                                             \\ \hline
	\end{tabular}
\end{tabular}
\vskip\baselineskip

図3.18に示す$\mathcal{B}$スキームは、別のタイプのコンテキストを構成しています。
$\mathcal{B}$スキームによってコンパイルされるには、式はWHNFへの評価が必要であることが分かっているだけでなく、整数型かブール型の式でなければなりません。
以下の式は$\mathcal{B}$スキームを介して伝搬されます。

\begin{itemize}
	\item \texttt{let(rec)} $\Delta$ \texttt{in} $e$が$\mathcal{B}$-strictコンテキストで現れた場合、
	      式$e$も$\mathcal{B}$-strictコンテキストになります。
	\item \texttt{if} $e_0$ $e_1$ $e_2$という式が$\mathcal{B}$-strictコンテキストで現れたら、
	      $e_0, e_1, e_2$という式も$\mathcal{B}$-strictコンテキストで現れることになります。
	\item $e_0$ $\odot$ $e_1$ が $\mathcal{B}$-strict のコンテキストで出現し、 $\odot$ が比較または算術演算子である場合、
	      式 $e_0$ と $e_1$ も $\mathcal{B}$-strict のコンテキストで出現します。
	\item もし\texttt{negate} $e$が$\mathcal{B}$-strictのコンテキストで発生した場合、式$e$も同様となる。
\end{itemize}

式の特殊なケースを認識できない場合、コンパイルされたコードは$\mathcal{E}$スキームを使用して式を評価し、その後\texttt{Get}命令を実行します。
\texttt{Get}命令は、$\mathcal{E}$スキームによってスタックの一番上に残された値をアンボックスし、Vスタックに移動します。
\vskip\baselineskip

このため、ある式が最初は$\mathcal{B}$-strictコンテキストにあることをどうやって知るかは未解決でした。
通常の状況では、通常の$\mathcal{E}$-strictなコンテキストから、
値が整数型またはブーリアン型であるという追加の知識とともに、
$\mathcal{B}$-strictなコンテキストを生成します。

\begin{description}
	\item[演習 3.41] $\mathcal{B}$コンパイラスキームを実装する。
\end{description}

\textbf{コンパイルスキーム$\mathcal{E}$}
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{E} \llbracket e \rrbracket ~ \rho$は，式$e$を環境$\rho$のWHNFに評価するコードをコンパイルし、       \\
	式へのポインタをスタックの一番上に残します。                                                                  \\
	\begin{tabular}{r c l}
		$\mathcal{E} \llbracket i \rrbracket ~ \rho$                                                               & $=$ & $\left[\texttt{Pushint} ~ i \right]$                                                                                                                                                         \\
		\multicolumn{3}{l}{$\mathcal{E} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                                                                  \\
		                                                                                                           & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+0} ~ \texttt{++}$                                                                                                                            \\
		                                                                                                           &     & $\ldots$                                                                                                                                                                                     \\
		                                                                                                           &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho^{+(n - 1)} ~ \texttt{++}$                                                                                                                      \\
		                                                                                                           &     & $\mathcal{E} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$                                                                                                \\
		                                                                                                           &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		\multicolumn{3}{l}{$\mathcal{E} \llbracket \texttt{letrec} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho$}                                                                                                                               \\
		                                                                                                           & $=$ & $\left[\texttt{Alloc} ~ n\right] ~ \texttt{++}$                                                                                                                                              \\
		                                                                                                           &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ n - 1\right] ~ \texttt{++}$                                                                           \\
		                                                                                                           &     & $\ldots$                                                                                                                                                                                     \\
		                                                                                                           &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ 0\right] ~ \texttt{++}$                                                                               \\
		                                                                                                           &     & $\mathcal{E} \llbracket e \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n\right]$                                                                                                \\
		                                                                                                           &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                         \\
		$\mathcal{E} \llbracket \texttt{case} ~ e ~ \texttt{of} ~ alts \rrbracket ~ \rho$                          & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Casejump} ~ \mathcal{D_E} \llbracket alts \rrbracket ~ \rho \right]$                                               \\
		$\mathcal{E} \llbracket \texttt{Pack\{} t \texttt{,} a \texttt{\}} ~ e_1 ~ \ldots ~ e_a \rrbracket ~ \rho$ & $=$ & $\mathcal{C} \llbracket e_a \rrbracket ~ \rho ~ \texttt{++}$                                                                                                                                 \\
		                                                                                                           &     & $\ldots$                                                                                                                                                                                     \\
		                                                                                                           &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho ~ \texttt{++}$                                                                                                                                 \\
		                                                                                                           &     & $\left[\texttt{Pack} ~ t ~ a \right]$                                                                                                                                                        \\
		$\mathcal{E} \llbracket e_0 ~ \texttt{+} ~ e_1 \rrbracket ~ \rho$                                          & $=$ & $\mathcal{B} \llbracket e_0 ~ \texttt{+} ~ e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Mkint} \right]$                                                                               \\
		                                                                                                           &     & 他の算術式についても同様。                                                                                                                                                                   \\
		$\mathcal{E} \llbracket e_0 ~ \texttt{==} ~ e_1 \rrbracket ~ \rho$                                         & $=$ & $\mathcal{B} \llbracket e_0 ~ \texttt{==} ~ e_1 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Mkbool} \right]$                                                                             \\
		                                                                                                           &     & 他の比較式についても同様。                                                                                                                                                                   \\
		$\mathcal{E} \llbracket \texttt{negate} ~ e \rrbracket ~ \rho$                                             & $=$ & $\mathcal{B} \llbracket \texttt{negate} ~ e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Mkint} \right]$                                                                                  \\
		$\mathcal{E} \llbracket \texttt{if} ~ e_0 ~ e_1 ~ e_2 \rrbracket ~ \rho$                                   & $=$ & $\mathcal{B} \llbracket e_0 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Cond} ~ (\mathcal{E} \llbracket e_1 \rrbracket ~ \rho) ~ (\mathcal{E} \llbracket e_2 \rrbracket ~ \rho) \right]$ \\
		$\mathcal{E} \llbracket e \rrbracket ~ \rho$                                                               & $=$ & $\mathcal{C} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Eval} \right]$                                                                                                     \\
		                                                                                                           &     & デフォルトケース                                                                                                                                                                             \\
	\end{tabular}
	\\ \hline
	$\mathcal{D_E} \llbracket alts \rrbracket ~ \rho ~ d$は、\texttt{case}式の選択肢のリストをコンパイルします。  \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{D_E} \llbracket alt_1 ~ \ldots ~ alt_n \rrbracket ~ \rho$ & $=$ & $\left[\mathcal{A_E} \llbracket alt_1 \rrbracket ~ \rho ~ d ~ , \ldots , \mathcal{A_E} \llbracket alt_n \rrbracket ~ \rho ~ d \right]$ \\
	\end{tabular}
	\\ \hline
	$\mathcal{A_E} \llbracket alt \rrbracket ~ \rho ~ d$は、\texttt{case}式の各選択肢のコードをコンパイルします。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{A_E} \llbracket \texttt{<} t \texttt{>} ~ x_1 ~ \ldots ~ x_n ~ \texttt{->} body \rrbracket ~ \rho ~ d$ & $=$ & $t ~ \texttt{->} ~ \left[\texttt{Split} ~ n \right] ~ \texttt{++} ~ \mathcal{E} \llbracket body \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Slide} ~ n \right]$ \\
		                                                                                                                 &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ 0, ~ \ldots , ~ x_n ~ \mapsto ~ n - 1\right]$ です。                                                                 \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

$\mathcal{E}$スキーム（図3.19）は、算術関数と比較関数の呼び出しを特別扱いすることを定めたものです。
Mark6マシンで使用したバージョンと異なるのは、算術演算と比較演算に$\mathcal{B}$スキームを使用するためです。
また、特殊なケースがない場合、式をコンパイルするためにデフォルトのメソッドを使用しなければなりません。
これは、$\mathcal{C}$スキームを用いてグラフを構築し、コードストリームに\texttt{Eval}命令を配置するだけです。
これにより、グラフがWHNFに評価されることが保証されます。

\begin{description}
	\item[演習 3.42] 新しい$\mathcal{E}$コンパイラスキームを実装する。
\end{description}

\textbf{コンパイルスキーム$\mathcal{R}$}
\vskip\baselineskip

また、この機会に$\mathcal{R}$スキームを改善します。
まず、$\mathcal{B}$スキームが使われる機会を作りたいと考えています。
また，関数のコード列の末尾で実行される命令の数を減らすことも試みています．
$\mathcal{R}$スキームの新しいコンパイルスキームを図3.20に示します。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$は，アリティ$d$のスーパーコンビネータのために、               \\
	環境$\rho$で式$e$をインスタンス化するコードを生成し、                                                         \\
	その後、結果のスタックの巻き戻しに進みます。                                                                  \\
	\begin{tabular}{r c l}
		\multicolumn{3}{l}{$\mathcal{R} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho ~ d$}                                                                                                                           \\
		                                                                                      & $=$ & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho^{+0} ~ \texttt{++}$                                                                                                                                              \\
		                                                                                      &     & $\ldots$                                                                                                                                                                                                       \\
		                                                                                      &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho^{+(n - 1)} ~ \texttt{++}$                                                                                                                                        \\
		                                                                                      &     & $\mathcal{R} \llbracket e \rrbracket ~ \rho' ~ (n + d)$                                                                                                                                                        \\
		                                                                                      &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                                           \\
		\multicolumn{3}{l}{$\mathcal{R} \llbracket \texttt{letrec} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho ~ d$}                                                                                                                        \\
		                                                                                      & $=$ & $\left[\texttt{Alloc} ~ n\right] ~ \texttt{++}$                                                                                                                                                                \\
		                                                                                      &     & $\mathcal{C} \llbracket e_1 \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ n - 1\right] ~ \texttt{++}$                                                                                             \\
		                                                                                      &     & $\ldots$                                                                                                                                                                                                       \\
		                                                                                      &     & $\mathcal{C} \llbracket e_n \rrbracket ~ \rho' ~ \texttt{++} ~ \left[\texttt{Update} ~ 0\right] ~ \texttt{++}$                                                                                                 \\
		                                                                                      &     & $\mathcal{R} \llbracket e \rrbracket ~ \rho' ~ (n + d)$                                                                                                                                                        \\
		                                                                                      &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ n - 1, ~ \ldots , ~ x_n ~ \mapsto ~ 0\right]$ です。                                                                                                           \\
		$\mathcal{R} \llbracket \texttt{if} ~ e_0 ~ e_1 ~ e_2 \rrbracket ~ \rho ~ d$          & $=$ & $\mathcal{B} \llbracket e_0 \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Cond} ~ \left[\mathcal{R} \llbracket e_1 \rrbracket ~ \rho ~ d, ~ \mathcal{R} \llbracket e_2 \rrbracket ~ \rho ~ d\right] \right]$ \\
		$\mathcal{R} \llbracket \texttt{case} ~ e ~ \texttt{of} ~ alts \rrbracket ~ \rho ~ d$ & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Casejump} ~ \mathcal{D_R} \llbracket alts \rrbracket ~ \rho ~ d \right]$                                                             \\
		$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$                                      & $=$ & $\mathcal{E} \llbracket e \rrbracket ~ \rho ~ \texttt{++} ~ \left[\texttt{Update} ~ d, ~ \texttt{Pop} ~ d, ~ \texttt{Unwind}\right]$                                                                           \\
		                                                                                      &     & デフォルトケース                                                                                                                                                                                               \\
	\end{tabular}
	\\ \hline
	$\mathcal{D_R} \llbracket alts \rrbracket ~ \rho ~ d$は、\texttt{case}式の選択肢のリストをコンパイルします。  \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{D_R} \llbracket alt_1 ~ \ldots ~ alt_n \rrbracket ~ \rho$ & $=$ & $\left[\mathcal{A_R} \llbracket alt_1 \rrbracket ~ \rho ~ d ~ , \ldots , \mathcal{A_R} \llbracket alt_n \rrbracket ~ \rho ~ d \right]$ \\
	\end{tabular}
	\\ \hline
	$\mathcal{A_R} \llbracket alt \rrbracket ~ \rho ~ d$は、\texttt{case}式の各選択肢のコードをコンパイルします。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{A_R} \llbracket \texttt{<} t \texttt{>} ~ x_1 ~ \ldots ~ x_n ~ \texttt{->} ~ body \rrbracket ~ \rho ~ d$ & $=$ & $t ~ \texttt{->} ~ \left[\texttt{Split} ~ n \right] ~ \texttt{++} ~ \mathcal{R} \llbracket body \rrbracket ~ \rho'  ~ (n + d)$ \\
		                                                                                                                   &     & ここで $\rho' = \rho^{+n} \left[x_1 ~ \mapsto ~ 0, ~ \ldots , ~ x_n ~ \mapsto ~ n - 1\right]$ です。                           \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

Mark6マシンで使用したバージョンから拡張され、コンテキストのように動作するようになりました。
このコンテキストを$\mathcal{R}$-strictと呼ぶことにします。
$\mathcal{R}$-strictコンテキストでコンパイルされる式はWHNFに評価され、現在のredexを上書きするために使われます。
これは以下の伝搬のルールに従います。

\begin{itemize}
	\item スーパーコンビネータ定義の本体である式は、$\mathcal{R}$-strictのコンテキストにあります。
	\item もし\texttt{let(rec)} $\Delta$ \texttt{in} $e$が$\mathcal{R}$-strictコンテキストで出現したら、
	      式$e$も$\mathcal{R}$-strictコンテキストになります。
	\item もし式\texttt{if} $e_0$ $e_1$ $e_2$が$\mathcal{R}$-strictのコンテキストで現れたら、式$e_1$と$e_2$も$\mathcal{R}$-strictのコンテキストにある。
	      (式$e_0$は今度は$\mathcal{B}$-strictのコンテキストに現れる)。
	\item もし\texttt{case} $e$ \texttt{of} $alts$が$\mathcal{R}$-strictコンテキストで出現するならば、$e$という式はstrictなコンテキストにあることになる。
	      さらに、各選択肢の式部分は$\mathcal{R}$-strictコンテキストで出現する。
\end{itemize}

\begin{description}
	\item[演習 3.43] 図3.20の$\mathcal{R}$スキームを実装してください。
		\texttt{compileAlts}関数の一般性を利用して、$\mathcal{A}_\mathcal{R}$スキームと$\mathcal{A}_\mathcal{E}$スキームの両方を実装できることに注意してください。
\end{description}

Mark7マシンについて特筆すべき点は、現在のVスタックをダンプに保存する\texttt{Eval}命令を定義していないことです。
これは、[Peyton Jones 1987]で説明されたGマシンとは対照的です。
これを行うかどうかは、本書で作成した抽象的なマシンでは、本当に好みの問題です。
実際のマシン用にコードをコンパイルする場合、我々はスタックの数を最小にしようとすることが多いでしょう。
このような場合、\texttt{Eval}の代替遷移規則として次のようなものを使いたいです。
\vskip\baselineskip

\begin{tabular} {|c|l l r r r r l l|} \hline
	(3.48) &                   & $o$ & \texttt{Eval} : $i$ & $a$ : $s$ & $d$                             & $v$ & $h$ & $m$ \\
	       & $\Longrightarrow$ & $o$ & [\texttt{Unwind}]   & [$a$]     & $\langle i, s, v \rangle$ : $d$ & []  & $h$ & $m$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 3.44] \texttt{Eval}のためにこの代替遷移規則を実装します。この新しい遷移規則を可能にするために変更する必要がある他の命令は何ですか？
	\item[演習 3.45] ブール演算子\texttt{\&}, \texttt{\textbar}, \texttt{not}の最適化されたコードを生成するために、どのようなコンパイルルールを変更しますか？
	\item[演習 3.46] 以下の遷移規則による\texttt{Return}命令の追加。
		\vskip\baselineskip

		\begin{tabular} {|c|l l r r r r l l|} \hline
			(3.49) &                   & $o$ & [\texttt{Return}] & [$a_0, \ldots, a_k$] & $\langle i, s \rangle$ : $d$ & $v$ & $h$ & $m$ \\
			       & $\Longrightarrow$ & $o$ & $i$               & $a_k$ : $s$          & $d$                          & $v$ & $h$ & $m$ \\ \hline
		\end{tabular}
		\vskip\baselineskip

		※※※

		上記の遷移規則では、WHNFにあることが分かっているスタックの一番上のアイテムを捨ててしまうことになる。 \\
		以下の様な遷移規則になるのでは？
		\vskip\baselineskip

		\begin{tabular} {|c|l l r r r r l l|} \hline
			(3.49) &                   & $o$ & [\texttt{Return}] & [$a_0, \ldots, a_k$] & $\langle i, s \rangle$ : $d$ & $v$ & $h$ & $m$ \\
			       & $\Longrightarrow$ & $o$ & $i$               & $a_0$ : $s$          & $d$                          & $v$ & $h$ & $m$ \\ \hline
		\end{tabular}

		※※※
		\vskip\baselineskip

		これは、スタックの一番上のアイテムがWHNFにあることが分かっているときに、$\mathcal{R}$スキームによって\texttt{Unwind}の代わりに使用されます。
		この新しい命令を生成するために\texttt{compileR}を修正します。
	\item[演習 3.47] \texttt{UpdateInt n}の遷移規則を書いてください。
		この命令はシーケンス\texttt{[Mkint, Update n]}と同じアクションを実行します。
		この遷移規則と\texttt{UpdateBool n}のための同様の遷移規則を実装してください。
		\texttt{compileR}を修正して、元のシーケンスの代わりにこれらの命令を生成するようにしてください。
		なぜ新しい命令が元のシーケンスより好ましいのでしょうか？
		(ヒント：いくつかのサンプルプログラムからの統計値を利用すること)
\end{description}
\newpage

\subsection{結論}

この章で採用したアプローチは、大きなソフトウェアを設計する際に非常に役立ちます。
最初は非常に単純なものから始め、徐々に変更を加えることで、非常に大規模で複雑なソフトウェアを作成します。
これは、小さな漸進的な変更のプロセスによって常に可能であると主張するのは誤解を招く可能性があります。
実際、Mark1マシンの一部として提示された材料は、Mark7マシンを念頭に置いて特別に設計されました。
\vskip\baselineskip

しかし、現時点では、かなり効率的なマシンを製造しています。
次の章では、TIM について説明します。
\newpage

\begin{verbatim}
  module Tim where
  import Utils
  import Language
\end{verbatim}
\newpage

\section{TIM: 3命令マシン}

3つの命令マシンであるTIMは、最初は、これまでに見たものとは非常に異なる形のリダクションマシンのように見えます。
それでも、一連の比較的単純な手順でGマシンをTIMに変換できることがわかりました。
この章では、これらの手順について説明し、それによってTIMがどのように機能するかを示し、完全な最小TIMコンパイラと評価器を定義します。
そして、それに対する一連の改善と最適化を開発します。
\vskip\baselineskip

TIMはFairbairnとWrayによって発明されたもので、彼らの元の論文[Fairbairn and Wray 1987]は読む価値があります。
この章で採用したアプローチとはまったく異なる方法でTIMを説明します。
ただし、この章で作成された資料は、FairbairnとWrayの研究をはるかに超えているため、
あまり知られていないアイデアが議論され、実装されている後のセクションで、詳細レベルが高められています。
提示された新しいアイデアの多くはGuy Argoによるものであり、彼のFPCA論文[Argo 1989]と博士論文[Argo 1991]に提示されています。

\subsection{背景: TIMの仕組み}

次の関数定義を検討してください。

\begin{verbatim}
  f x y = g E1 E2
\end{verbatim}

ここで、\texttt{E1}と\texttt{E2}は任意の(そしておそらく複雑な)式であり、\texttt{g}はその他の関数です。
テンプレートインスタンス化マシン(第2章)とGマシン(第3章)の両方が、次の簡約を実行します。

\begin{verbatim}
      @    reduces to    @
     / \                / \
    @   y              @   E2
   / \                / \
  f   x              g   E1
\end{verbatim}

Gマシンはこれを行うためにかなりの数の(単純な)命令を必要としますが、テンプレートマシンは1つの(複雑な)ステップでそれを行います。
ですが、最終的な結果は同じです。

この図で、\texttt{E1} と \texttt{E2} は式 \texttt{E1} と \texttt{E2} のグラフです。
たとえば、\texttt{E1} が \texttt{(x+y)*(x-y)} の場合、\texttt{g} の最初の引数は \texttt{(x+y)*(x-y)} のグラフになります。
このグラフは、($\mathcal{C}$ コンパイル スキームによって生成されたコードによって) ヒープに苦労して構築する必要があります。
残念ながら、\texttt{g} は最初の引数を使用せずに破棄する可能性があるため、これは無駄な作業になる可能性があります。
関数への引数に対して行われるグラフ作成の量を制限する何らかの方法を見つけたいと考えています。

\subsubsection{平坦化}

変換のステップ1はまさにこれを行います。
\texttt{f}の定義を次の新しい定義に置き換えるとします。

\begin{verbatim}
  f x y = g (c1 x y) (c2 x y)
  c1 x y = E1
  c2 x y = E2
\end{verbatim}

私たちは、\texttt{c1}と\texttt{c2}という2つの補助関数を発明しました。
この定義は明らかに古いものと同等ですが、\textbf{\texttt{E1}がどれほど大きく複雑であっても、\texttt{f}の簡約中に行われる唯一の作業は、
	\texttt{(c1 x y)}のグラフを作成することです。}

さらに良いことに、Gマシンの実装には、自動的に得られるさらなる利点があります。
最初の定義では、\texttt{E1}は$\mathcal{C}$スキームによってコンパイルされます。
算術式をコンパイルするときに、$\mathcal{E}$スキームに存在する最適化を利用することはできません。
しかし、2番目の定義では、式\texttt{E1}はスーパーコンビネーターの右辺になり、これらすべての最適化が適用されます。
この方法で \texttt{(x+y)*(x-y)} をより効率的に評価できます。

もちろん、\texttt{E1}と\texttt{E2}自体に$\mathcal{C}$スキームでコンパイルされる大きな式が含まれている可能性があるため
(たとえば、\texttt{E2}が\texttt{(h E3 E4)}であるとします)、\texttt{c1}と\texttt{c2}の右辺に変換を再度適用する必要があります。 .
その結果、ネストされた構造を持つ式がないため、\textbf{平坦化された}プログラムと呼ばれます。

\subsubsection{タプル化}

次の注目点は、\texttt{c1}と\texttt{c2}の両方が\texttt{x}と\texttt{y}の両方に適用されることです。
そのため、\texttt{g}を呼び出す前に\texttt{(c1 x y)}と\texttt{(c2 x y)}のグラフを作成する必要があります。
\texttt{c1}と\texttt{c2}に引数が2つだけではなく多数ある場合、グラフはかなり大きくなる可能性があります。
2つのグラフは互いに非常に似ているため、これらの引数グラフがいくつかの共通部分を共有できるかどうかを尋ねるのは自然なことです。
重複を避け、それによってヒープ割り当てを減らします。
このアイデアは、2番目の変換で表現できます。

\begin{verbatim}
  f x y = let tup = (x,y)
          in g (c1 tup) (c2 tup)
  c1 (x,y) = E1
  c2 (x,y) = E2
\end{verbatim}

最初にその引数をタプルにパッケージ化し、次にこの単一のタプルを\texttt{c1}と\texttt{c2}に渡すという考え方です。
\texttt{f}をこのように定義すると、\texttt{f}の簡約は次のようになります。

\begin{verbatim}
      @    reduces to    @
     / \                / \
    @   y              /   @
   / \                @   / \
  f   x              / \ c2  \
                    g   @     \
                       / \_____\
                      c1        \
                                 -----
                                 |  -|---> x
                                 -----
                                 |  -|---> y
                                 -----
\end{verbatim}

\subsubsection{スパインレスであること}

前の図を見ると、スーパーコンビネータとタプル\texttt{tup}の場合、スパインが指す引数は常に\texttt{(c tup)}の形式であることがわかります。
簡約中に、これらの引数へのポインタのスタックを構築します。
しかし、それらはすべて同じ形式になっているので、代わりに引数(のルート)自体を積み重ねることができます!
したがって、\texttt{f}簡約後、スタックは次のようになります。

\begin{verbatim}
  |      |      |
  |-------------|
  |  C2  |  ----|---\
  |-------------|    \    |-------------|
  |  C1  |  ----|-------> |      |      | x
  |-------------|         |-------------|
                          |      |      | y
                          |-------------|
\end{verbatim}

スパインスタックの各アイテムは、コードポインタとタプルへのポインタのペアになりました。
このペアは、タプルに適用される関数を定義するコードである関数適用ノードと考えることができます。
\texttt{f}へのエントリでは、引数\texttt{x}と\texttt{y}(のルート)がスタック上にあったため、
\texttt{x}と\texttt{y}のタプルは実際にはコードポインタ/タプルポインタのペアのタプルです。

コードポインタ/タプルポインタのペアは\textbf{クロージャ}と呼ばれ、そのようなクロージャのタプルは\textbf{フレーム}と呼ばれます。
フレームへのポインタを\textbf{フレームポインタ}と呼びます。
ヒープにスパインがなくなっていることに注意してください。スタックは、評価される式のスパインです。
TIMはスパインレスマシンです。

\subsubsection{例}

TIMプログラムがどのように機能するかの例を示します。
次のように定義された関数\texttt{compose2}を考えてみましょう。

\begin{verbatim}
  compose2 f g x = f (g x x)
\end{verbatim}

\texttt{compose2}の「平坦化された」形式は次のようになります。

\begin{verbatim}
  compose2 f g x = f (c1 g x)
  c1 g x = g x x
\end{verbatim}

\texttt{compose2}に入ると、次のように3つの引数がスタックの一番上に置かれます。

\begin{verbatim}
    |        |       |
    |----------------|
  x | x-code | x-frm |
    |----------------|
  g | g-code | g-frm |
    |----------------|
  f | f-code | f-frm |
    |----------------|
\end{verbatim}

最初に行うことは、これら3つの引数のタプル(フレーム)をヒープに形成することです。
その後、それらをスタックから削除できます。
\textbf{フレームポインタ}と呼ばれる特別なレジスタに新しいフレームへのポインタを保持します。
これは、命令によって行われます。

\begin{verbatim}
  Take 3
\end{verbatim}

マシンの状態は次のようになります。

\begin{verbatim}
        |        |       |
        |----------------|
                                        ------------------
  Frame ptr ------------------------> f | f-code | f-frm |
                                        |----------------|
                                      g | g-code | g-frm |
                                        |----------------|
                                      x | x-code | x-frm |
                                        ------------------
\end{verbatim}

次に、\texttt{f}の引数を準備する必要があります。
\texttt{(g x x)}という1つのみがあり、そのクロージャをスタックにプッシュします。
クロージャのフレームポインタは現在のフレームポインタレジスタにすぎないため、命令はコードラベルを提供するだけで済みます。

\begin{verbatim}
  Push (Label "c1")
\end{verbatim}

最後に、\texttt{f}にジャンプします。
\texttt{f}はグローバルなスーパーコンビネータではなく、\texttt{compose}の引数であるため、
\texttt{f}は、現在のフレームのクロージャによって表されます。
私たちがしなければならないことは、クロージャをフェッチし、そのフレームポインタをフレームポインタレジスタにロードし、
そのコードポインタをプログラムカウンタにロードすることです。
これは次の命令によって行われます。

\begin{verbatim}
  Enter (Arg 1) -- f is argument 1
\end{verbatim}

この命令の後、マシンの状態は次のようになります。

\begin{verbatim}
      |       |       |
      |---------------|               -----------------
      | c1    |   ----|-----------> f | f-code| f-frm |
      |---------------|               |---------------|
                                    g | g-code| g-frm |
Frame ptr:   f-frm                    |---------------|
Program ctr: f-code                 x | x-code| x-frm |
                                      -----------------
\end{verbatim}

それだ！
\texttt{compose2}の本体は、次の3つの命令だけで構成されています。

\begin{verbatim}
  compose2:   Take 3                -- 3 arguments
              Push (Label "c1")     -- closure for (g x x)
              Enter (Arg 1)         -- f is argument 1
\end{verbatim}

ただし、ラベル\texttt{c1}を処理する必要があります。
\texttt{(g x x)}のクロージャが必要な場合は、\texttt{Enter}命令で入力されるため、プログラムカウンタは\texttt{c1}を指し、
\texttt{f}、\texttt{g}、および\texttt{x}を含む元のフレームへのフレームポインタ。
この時点で必要なことは、\texttt{g}の引数、つまり\texttt{x}を準備し、\texttt{g}を入力することだけです。

\begin{verbatim}
  c1:         Push (Arg 3)          -- x is argument 3
              Push (Arg 3)          -- x again
              Enter (Arg 2)         -- g is argument 2
\end{verbatim}

\texttt{Push (Arg 3)}命令は、現在のフレームから\texttt{x}のクロージャのコピーをフェッチし、それをスタックにプッシュします。
次に、\texttt{Enter (Arg 2)}命令が、現在スタックにある引数
\footnote{\texttt{(g x x)}クロージャに入ったときにスタックが空でなかった場合、2つ以上になる可能性があります。}
に\texttt{g}を適用します。

\subsubsection{状態遷移規則によるマシンの定義}

3つの命令マシンと呼ばれる理由がわかります。
\texttt{Take}、\texttt{Push}、\texttt{Enter}の3つの主要な命令があります。
いくつかの点で、3つの命令しかないと主張するのはかなり楽観的です。
なぜなら、\texttt{Push}と\texttt{Enter}には両方ともいくつかの「アドレス指定モード」があり、
さらに、やがてかなりの数の新しい命令を発明する必要があるからです。
それにしても素敵な名前ですね。
\vskip\baselineskip

いつものように、状態遷移規則を使用して、各命令の正確な作用を表現します。
まず、マシンの状態を定義する必要があります。
これは、

\[
	(instructions, ~ frame pointer, ~ stack, ~ heap, ~ code store)
\]

または略して$(i, ~ f, ~ s, ~ h, ~ c)$の五つ組です。
コード ストアは、まだ説明されていない唯一の項目です。
コードのコレクションが含まれており、それぞれにラベルが付いています。
実際には、コードストアにはコンパイル済みのスーパーコンビネータの定義が含まれており、
それぞれにスーパーコンビネータの名前が付けられていますが、
原則として、有用であることが判明した場合は、他のラベル付けされたコードフラグメントも含めることができます。
\vskip\baselineskip

次に、各命令の遷移規則を作成します。
\texttt{Take} $n$ は、スタックの上位 $n$ 個の要素を新しいフレームに形成し、現在のフレームポインタがそれを指すようにします。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.1) &                   & \texttt{Take} $n$ : $i$ & $f$  & $c_1$ : $\ldots$ : $c_n$ : $s$ & $h$                                            & $c$ \\
	      & $\Longrightarrow$ & $i$                     & $f'$ & $s$                            & $h$[$f'$ : $\langle c_1, \ldots, c_n \rangle$] & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

次に、\texttt{Push} と \texttt{Enter} のルールについて説明します。
これらの 2 つの命令はまったく同じアドレッシング モード (\texttt{Arg}、\texttt{Label} など) を持ち、それらの間には非常に明確な関係があります。

\begin{quote}
	\texttt{Push}/\texttt{Enter}の関係。
	\texttt{Push} $arg$ 命令がクロージャ $(i, f )$ をスタックにプッシュする場合、
	\texttt{Enter} $arg$ は $i$ をプログラムカウンタにロードし、$f$ を現在のフレームポインタにロードします。
\end{quote}

\texttt{Push} (\texttt{Arg} $n$) 命令は、現在のフレームから $n$ 番目のクロージャをフェッチし、それをスタックにプッシュします。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.2) &                   & \texttt{Push} (\texttt{Arg} $k$) : $i$ & $f$ & $s$                  & $h$[$f$ : $\langle (i_1, f_1), \ldots, (i_k, f_k), \ldots, (i_n, f_n) \rangle$] & $c$ \\
	      & $\Longrightarrow$ & $i$                                    & $f$ & ($i_k$, $f_k$) : $s$ & $h$                                                                             & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Push} (\texttt{Label} $l$) は、コードストアでラベル $l$ を検索し、
このコードポインタと現在のフレームポインタで構成されるクロージャをプッシュします。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.3) &                   & \texttt{Push} (\texttt{Label} $l$) : $i$ & $f$ & $s$               & $h$ & $c$[$l$ : $i'$] \\
	      & $\Longrightarrow$ & $i$                                      & $f$ & ($i'$, $f$) : $s$ & $h$ & $c$             \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{compose} の例では、任意のラベル \texttt{c1} を作成する必要がありました。
これらのラベルを考え出さなければならないのは面倒です。
代わりに、プッシュ命令の新しい形式、\texttt{Push} (\texttt{Code} $i$) を追加するだけです。
これにより、ターゲットコードシーケンス $i$ が命令自体の一部になります。
したがって、

\begin{verbatim}
  Push (Label "c1")
\end{verbatim}

の代わりに

\begin{verbatim}
  Push (Code [Push (Arg 3), Push (Arg 3), Enter (Arg 2)])
\end{verbatim}

と書くことが出来ます。
適切な状態遷移規則は次のとおりです。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.4) &                   & \texttt{Push} (\texttt{Code} $i'$) : $i$ & $f$ & $s$               & $h$ & $c$ \\
	      & $\Longrightarrow$ & $i$                                      & $f$ & ($i'$, $f$) : $s$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

これまでのところ、\texttt{Arg}、\texttt{Code}、\texttt{Label} の 3 つの「アドレス指定モード」があります。
整数定数用に \texttt{IntConst} をもう 1 つ追加する必要があります。
たとえば、呼び出し \texttt{(f 6)} は次のコードにコンパイルされます。

\begin{verbatim}
  Push (IntConst 6)
  Enter (Label "f")
\end{verbatim}

\texttt{Push} 命令は常にクロージャ (つまり、コードポインタ/フレームポインタのペア) をスタックにプッシュしますが、
整数定数の場合は、どのクロージャをプッシュするかはまったく明確ではありません。
整数自体を格納する場所が必要なので、その目的のためにフレームポインタスロットを「スチール」しましょう。
\footnote{整数はフレームポインタよりも大きくないという暗黙の仮定を行っていますが、これは通常実際には当てはまります。}
この決定は、次の規則につながります。
ここで、\texttt{intCode} は整数クロージャの (まだ未定の) コードシーケンスです。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.5) &                   & \texttt{Push} (\texttt{IntConst} $n$) : $i$ & $f$ & $s$                           & $h$ & $c$ \\
	      & $\Longrightarrow$ & $i$                                         & $f$ & (\texttt{intCode}, $n$) : $s$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{intCode} は何をすべきか?
今のところ、私たちのマシンは演算を行わないので、簡単な解決策は \texttt{intCode} を空のコードシーケンスにすることです。

\begin{verbatim}
  intCode = []  -- Mark1 TIM を写経する際は、これを忘れずに！
\end{verbatim}

整数クロージャが入力されると、マシンは空のコードシーケンスにジャンプし、実行が停止します。
これにより、Mark 1 には十分な整数を返すプログラムを書くことができます。

\texttt{Push} 命令については以上です。
\texttt{Enter} 命令のルール (アドレス指定ごとに 1 つ)
モードでは、\texttt{Push}/\texttt{Enter} 関係から直接に従います。
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.6) &                   & [\texttt{Enter} (\texttt{Label} $l$)] & $f$ & $s$ & $h$ & $c$[$l$ : $i$] \\
	      & $\Longrightarrow$ & $i$                                   & $f$ & $s$ & $h$ & $c$            \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.7) &                   & [\texttt{Enter} (\texttt{Arg} $k$)] & $f$   & $s$ & $h$[$f$ : $\langle (i_1, f_1), \ldots, (i_k, f_k), \ldots, (i_n, f_n) \rangle$] & $c$ \\
	      & $\Longrightarrow$ & $i_k$                               & $f_k$ & $s$ & $h$                                                                             & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.8) &                   & [\texttt{Enter} (\texttt{Code} $i$)] & $f$ & $s$ & $h$ & $c$ \\
	      & $\Longrightarrow$ & $i$                                  & $f$ & $s$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

\begin{tabular} {|c|l r l r l l|} \hline
	(4.9) &                   & [\texttt{Enter} (\texttt{IntConst} $n$)] & $f$ & $s$ & $h$ & $c$ \\
	      & $\Longrightarrow$ & \texttt{intCode}                         & $n$ & $s$ & $h$ & $c$ \\ \hline
\end{tabular}

\subsubsection{コンパイル}

これで、各 TIM 命令が何を行うかについて正確な説明ができました。
プログラムを TIM 命令に変換する方法を説明する必要があります。
これは、以前と同様に、一連の\textbf{コンパイルスキーム}を使用して行います。
各スーパーコンビネーターは、図 4.1 に示す $\mathcal{SC}$ スキームでコンパイルされます。
$\mathcal{SC}$ に渡される初期環境は、各スーパーコンビネータ名をそのラベルアドレッシングモードにバインドします。
$\mathcal{SC}$ スキームは単に \texttt{Take} 命令を生成し、$\mathcal{R}$ スキームを呼び出して、
各引数に使用するアドレッシングモードを指定するバインドによって強化された環境を渡します。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{SC} \llbracket e \rrbracket ~ \rho$は、環境$\rho$におけるスーパーコンビネータ定義$def$のTIMコードです。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{SC} \llbracket f ~ x_1 ~ \ldots ~ x_n ~ \texttt{=} ~ e \rrbracket ~ \rho$ & $=$ & \texttt{Take} $n$ \texttt{:} $\mathcal{R} \llbracket e \rrbracket ~ \rho[x_1 \mapsto \texttt{Arg} ~ 1, \ldots, x_n \mapsto \texttt{Arg} ~ n]$
	\end{tabular}
	\\ \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho$は、環境$\rho$の式$e$の値をスタック上の引数に適用するTIMコードです。  \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{R} \llbracket e_1 ~ e_2 \rrbracket ~ \rho$ & $=$ & \texttt{Push} ($\mathcal{A} \llbracket e_2 \rrbracket ~ \rho$) \texttt{:} $\mathcal{R} \llbracket e_1 \rrbracket ~ \rho$ \\
		$\mathcal{R} \llbracket a \rrbracket ~ \rho$         & $=$ & \texttt{Enter} ($\mathcal{A} \llbracket a \rrbracket ~ \rho$)                                                            \\
		                                                     &     & ここで、$a$ は整数、変数、またはスーパーコンビネータです。
	\end{tabular}
	\\ \hline
	$\mathcal{A} \llbracket e \rrbracket ~ \rho$は、環境$\rho$における式$e$のTIMアドレッシングモードです。            \\
	\\
	\begin{tabular}{r c l l}
		$\mathcal{A} \llbracket x \rrbracket ~ \rho$ & $=$ & $\rho ~ x$                                                   & ここで、$x$ は $\rho$ によって束縛されます。 \\
		$\mathcal{A} \llbracket n \rrbracket ~ \rho$ & $=$ & \texttt{IntConst} $n$                                        & ここで、$n$ は整数です。                     \\
		$\mathcal{A} \llbracket e \rrbracket ~ \rho$ & $=$ & \texttt{Code} ($\mathcal{R} \llbracket e \rrbracket ~ \rho$) & その他                                       \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

$\mathcal{R}$ スキーム (図 4.1) は、変数またはスーパーコンビネータが見つかるまで、単純に引数をスタックにプッシュします。
$\mathcal{A}$ 方式を使用して正しいアドレッシングモードを生成します。
セクション 4.1.1 で説明した平坦化プロセスがこれらのルールによって「オンザフライ」で実行されることに注意してください。
\vskip\baselineskip

ここでは、算術、データ構造、ケース分析、および \texttt{let(rec)} 式を省略します。
それらはすべて後で追加されます。

\subsubsection{更新}

これまでのところ、更新についての言及はありません。
これは、スパインが消滅したため、更新するスパインノードがないためです。実際、これまで説明してきたマシンはツリー簡約マシンです。
共有引数は繰り返し評価される場合があります。
更新を適切に行うことは、スパインレス実装のアキレス腱です。
そうしないと無制限の量の作業が複製される可能性があるため、これは絶対に必要ですが、
更新しないバージョンの優雅さと速度(複製はさておき)の一部を失う複雑さを追加します。

後でセクション4.5で更新に戻りますが、それまでは非更新バージョンを実装するだけで十分です。
\newpage

\subsection{Mark 1: 最小限のTIM}

このセクションでは、演算、データ構造、または更新を使用しない、最小限で完全な TIM 実装を開発します。
これらは、後続のセクションで追加されます。

\subsubsection{全体構造}

構造は、テンプレートインスタンス化インタープリタとほとんど同じです。
\texttt{run}関数は、従来通り、\texttt{parse}、\texttt{compile}、\texttt{eval}、\texttt{showResults}の4つの関数で構成されています。
解析のタイプは第1章で与えられます。 他の3つのタイプを以下に示します。

\begin{verbatim}
  runProg     :: [Char] -> [Char]
  compile     :: CoreProgram -> TimState
  eval        :: TimState -> [TimState]
  showResults :: [TimState] -> [Char]

  runProg = showResults . eval . compile . parse
\end{verbatim}

多くの場合、すべての中間状態を表示すると便利なため、\texttt{showFullResults}を使用して各状態を表示する\texttt{fullRun}も提供します。

\begin{verbatim}
  fullRun :: [Char] -> [Char]
  fullRun = showFullResults . eval . compile . parse
\end{verbatim}

languageモジュールをインポートする必要があります。

\subsubsection{データ型の定義}

TIM 命令のデータ型は、これまでに紹介した命令に直接対応しています。

\begin{verbatim}
  data Instruction = Take  Int
                   | Enter TimAMode
                   | Push  TimAMode
\end{verbatim}

アドレッシングモードのタイプである \texttt{timAMode} は、\texttt{Push} と \texttt{Enter} の関係を強調するために、
別個のデータタイプとして分離されています。

\begin{verbatim}
  data TimAMode = Arg      Int
                | Label    [Char]
                | Code     [Instruction]
                | IntConst Int
\end{verbatim}

TIMマシンの状態は、次の定義によって与えられます。

\begin{verbatim}
  type TimState = ([Instruction], -- The current instruction stream
                   FramePtr,      -- Address of current frame
                   TimStack,      -- Stack of arguments
                   TimValueStack, -- Value stack (not used yet)
                   TimDump,       -- Dump (not used yet)
                   TimHeap,       -- Heap of frames
                   CodeStore,     -- Labelled blocks of code
                   TimStats)      -- Statistics
\end{verbatim}

値スタックとダンプは、この章の後半でのみ必要になりますが、それらのプレースホルダーをすぐに追加する方が便利です。
\vskip\baselineskip

これらの各コンポーネントの表現を順番に検討します。

\begin{itemize}
	\item \textbf{現在の命令ストリーム}は、命令のリストで表されます。
	      実際のマシンでは、これはプログラムメモリと共にプログラムカウンタになります。
	\item 通常、\textbf{フレームポインタ}はヒープ内のフレームのアドレスですが、他に 2 つの可能性があります。
	      整数値を保持するために使用されるか、初期化されていない可能性があります。
	      マシンは、これら3つの可能性のどれを期待するかを常に「認識」していますが、\texttt{framePtr}の代数データ型を使用してそれらを区別する実装が便利です。
	      \begin{verbatim}
          data FramePtr = FrameAddr Addr -- The address of a frame
                        | FrameInt Int   -- An integer value
                        | FrameNull      -- Uninitialised
        \end{verbatim}
	      これを行わないと、アドレスを数値として使用しようとすると、Mirandaは(正当に)型エラーを報告します。
	      さらに、初期化されていない状態の \texttt{FrameNull}のコンストラクタがあるということは、
	      初期化されていない値を有効なアドレスとして誤って使用しようとした場合に、インタープリタが検出することを意味します。
	\item \textbf{スタック}には\textbf{クロージャ}が含まれており、それぞれがコード ポインタとフレーム ポインタを含むペアです。
	      スタックをリストとして表します。
	      \begin{verbatim}
          type TimStack = [Closure]
          type Closure = ([Instruction], FramePtr)
        \end{verbatim}
	\item 値スタックとダンプは最初からまったく使用されていないため、nullary コンストラクターが 1 つだけあるダミーの代数データ型でそれぞれを表します。
	      後で、これらの定義をより興味深いものに置き換えます。
	      \begin{verbatim}
          data TimValueStack = DummyTimValueStack
          data TimDump = DummyTimDump
        \end{verbatim}
	\item \textbf{ヒープ}には\textbf{フレーム}が含まれており、それぞれがクロージャのタプルです。
	      フレームのデータ型は、独自の抽象データ型に値するほど重要です。
	      \begin{verbatim}
          type TimHeap = Heap Frame

          fAlloc  :: TimHeap -> [Closure] -> (TimHeap, FramePtr)
          fGet    :: TimHeap -> FramePtr -> Int -> Closure
          fUpdate :: TimHeap -> FramePtr -> Int -> Closure -> TimHeap
          fList   :: Frame -> [Closure] -- Used when printing
        \end{verbatim}
	      これらの操作により、フレームを構築し、コンポーネントを抽出して更新できます。
	      \texttt{fGet} と \texttt{fUpdate} のために、\texttt{fAlloc} に与えられるリストの最初の要素には \texttt{1} の番号が付けられます。
	      これは、リストに基づく簡単な実装です。
	      \begin{verbatim}
          type Frame = [Closure]

          fAlloc heap xs = (heap', FrameAddr addr)
                           where
                           (heap', addr) = hAlloc heap xs

          fGet heap (FrameAddr addr) n = f !! (n-1)
                                         where
                                           f = hLookup heap addr

          fUpdate heap (FrameAddr addr) n closure
            = hUpdate heap addr new_frame
              where
                frame = hLookup heap addr
                new_frame = take (n-1) frame ++ [closure] ++ drop n frame

          fList f = f
        \end{verbatim}
	\item ラベルごとに、\textbf{コードストア}は対応するコンパイル済みコードを提供します。
	      \begin{verbatim}
          type CodeStore = ASSOC Name [Instruction]
        \end{verbatim}
	      この機会に、失敗した場合にエラー メッセージを生成するラベルのルックアップ関数を提供します。
	      \begin{verbatim}
          codeLookup :: CodeStore -> Name -> [Instruction]
          codeLookup cstore l
            = aLookup cstore l (error ("Attempt to jump to unknown label "
                                       ++ show l))
        \end{verbatim}
	\item いつものように、\textbf{統計}を簡単に追加できる抽象データ型にします。
	      \begin{verbatim}
          statInitial :: TimStats
          statIncSteps :: TimStats -> TimStats
          statGetSteps :: TimStats -> Int
        \end{verbatim}
\end{itemize}

ステップ数のみをカウントする最初の実装はかなり単純です。

\begin{verbatim}
  type TimStats = Int -- The number of steps
  statInitial = 0
  statIncSteps s = s+1
  statGetSteps s = s
\end{verbatim}

最後に、ヒープとスタックのコードが必要です。

\begin{verbatim}
  -- :a util.lhs -- heap data type and other library functions
\end{verbatim}

\subsubsection{プログラムのコンパイル}

\texttt{compile}は、与えられたプログラムから初期マシン状態を作成する、テンプレートインスタンス化のコンパイラと非常によく似た働きをします。
主な違いは、コンパイル関数\texttt{compileSC}にあります。
これは各スーパーコンビネータに適用されます。

\begin{verbatim}
  compile program
    = ([Enter (Label "main")], -- Initial instructions
       FrameNull,              -- Null frame pointer
       initialArgStack,        -- Argument stack
       initialValueStack,      -- Value stack
       initialDump,            -- Dump
       hInitial,               -- Empty heap
       compiled_code,          -- Compiled code for supercombinators
       statInitial)            -- Initial statistics
      where
        sc_defs = preludeDefs ++ program
        compiled_sc_defs = map (compileSC initial_env) sc_defs
        compiled_code = compiled_sc_defs ++ compiledPrimitives
        initial_env = [(name, Label name) | (name, args, body) <- sc_defs] ++
                      [(name, Label name) | (name, code) <- compiledPrimitives]
\end{verbatim}

今のところ、引数スタックは空に初期化されています。

\begin{verbatim}
  initialArgStack = []
\end{verbatim}

今のところ、値スタックとダンプはダミー値に初期化されています。
後でこれらの定義を変更します。

\begin{verbatim}
  initialValueStack = DummyTimValueStack
  initialDump = DummyTimDump
\end{verbatim}

コンパイルされたスーパーコンビネータ\texttt{compiled\_sc\_defs}は、
\texttt{compileSC}を使用して、プログラム内の各スーパーコンビネータをコンパイルすることによって取得されます。
\texttt{compileSC}に渡される初期環境は、各スーパーコンビネータに適したアドレス指定モードを提供します。
コードストア、\texttt{compiled\_code}は、\texttt{compiled\_sc\_defs}と\texttt{compiledPrimitives}を組み合わせることによって取得されます。
後者は、組み込みのプリミティブ用にコンパイルされたコードを含むことを目的としていますが、現時点では空です:

\begin{verbatim}
  compiledPrimitives = []
\end{verbatim}

テンプレートマシンやGマシンとは異なり、初期ヒープは空です。
これらの場合に空でない初期ヒープの理由は、CAF(つまり、引数のないスーパーコンビネータ - セクション 2.1.6)の共有を保持するためでした。
TIMマシンのこの初期バージョンでは、CAF用にコンパイルされたTIMコードが呼び出されるたびに実行されるため、CAFを評価する作業は共有されません。
この問題については、後でセクション4.7で説明します。
\vskip\baselineskip

コンパイラの核心は、コンパイルスキーム$\mathcal{SC}$、$\mathcal{R}$、および$\mathcal{A}$を
それぞれ関数\texttt{compileSC}、\texttt{compileR}、および\texttt{compileA}に直接変換することです。
環境$\rho$は、名前をアドレッシングモードにバインドする連想リストによって表されます。
Gマシンのコンパイラは、名前からスタックオフセットへのマッピングを使用していましたが、
アドレッシングモードを使用することで得られる特別な柔軟性はかなり有用であることがわかりました。

\begin{verbatim}
  type TimCompilerEnv = [(Name, TimAMode)]
\end{verbatim}

これで\texttt{compileSC}を定義する準備が整いました:

\begin{verbatim}
  compileSC :: TimCompilerEnv -> CoreScDefn -> (Name, [Instruction])
  compileSC env (name, args, body)
    = (name, Take (length args) : instructions)
      where
        instructions = compileR body new_env
        new_env = (zip2 args (map Arg [1..])) ++ env
\end{verbatim}

\texttt{compileR}は式と環境を受け取り、命令のリストを提供します。

\begin{verbatim}
  compileR :: CoreExpr -> TimCompilerEnv -> [Instruction]
  compileR (EAp e1 e2) env = Push (compileA e2 env) : compileR e1 env
  compileR (EVar v)    env = [Enter (compileA (EVar v) env)]
  compileR (ENum n)    env = [Enter (compileA (ENum n) env)]
  compileR e           env = error "compileR: can't do this yet"

  compileA :: CoreExpr -> TimCompilerEnv -> TimAMode
  compileA (EVar v) env = aLookup env v (error ("Unknown variable " ++ v))
  compileA (ENum n) env = IntConst n
  compileA e env = Code (compileR e env)
\end{verbatim}

\subsubsection{評価器}

次に、評価器が実際にどのように機能するかを定義する必要があります。
\texttt{eval}の定義は、テンプレートインスタンス化マシンとまったく同じです。

\begin{verbatim}
  eval state
    = state : rest_states
      where
        rest_states | timFinal state = []
                    | otherwise      = eval next_state
        next_state = doAdmin (step state)

  doAdmin state = applyToStats statIncSteps state
\end{verbatim}

\texttt{timFinal}関数は、状態が最終状態であることを示します。
\texttt{Stop}命令を発明することもできますが、コードシーケンスが空の場合に終了したと言うのは簡単です。

\begin{verbatim}
  timFinal ([], frame, stack, vstack, dump, heap, cstore, stats) = True
  timFinal state                                                 = False
\end{verbatim}

\texttt{applyToStats}関数は、状態の統計コンポーネントに関数を適用するだけです。

\begin{verbatim}
  applyToStats stats_fun (instr, frame, stack, vstack,
                          dump, heap, cstore, stats)
    = (instr, frame, stack, vstack, dump, heap, cstore, stats_fun stats)
\end{verbatim}

\textbf{ステップを進める}
\vskip\baselineskip

\texttt{step}は、単一の命令を受け取って実行するケース分析を行います。
\texttt{Take}式は、対応する状態遷移規則(4.1)を単純に訳したものです。

\begin{verbatim}
  step ((Take n:instr), fptr, stack, vstack, dump, heap, cstore,stats)
    | length stack >= n = (instr, fptr', drop n stack, vstack, dump,
                           heap', cstore, stats)
    | otherwise     = error "Too few args for Take instruction"
    where (heap', fptr') = fAlloc heap (take n stack)
\end{verbatim}

\texttt{Enter}と\texttt{Push}の方程式は、\texttt{timAMode}をクロージャに変換する共通関数\texttt{amToClosure}を使用して、
\texttt{Push}/\texttt{Enter}の関係を利用します。

\begin{verbatim}
  step ([Enter am], fptr, stack, vstack, dump, heap, cstore, stats)
    = (instr', fptr', stack, vstack, dump, heap, cstore, stats)
      where (instr',fptr') = amToClosure am fptr heap cstore

  step ((Push am:instr), fptr, stack, vstack, dump, heap, cstore, stats)
    = (instr, fptr, amToClosure am fptr heap cstore : stack,
       vstack, dump, heap, cstore, stats)
\end{verbatim}

\texttt{amToClosure}は、最初の引数であるアドレッシングモードによってアドレス指定されたクロージャを提供します。

\begin{verbatim}
  amToClosure :: TimAMode -> FramePtr -> TimHeap -> CodeStore -> Closure
  amToClosure (Arg n)      fptr heap cstore = fGet heap fptr n
  amToClosure (Code il)    fptr heap cstore = (il, fptr)
  amToClosure (Label l)    fptr heap cstore = (codeLookup cstore l, fptr)
  amToClosure (IntConst n) fptr heap cstore = (intCode, FrameInt n)
\end{verbatim}

\subsubsection{結果の表示}

テンプレートインスタンス化バージョンと同様に、結果を適切な方法で出力するには、かなり退屈な関数のコレクションが必要です。
スーパーコンビネータの定義を出力すると便利な場合が多いため、最初の状態の定義を使用して、\texttt{showResults}を出力することから始めます。

\begin{verbatim}
  showFullResults states
    = iDisplay (iConcat [
        iStr "Supercombinator definitions", iNewline, iNewline,
        showSCDefns first_state, iNewline, iNewline,
        iStr "State transitions", iNewline,
        iLayn (map showState states), iNewline, iNewline,
        showStats (last states)
      ])
      where
        (first_state:rest_states) = states
\end{verbatim}

\texttt{showResults}は、最後の状態といくつかの統計を表示するだけです。

\begin{verbatim}
  showResults states
    = iDisplay (iConcat [
        showState last_state, iNewline, iNewline, showStats last_state
      ])
      where last_state = last states
\end{verbatim}

残りの機能は簡単です。
\texttt{showSCDefns}は、各スーパーコンビネータのコードを表示します。

\begin{verbatim}
  showSCDefns :: TimState -> Iseq
  showSCDefns (instr, fptr, stack, vstack, dump, heap, cstore, stats)
    = iInterleave iNewline (map showSC cstore)

  showSC :: (Name, [Instruction]) -> Iseq
  showSC (name, il)
    = iConcat [
        iStr "Code for ", iStr name, iStr ":", iNewline,
        iStr " ", showInstructions Full il, iNewline, iNewline
      ]
\end{verbatim}

\texttt{showState}は、TIMマシンの状態を表示します。

\begin{verbatim}
  showState :: TimState -> Iseq
  showState (instr, fptr, stack, vstack, dump, heap, cstore, stats)
    = iConcat [
        iStr "Code: ", showInstructions Terse instr, iNewline,
        showFrame heap fptr,
        showStack stack,
        showValueStack vstack,
        showDump dump,
        iNewline
      ]
\end{verbatim}

showFrame は状態のフレーム コンポーネントを表示し、showClosure を使用してその内部の各クロージャを表示します。

\begin{verbatim}
  showFrame :: TimHeap -> FramePtr -> Iseq
  showFrame heap FrameNull = iStr "Null frame ptr" `iAppend` iNewline
  showFrame heap (FrameAddr addr)
    = iConcat [
        iStr "Frame: <",
        iIndent (iInterleave iNewline
        (map showClosure (fList (hLookup heap addr)))),
        iStr ">", iNewline
      ]
  showFrame heap (FrameInt n)
    = iConcat [ iStr "Frame ptr (int): ", iNum n, iNewline ]
\end{verbatim}

\texttt{showStack}は引数スタックを表示し、\texttt{showClosure}を使用して各クロージャを表示します。

\begin{verbatim}
  showStack :: TimStack -> Iseq
  showStack stack
    = iConcat [ iStr "Arg stack: [",
        iIndent (iInterleave iNewline (map showClosure stack)),
        iStr "]", iNewline
      ]
\end{verbatim}

現時点では、値スタックとダンプを表示する\texttt{showValueStack}と\texttt{showDump}は、
状態のこれらのコンポーネントを使用していないため、現時点ではスタブです。

\begin{verbatim}
  showValueStack :: TimValueStack -> Iseq
  showValueStack vstack = iNil

  showDump :: TimDump -> Iseq
  showDump dump = iNil
\end{verbatim}

\texttt{showClosure}はクロージャを表示し、\texttt{showFramePtr}を使用してフレームポインタを表示します。

\begin{verbatim}
  showClosure :: Closure -> Iseq
  showClosure (i,f)
    = iConcat [ iStr "(", showInstructions Terse i, iStr ", ",
        showFramePtr f, iStr ")"
      ]

  showFramePtr :: FramePtr -> Iseq
  showFramePtr FrameNull     = iStr "null"
  showFramePtr (FrameAddr a) = iStr (show a)
  showFramePtr (FrameInt n)  = iStr "int " `iAppend` iNum n
\end{verbatim}

\texttt{showStats}は、蓄積された統計を出力します。

\begin{verbatim}
  showStats :: TimState -> Iseq
  showStats (instr, fptr, stack, vstack, dump, heap, code, stats)
    = iConcat [ iStr "Steps taken = ", iNum (statGetSteps stats), iNewline,
                iStr "No of frames allocated = ", iNum (hSize heap),
                iNewline
      ]
\end{verbatim}

\textbf{命令の表示}
\vskip\baselineskip

命令と命令シーケンスを表示する必要があります。
一連の命令が1つの長い行として出力されると、かなり読みにくくなるため、それらをきれいに出力するコードを作成する価値があります。
\vskip\baselineskip

実際、命令シーケンスのコード全体(たとえば、スーパーコンビネータの定義を出力する場合)を出力できるようにするか、
一部の省略形だけを出力できるようにしたいと考えています。
後者の例は、スタックの内容を表示するときに発生します。
各クロージャのコードの一部を確認することは役に立ちますが、すべてを確認する必要はありません。
したがって、各関数に追加の引数\texttt{d}を与えて、どの程度完全に出力するかを伝えます。
この引数の値は、\texttt{Full}、\texttt{Terse}、または\texttt{None}のいずれかです。

\begin{verbatim}
  data HowMuchToPrint = Full | Terse | None
\end{verbatim}

\texttt{showInstructions}は命令のリストを\texttt{iseq}に変換します。
\texttt{d}が\texttt{None}の場合、省略記号のみが出力されます。
\texttt{d}が\texttt{Terse}の場合、命令はすべて1行に出力され、ネストされた命令は\texttt{d}を\texttt{None}として出力されます。
\texttt{d}が\texttt{Full}の場合、命令は1行に1つずつレイアウトされ、完全に出力されます。

\begin{verbatim}
  showInstructions :: HowMuchToPrint -> [Instruction] -> Iseq
  showInstructions None il = iStr "{..}"
  showInstructions Terse il
    = iConcat [iStr "{", iIndent (iInterleave (iStr ", ") body), iStr "}"]
      where
        instrs = map (showInstruction None) il
        body | length il <= nTerse = instrs
             | otherwise           = (take nTerse instrs) ++ [iStr ".."]
  showInstructions Full il
    = iConcat [iStr "{ ", iIndent (iInterleave sep instrs), iStr " }"]
      where
        sep = iStr "," `iAppend` iNewline
        instrs = map (showInstruction Full) il
\end{verbatim}

\texttt{showInstruction}は、単一の命令を\texttt{iseq}に変換します。

\begin{verbatim}
  showInstruction d (Take m)  = (iStr "Take ")  `iAppend` (iNum m)
  showInstruction d (Enter x) = (iStr "Enter ") `iAppend` (showArg d x)
  showInstruction d (Push x)  = (iStr "Push ")  `iAppend` (showArg d x)

  showArg d (Arg m)      = (iStr "Arg ")      `iAppend` (iNum m)
  showArg d (Code il)    = (iStr "Code ")     `iAppend` (showInstructions d il)
  showArg d (Label s)    = (iStr "Label ")    `iAppend` (iStr s)
  showArg d (IntConst n) = (iStr "IntConst ") `iAppend` (iNum n)
\end{verbatim}

\texttt{nTerse}は、シーケンスのいくつの命令を簡潔な形式で出力する必要があるかを示します。

\begin{verbatim}
  nTerse = 3
\end{verbatim}

\begin{description}
	\item[演習 4.1] \texttt{main}の次の定義を使用してマシンを実行します。
		\begin{verbatim}
          main = S K K 4
        \end{verbatim}
		\texttt{S K K}は恒等関数であるため、\texttt{main}は\texttt{4}に減少し、マシンが停止します。
		もう少し手の込んだものにしてみてください。
		例えば
		\begin{verbatim}
          id = S K K ;
          id1 = id id ;
          main = id1 4
        \end{verbatim}
	\item[演習 4.2] さらなる性能測定を追加します。
		例えば：
		\begin{itemize}
			\item 実行時間を測定し、\texttt{Take}を除く命令ごとに1つの時間単位をカウントします。
			      \texttt{Take}は、フレームに含まれる要素と同じ数の時間単位をカウントする必要があります。
			\item 実行で割り当てられたヒープの合計量を出力して、ヒープ使用量を測定します。
			      フレームのサイズを数えて、結果をテンプレートインスタンス化バージョンの結果と直接比較できるようにします。
			\item 最大スタック深さを測定します。
		\end{itemize}
	\item[演習 4.3] $n = 0$の場合、\texttt{Take} $n$は何も役に立ちません。
		CAFの\texttt{Take}命令を完全に省略することで、\texttt{compileSC}の定義を調整して、この最適化を見つけます。
\end{description}

\subsubsection{ガベージコレクション \dag}

ヒープベースのシステムと同様に、TIMにはガベージコレクタが必要ですが、少し洗練されたものも必要です。
いつものように、ガベージコレクタはマシンの状態から開始して、すべてのライブデータを検出します。
つまり、スタックとフレームポインタからです。
スタック上の各クロージャはフレームを指しており、明確に保持する必要があります。
しかし、そのフレームには、さらに別のフレームへのポインタが含まれています。
問題が発生します: \textbf{特定のフレームが与えられた場合、その中のどのフレームポインタを再帰的に追跡する必要がありますか?}
\vskip\baselineskip

安全な答えは「それらすべてに従う」ことですが、これには必要以上のデータを保持するリスクがあります。
たとえば、セクション4.1.4の\texttt{compose2}の例の\texttt{(g x x)}のクロージャには、
\texttt{f}、\texttt{g}、および\texttt{x}を含むフレームへのポインタがありますが、\texttt{g}と\texttt{x}のクロージャのみが必要です。
ナイーブなガベージコレクタは、\texttt{f}のクロージャからのフレームポインタもたどり、データを不必要に保持する可能性があります。
この不要な保持は\textbf{スペースリーク}と呼ばれ、ガベージコレクションが他の場合よりも頻繁に発生する可能性があります。
\vskip\baselineskip

ただし、この特定のスペースリークは、かなり面倒ではありますが、解消するのは簡単です。
各クロージャは、フレームポインタとペアになったコードポインタで構成されます。
コードは、どのフレーム要素が必要になるかを「認識」しており、この情報をコードに記録して、ガベージコレクターが調査できるようにします。
たとえば、コードポインタと呼んでいるものは、実際には、コードで使用されるスロット番号のリストとコード自体で構成されるペアを指している可能性があります。
(実際の実装では、リストはビットマスクとしてエンコードされる場合があります。)
有用なスロットのリストはどのように導出できますか?
それは簡単です: コンパイルされている式の自由変数を見つけ、環境を使用してそれらをスロット番号にマップするだけです。
\newpage

\subsection{Mark 2: 算術演算の追加}

このセクションでは、マシンに算術演算を追加します。

\subsubsection{概要: 算術演算の仕組み}

オリジナルの Fairbairn と Wray の TIM マシンは、算術を行うためのかなり悪質なスキームを持っていました。
彼らの主な動機は、マシンを\textbf{最小限}に抑えることでしたが、彼らのアプローチは非常に理解しにくく、
効率的な実装を行うにはかなりの修正が必要です。
\vskip\baselineskip

代わりに、GマシンのVスタックとまったく同じようにTIMを変更します (セクション 3.9)。
(評価され、ボックス化されていない)整数のスタックである\textbf{値スタック}を導入することにより、状態を変更します。
値スタックの最上位要素で算術演算$op$を実行し、値スタックの最上位に結果を残す命令\texttt{Op} $op$ファミリーで命令セットを拡張します。
たとえば、\texttt{Op Sub}命令は、値スタックの上位2つの要素を削除し、それらを減算して、結果を値スタックにプッシュします。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r l l|} \hline
	(4.10) &                   & \texttt{Op} \texttt{Sub} : $i$ & $f$ & $s$ & $n_1$ : $n_2$ : $v$ & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                            & $f$ & $s$ & $(n_1 - n_2)$ : $v$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

このようにして、\texttt{Op Add}、\texttt{Op Sub}、\texttt{Op Mult}、\texttt{Op Div}、\texttt{Op Neg}などの
算術命令の完全なファミリを簡単に定義できます。
\vskip\baselineskip

次に、以下の関数\texttt{sub}を考えてみましょう。

\begin{verbatim}
  sub a b = a - b
\end{verbatim}

\texttt{sub}用にどのコードを生成する必要がありますか?
次の手順を実行する必要があります。

\begin{enumerate}
	\item 引数をフレームに形成する通常の\texttt{Take 2}。
	\item \texttt{b}を評価し、その値を値スタックに置きます。
	\item 同様にして\texttt{a}を評価します。
	\item \texttt{Op Sub}命令を使用して\texttt{a}の値から\texttt{b}の値を引き、その結果を値スタックの一番上に残します。
	\item 「呼び出し元」に「戻る」。
\end{enumerate}

まず、\texttt{a}と\texttt{b}の評価を考えます。
それらはクロージャによって表され、現在のフレームに保持されます。クロージャに対してできることは、それを入力することだけです。
おそらく\texttt{a}を評価するには、\texttt{a}のクロージャを入力する必要がありますが、整数値のクロージャを入力するとはどういう意味でしょうか?
これまで関数を入力しただけで、整数は関数ではありません。
重要なアイデアは次のとおりです。

\begin{quote}
	整数不変: \textbf{整数値のクロージャが入力されると、整数の値が計算され、それが値スタックにプッシュされ、引数スタックの一番上のクロージャが入力されます。}
\end{quote}

引数スタックの一番上にあるクロージャは、整数の評価が完了したら次に何をすべきかを示しているため、\textbf{継続}と呼ばれます。
継続は、整数の評価が完了したときに何をすべきかを示す命令シーケンスと、現在のフレームポインタ(整数の評価によって妨害された場合)で構成されます。
つまり、継続は完全に通常のクロージャです。
\vskip\baselineskip

したがって、\texttt{sub}のコードは次のようになります。

\begin{verbatim}
  sub: Take 2
       Push (Label L1)  -- Push the continuation
       Enter (Arg 2)    -- Evaluate b

  L1:  Push (Label L2)  -- Push another continuation
       Enter (Arg 1)    -- Evaluate a

  L2:  Op Sub           -- Compute a-b on value stack
\end{verbatim}

\texttt{Return}命令は何をすべきですか？
\texttt{sub}によって返される値は整数であり、\texttt{Op Sub}命令の後、この整数は値スタックの一番上にあるため、
\texttt{Return}がしなければならないことは、引数スタックの一番上にクロージャをポップして入力することだけです。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r l l|} \hline
	(4.11) &                   & [\texttt{Return}] & $f$  & ($i'$, $f'$) : $s$ & $v$ & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i'$              & $f'$ & $s$                & $v$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

ラベルを使用して、\texttt{sub}のコードを記述しました。
これが唯一の方法ではありません。
別の方法として、\texttt{Push Code}命令を使用する方法があります。
これにより、面倒な新しいラベルを作成する必要がなくなります。
このスタイルでは、\texttt{sub}のコードは次のようになります。

\begin{verbatim}
  sub: Take 2
       Push (Code [ Push (Code [Op Sub, Return]),
                    Enter (Arg 1)
            ])
       Enter (Arg 2)
\end{verbatim}

このように書かれていると、ラベルを使用するよりも何が起こっているかを確認するのが簡単ではないため、
コードの断片を理解しやすくするために説明では引き続きラベルを使用しますが、
コンパイラでは\texttt{Push Code}バージョンを使用します。
\vskip\baselineskip

ここで、整数定数の問題に戻る必要があります。
\texttt{(sub 4 2)}という式を考えてみましょう。
以下のコードにコンパイルされます

\begin{verbatim}
  Push (IntConst 2)
  Push (IntConst 4)
  Enter (Label "sub")
\end{verbatim}

\texttt{sub}のコードはすぐにクロージャ\texttt{(IntConst 2)}に入り、フレームポインタに整数\texttt{2}を配置して\texttt{intCode}にジャンプします。
現在、\texttt{intCode}は空のコードシーケンスです(整数を Enter するとマシンが停止します)が、これを変更する必要があります。
\texttt{intCode}は今何をすべきか?
答えは整数不変式によって与えられます: 整数を値スタックにプッシュして返す必要があるため、次のようになります。

\begin{verbatim}
  intCode = [PushV FramePtr, Return]
\end{verbatim}

\texttt{PushV FramePtr}は、現在フレームポインタとして偽装されている数値を値スタックの一番上にプッシュする新しい命令です。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r l l|} \hline
	(4.12) &                   & \texttt{PushV FramePtr} : $i$ & $n$ & $s$ & $v$       & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                           & $n$ & $s$ & $n$ : $v$ & $h$ & $c$ \\ \hline
\end{tabular}

\subsubsection{実装への単純な算術演算の追加}

これで、実装を変更する準備が整いました。 各算術関数のコードを\texttt{compiledPrimitives}に追加することで、変更を最小限に抑えます。
プログラムで(たとえば)\texttt{p-q}と書くと、パーサはそれを次のように変換することを思い出してください。

\begin{verbatim}
  EAp (EAp (EVar "-") (EVar "p")) (EVar "q")
\end{verbatim}

プリミティブ\texttt{-}に適したコードを作成し、このコードをコードストアに追加するだけです。
コンパイラは、他のスーパーコンビネータと同じように\texttt{-}を扱います。
最後に、必要な\texttt{-}のコードは、前のセクションで作成した\texttt{sub}とまったく同じであり、
他の算術演算についても同様のコードを簡単に作成できます。
\vskip\baselineskip

したがって、必要な手順は次のとおりです。

\begin{itemize}
	\item 次の型定義と値スタックの初期化を追加します。
	      \begin{verbatim}
          type TimValueStack = [Int]
          initialValueStack = []
        \end{verbatim}
	\item 新しい命令\texttt{PushV}、\texttt{Return}、および\texttt{Op}を\texttt{instruction}型に追加します。
	      この機会に、\texttt{Cond}という命令を1つ追加します。これについてはまだ説明していませんが、後の演習の対象となります。
	      TIMはもはや3命令マシンではありません！
	      \begin{verbatim}
          data Instruction = Take Int
                           | Push TimAMode
                           | PushV ValueAMode
                           | Enter TimAMode
                           | Return
                           | Op Op
                           | Cond [Instruction] [Instruction]
          data Op = Add | Sub | Mult | Div | Neg
                  | Gr | GrEq | Lt | LtEq | Eq | NotEq
                deriving (Eq) -- KH
        \end{verbatim}
	      これまでのところ、\texttt{PushV}命令の引数は\texttt{FramePtr}のみですが、
	      リテラル定数を値スタックにプッシュできるようにする2番目の形式をすぐに追加します。
	      したがって、\texttt{valueAMode}の代数データ型を宣言する価値があります。
	      \begin{verbatim}
          data ValueAMode = FramePtr
                          | IntVConst Int
        \end{verbatim}
	      この追加構造を処理するには、\texttt{showInstruction}関数を変更する必要があります。
	\item \texttt{step}関数を変更して、追加の命令を実装します。
	      これは、状態遷移規則をMirandaに翻訳する問題です。
	\item \texttt{+}、\texttt{-}などの適切な定義を\texttt{compiledPrimitives}に追加します。
	\item \texttt{intCode}が空でなくなったので、スタックを初期化して、
	      \texttt{main}が戻るための適切な継続(戻りアドレス)を持たせる必要があります。
	      これを行う方法は、\texttt{initialArgStack}を再定義することにより、
	      \texttt{compile}にクロージャ\texttt{([], FrameNull)}でスタックを初期化させることです。
	      \begin{verbatim}
          initialArgStack = [([], FrameNull)]
        \end{verbatim}
	      この継続には空のコードシーケンスがあるため、マシンは結果を値スタックの上に置いて停止します。
\end{itemize}

\begin{description}
	\item[演習 4.4] これらの変更をプロトタイプに実装します。
		簡単な例で試してみてください。
		例えば
		\begin{verbatim}
          four = 2 * 2
          main = four + four
        \end{verbatim}
	\item[演習 4.5] まだ条件式がなく、条件式がなければ再帰を使用できないため、まだ「興味深い」プログラムを実行できません。
		簡単な解決策は、新しい命令\texttt{Cond i1 i2}を追加することです。
		この命令は、値スタックの一番上から値を削除し、それがゼロかどうかをチェックし、
		ゼロである場合は命令シーケンス\texttt{i1}を続行し、そうでない場合は\texttt{i2}を続行します。
		その状態遷移規則は次のとおりです。
		\vskip\baselineskip
		\begin{tabular} {|c|l r l r r l l|} \hline
			(4.13) &                   & [\texttt{Cond} ~ $i_1$ ~ $i_2$]          & $f$ & $s$ & $0$ : $v$ & $h$ & $c$ \\
			       & $\Longrightarrow$ & $i_1$                                    & $f$ & $s$ & $v$       & $h$ & $c$ \\ \hline
			       &                   & [\texttt{Cond} ~ $i_1$ ~ $i_2$]          & $f$ & $s$ & $n$ : $v$ & $h$ & $c$ \\
			(4.13) & $\Longrightarrow$ & $i_2$                                    & $f$ & $s$ & $v$       & $h$ & $c$ \\
			       &                   & \multicolumn {6} {l|} {ここで$n \neq 0$}                                     \\ \hline
		\end{tabular}
		\vskip\baselineskip
		最初のルールは、ゼロが値スタックの一番上にある場合に一致します。
		それ以外の場合は、2番目の規則が適用されます。
		次のように動作するプリミティブ\texttt{if}も追加する必要があります。
		\begin{verbatim}
          if 0 t f = t
          if n t f = f
        \end{verbatim}
		\texttt{Cond}命令を使用して\texttt{if}のTIMコードを作成し、それを\texttt{compiledPrimitives}に追加する必要があります。
		最後に、階乗関数を使用して改善されたシステムをテストできます。
		\begin{verbatim}
          factorial n = if n 1 (n * factorial (n-1))
          main = factorial 3
        \end{verbatim}
\end{description}

\subsubsection{算術演算のコンパイルスキーム}

Gマシンの場合と同様に、現在行っているマシン用のコンパイルよりもはるかに優れた仕事を行うことができます。
次のような関数を考えてみましょう

\begin{verbatim}
  f x y z = (x+y) * z
\end{verbatim}

現状では、これは次のように解析されます

\begin{verbatim}
  f x y z = * (+ x y) z
\end{verbatim}

\texttt{f}のコードがコンパイルされ、標準関数\texttt{*}および\texttt{+}が呼び出されます。
しかし、これよりもはるかに良いことができます!
たとえば、\texttt{(+ x y)}のクロージャを作成して\texttt{*}に渡す代わりに、次の手順を使用してインラインで操作を行うことができます。

\begin{enumerate}
	\item \texttt{x}を評価する
	\item \texttt{y}を評価する
	\item それらを加算する
	\item \texttt{z}を評価する
	\item 乗算する
	\item 戻る
\end{enumerate}

クロージャを構築する必要はなく、ジャンプを行う必要もありません
(\texttt{x}、\texttt{y}、\texttt{z}を評価するために必要なものを除く)。
\vskip\baselineskip

この改善を表現するために、値が整数である式を処理する新しいコンパイルスキーム、$\mathcal{B}$スキームを導入します。
次のように定義されます: 値が整数である任意の式$e$と、任意のコード シーケンス$cont$に対して、

\begin{quotation}
	\textbf{$(\mathcal{B} \llbracket e \rrbracket ~ \rho ~ cont)$は、
		現在のフレームが$\rho$で記述されているようにレイアウトされた状態で実行されると、
		式$e$の値を値スタックにプッシュしてから、コードシーケンス$cont$を実行するコードシーケンスです。}
\end{quotation}

コンパイルスキームは\textbf{継続渡しスタイル}を使用します。
このスタイルでは、$cont$引数が、値が計算された後に何をすべきかを示します。
\vskip\baselineskip

図4.2は、改訂された$\mathcal{R}$および$\mathcal{A}$スキームと共に、$\mathcal{B}$コンパイルスキームを示しています。
$\mathcal{R}$が算術式である式を見つけると、それをコンパイルするために$\mathcal{B}$を呼び出します。
$\mathcal{B}$には、継続を明示的にプッシュすることを回避する、定数および算術演算子の適用に関する特殊なケースがあります。
特別に処理できない式に遭遇した場合は、継続をプッシュして$\mathcal{R}$を呼び出すだけです。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho$は、環境$\rho$の式$e$の値をスタック上の引数に適用するTIMコードです。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{R} \llbracket e \rrbracket ~ \rho$         & $=$ & $\mathcal{B} \llbracket e \rrbracket ~ \rho$ [\texttt{Return}]                                                           \\
		                                                     &     & ここで、$e$は$e_1 + e_2$などの算術式、または数値です。                                                                   \\
		$\mathcal{R} \llbracket e_1 ~ e_2 \rrbracket ~ \rho$ & $=$ & \texttt{Push} ($\mathcal{A} \llbracket e_2 \rrbracket ~ \rho$) \texttt{:} $\mathcal{R} \llbracket e_1 \rrbracket ~ \rho$ \\
		$\mathcal{R} \llbracket a \rrbracket ~ \rho$         & $=$ & \texttt{Enter} ($\mathcal{A} \llbracket a \rrbracket ~ \rho$)                                                            \\
		                                                     &     & ここで、$a$ は整数、変数、またはスーパーコンビネータです。                                                               \\
	\end{tabular}
	\\ \hline
	$\mathcal{A} \llbracket e \rrbracket ~ \rho$は、環境$\rho$における式$e$のTIMアドレッシングモードです。           \\
	\\
	\begin{tabular}{r c l l}
		$\mathcal{A} \llbracket x \rrbracket ~ \rho$ & $=$ & $\rho ~ x$                                                   & ここで、$x$ は $\rho$ によって束縛されます。 \\
		$\mathcal{A} \llbracket n \rrbracket ~ \rho$ & $=$ & \texttt{IntConst} $n$                                        & ここで、$n$ は整数定数です。                 \\
		$\mathcal{A} \llbracket e \rrbracket ~ \rho$ & $=$ & \texttt{Code} ($\mathcal{R} \llbracket e \rrbracket ~ \rho$) & その他                                       \\
	\end{tabular}
	\\ \hline
	$\mathcal{B} \llbracket e \rrbracket ~ \rho$は、環境$\rho$で式$e$を評価して、                                    \\
	その値(整数でなければならない)を値スタックの一番上に置き、                                                       \\
	コード シーケンス$cont$を続行するTIMコードです。                                                                 \\
	\\
	\begin{tabular}{r c l l}
		$\mathcal{B} \llbracket e_1 \texttt{+} ~ e_2 \rrbracket ~ \rho ~ cont$ & $=$                                                                   & $\mathcal{B} \llbracket e_2 \rrbracket ~ \rho ~ (\mathcal{B} \llbracket e_1 \rrbracket ~ \rho ~ (\texttt{Op Add :} ~ cont))$ &                         \\
		                                                                       & \multicolumn {3} {l} {$\ldots$および他の算術プリミティブの同様の規則}                                                                                                                                                          \\
		$\mathcal{B} \llbracket n \rrbracket ~ \rho ~ cont$                    & $=$                                                                   & $\texttt{PushV} ~ (\texttt{IntVConst} ~ n) ~ \texttt{:} ~ cont$                                                              & ここで、$n$は数値です。 \\
		$\mathcal{B} \llbracket e \rrbracket ~ \rho$                           & $=$                                                                   & \texttt{Push} (\texttt{Code} $cont$) \texttt{:} $\mathcal{R} \llbracket e \rrbracket ~ \rho$                                 & その他                  \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

必要な新しい命令が1つあります。これは、$\mathcal{B}$が定数をコンパイルするように要求されたときに使用されます。
その時には、整数定数を値スタックにプッシュする命令\texttt{PushV} (\texttt{IntVConst} $n$)が必要です。
その遷移規則は非常に単純です。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r l l|} \hline
	(4.14) &                   & \texttt{PushV} (\texttt{IntVCont} $n$) : $i$ & $f$ & $s$ & $v$       & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                                          & $f$ & $s$ & $n$ : $v$ & $h$ & $c$ \\ \hline
\end{tabular}

\begin{description}
	\item[演習 4.6] 改善されたコンパイル スキームを実装します。
		実装のパフォーマンスを以前のパフォーマンスと比較します。
	\item[演習 4.7] $\mathcal{R}$スキームに新しいルールを追加して、\texttt{if}の(完全な)アプリケーションに一致させます。
		\texttt{if}プリミティブを呼び出して取得するよりもはるかに優れたコードを生成できるはずです。
		変更を実装し、パフォーマンスの改善を測定します。
	\item[演習 4.8] 次のように、より一般的な算術比較を処理するために条件を一般化するとします。
		\begin{verbatim}
          fib n = if (n < 2) 1 (fib (n-1) + fib (n-2))
        \end{verbatim}
		必要なのは、値スタックの上位2つの項目をポップし、それらを比較し、比較の結果に応じて値スタックに1または0をプッシュする新しい命令\texttt{Op Lt}です。
		次に、\texttt{Cond}命令がこの結果を検査します。

		このような比較命令のファミリを実装し、他の算術演算子とまったく同じ方法で、それらの特殊なケースを$\mathcal{B}$スキームに追加します。
		あなたの改善をテストします。
	\item[演習 4.9] 前の練習問題で、追加の比較モードを持つように\texttt{Cond}命令を変更しなかった理由を疑問に思ったかもしれません。
		次に、このモードに従って値スタックの上位2つの項目を比較し、それに応じて動作します。
		なぜこれをしなかったのですか？
		ヒント: このようなプログラムはどうなるでしょうか?
		\begin{verbatim}
          multipleof3 x = ((x / 3) * 3) == x
          f y = if (multipleof3 y) 0 1
        \end{verbatim}
\end{description}
このセクションの内容は[Argo 1989]で説明されており、[Peyton Jones 1987]の第20章で説明されている改良されたGマシンコンパイルスキームに正確に対応しています。
\newpage

\subsection{Mark 3: \texttt{let(rec)}式}

現在、コンパイラは\texttt{let(rec)}式を処理できません。
これは、このセクションで解決する問題です。
2つの主要な新しいアイデアが導入されました。

\begin{itemize}
	\item \texttt{Take}命令を変更して、余分なスペースをフレームに割り当てて、\texttt{let(rec)}束縛変数と仮パラメータを含めます。
	\item \textbf{間接クロージャ}の考え方を紹介します。
\end{itemize}

\subsubsection{\texttt{let}式}

\texttt{let}式をコンパイルするとき、定義の右側の新しいクロージャを構築するコードを生成する必要があります。
これらの新しいクロージャはどこに配置する必要がありますか?
\texttt{let(rec)}で束縛された名前を引数名と同じように扱うには、それらを現在のフレームに配置する必要があります
\footnote{このセクションの資料のヒントは [Wakeling and Dix 1989] にありますが、完全には解明されていません。}。
これには、ランタイム機構に2つの変更が必要です。

\begin{itemize}
	\item \texttt{Take}命令は、スーパーコンビネータの実行中に発生する
	      すべての\texttt{let}定義のクロージャを含むのに十分な大きさのフレームを割り当てる必要があります。
	      \texttt{Take}命令は、$\texttt{Take} ~ t ~ n$ の形式に変更する必要があります。
	      ここで、$t ~ \ge ~ n$ です。
	      この命令は、サイズ$t$のフレームを割り当て、スタックの一番上から$n$個のクロージャを取得し、それらをフレームの最初の$n$個の場所に配置します。
	\item 新しいクロージャ$a$を現在のフレームのスロット$i$に移動するには、新しい命令$\texttt{Move} ~ i ~ a$が必要です。
	      ここで$a$は、\texttt{Push}および\texttt{Enter}と同様に\texttt{timAMode}型です。
\end{itemize}

たとえば、次の定義です。

\begin{verbatim}
  f x = let
          y = f 3
        in
          g x y
\end{verbatim}

これは次のコードにコンパイルされます。

\begin{verbatim}
  [ Take 2 1,
    Move 2 (Code [Push (IntConst 3), Enter (Label "f")]),
    Push (Arg 2),
    Push (Arg 1),
    Enter (Label "g")
  ]
\end{verbatim}

もう少し複雑な例を次に示します。

\begin{verbatim}
  f x = let
          y = f 3
        in
          g (let z = 4 in h z) y
\end{verbatim}

これは次のコードを生成します：

\begin{verbatim}
  [ Take 3 1,
    Move 2 (Code [Push (IntConst 3), Enter (Label "f")]),
    Push (Arg 2),
    Push (Code [Move 3 (IntConst 4), Push (Arg 3), Enter (Label "h")]),
    Enter (Label "g")
  ]
\end{verbatim}

スーパーコンビネータ本体のクロージャが必要とする\textbf{すべての}スロットに、最初の\texttt{Take}がスペースを割り当てる方法に注目してください。

\begin{description}
	\item[演習 4.10] 新しい\texttt{Take}および\texttt{Move}命令の状態遷移規則を記述します。
\end{description}

次に、新しい\texttt{Take}命令と\texttt{Move}命令を生成するようにコンパイラを変更する必要があります。
\texttt{let}式に遭遇した場合、フレーム内の空きスロットを各バインド変数に割り当てる必要があるため、
フレーム内のどのスロットが使用中で、どのスロットが空きであるかを追跡する必要があります。
これを行うには、追加のパラメータ$d$を各コンパイル スキームに追加して、$d+1$以降のフレームスロットが空いていることを記録しますが、
1から$d$までのスロットは占有される可能性があることを記録します。
\vskip\baselineskip

残りの複雑な点は、最初の\texttt{Take}命令で十分な大きさのフレームを割り当てることができるように、$d$が取り得る最大値を発見する必要があることです。
これには、各コンパイルスキームが、コンパイルされたコードと$d$によって取得される最大値のペアを返す必要があります。
新しいコンパイルスキームを図4.3に示します。
(この図とその後で、$is_1 ~ \texttt{++} ~ is_2$という表記を使用して、命令シーケンス$is_1$と$is_2$の連結を示します。)
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{SC} \llbracket e \rrbracket ~ \rho$は、環境$\rho$でコンパイルされたスーパーコンビネータ定義$def$のTIMコードです。 \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{SC} \llbracket f ~ x_1 ~ \ldots ~ x_n ~ \texttt{=} ~ e \rrbracket ~ \rho$ & $=$ & \texttt{Take} $d'$ $n$ \texttt{:} $is$                                                                                                \\
		                                                                                    &     & ここで                                                                                                                                \\
		                                                                                    &     & $(d', ~ is) = \mathcal{R} \llbracket e \rrbracket ~ \rho[x_1 \mapsto \texttt{Arg} ~ 1, ~ \ldots, ~ x_n \mapsto \texttt{Arg} ~ n] ~ n$ \\
		                                                                                    &     & です。
	\end{tabular}
	\\ \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$は、ペア$(d', ~ is)$です。                                                  \\
	ここで、$is$は、環境$\rho$内の式$e$の値をスタック上の引数に適用するTIMコードです。                                          \\
	このコードは、フレームの最初の $d$ スロットが占有されていると想定しており、                                                 \\
	スロット $(d + 1 ~ ... ~ d')$ を使用します。                                                                                \\
	\\
	\begin{tabular}{r c l}
		$\mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$         & $=$ & $\mathcal{B} \llbracket e \rrbracket ~ \rho ~ d$ [\texttt{Return}]                                                      \\
		                                                         &     & ここで、$e$は$e_1 + e_2$などの算術式、または数値です。                                                                  \\
		\multicolumn{3}{l}{$\mathcal{R} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho ~ d$}       \\
		                                                         & $=$ & $(d', ~ \left[ \texttt{Move} ~ (d + 1) ~ am_1, ~ \ldots, ~ \texttt{Move} ~ (d + n) ~ am_n \right]$ ~ \texttt{++} ~ is)  \\
		                                                         &     & ここで                                                                                                                  \\
		                                                         &     & $(d_1, ~ am_1) = \mathcal{A} \llbracket e_1 \rrbracket ~ \rho ~ (d + n)$                                                \\
		                                                         &     & $(d_2, ~ am_2) = \mathcal{A} \llbracket e_2 \rrbracket ~ \rho ~ d_1$                                                    \\
		                                                         &     & $\ldots$                                                                                                                \\
		                                                         &     & $(d_n, ~ am_n) = \mathcal{A} \llbracket e_n \rrbracket ~ \rho ~ d_{n - 1}$                                              \\
		                                                         &     & $\rho' = \rho \left[x_1 ~ \mapsto ~ \texttt{Arg} ~ (d + 1), ~ \ldots , ~ x_n ~ \mapsto ~ \texttt{Arg} ~ (d + n)\right]$ \\
		                                                         &     & $(d', ~ is) = \mathcal{R} \llbracket e \rrbracket ~ \rho' ~ d_n$                                                        \\
		                                                         &     & です。                                                                                                                  \\
		$\mathcal{R} \llbracket e_1 ~ e_2 \rrbracket ~ \rho ~ d$ & $=$ & $(d_2, ~ \texttt{Push} ~ am \texttt{:} is)$                                                                             \\
		                                                         &     & ここで                                                                                                                  \\
		                                                         &     & $(d_1, ~ am) = \mathcal{A} \llbracket e_2 \rrbracket ~ \rho ~ d$                                                        \\
		                                                         &     & $(d_2, ~ is) = \mathcal{R} \llbracket e_1 \rrbracket ~ \rho ~ d_1$                                                      \\
		                                                         &     & です。                                                                                                                  \\
		$\mathcal{R} \llbracket a \rrbracket ~ \rho ~ d$         & $=$ & $(d', ~ \left[ \texttt{Enter} ~ am \right])$                                                                            \\
		                                                         &     & ここで、$a$ は整数、変数、またはスーパーコンビネータであり、                                                            \\
		                                                         &     & $(d', ~ am) = \mathcal{A} \llbracket a \rrbracket ~ \rho ~ d$ です。
	\end{tabular}
	\\ \hline
	$\mathcal{A} \llbracket e \rrbracket ~ \rho$は、ペア$(d', ~ am)$です。                                                      \\
	ここで、$am$は環境$\rho$における式$e$のTIMアドレッシングモードです。                                                        \\
	このコードは、フレームの最初の $d$ スロットが占有されていると想定しており、                                                 \\
	スロット $(d + 1 ~ ... ~ d')$ を使用します。                                                                                \\
	\\
	\begin{tabular}{r c l l}
		$\mathcal{A} \llbracket x \rrbracket ~ \rho ~ d$ & $=$ & $(d, ~ \rho ~ x)$                                                            & ここで、$x$ は $\rho$ によって束縛されます。 \\
		$\mathcal{A} \llbracket n \rrbracket ~ \rho ~ d$ & $=$ & $(d, ~ \texttt{IntConst} ~ n)$                                               & ここで、$n$ は整数です。                     \\
		$\mathcal{A} \llbracket e \rrbracket ~ \rho ~ d$ & $=$ & $(d', ~ \texttt{Code} ~ is)$                                                 & その他                                       \\
		                                                 &     & ここで、$(d', ~ is) = \mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$ です。
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

$\mathcal{SC}$スキームでは、スーパーコンビネータ本体のコンパイルから返された最大フレームサイズ$d'$を使用して、
実行する\texttt{Take}の大きさを決定する方法を確認できます。
$\mathcal{R}$スキームの\texttt{let}式の場合、定義ごとに命令$\texttt{Move} ~ i ~ a$を生成します。
ここで、$i$は現在のフレームの空きスロットの番号であり、$a$は$e$を$\mathcal{A}$スキームでコンパイルした結果です。
各右辺のコンパイルに、前の右辺によって占有されていた最後のスロットのインデックスが与えられる方法に注意してください。
これにより、すべての右辺が異なるスロットを使用することが保証されます。

\begin{description}
	\item[演習 4.11] このセクションで説明する変更を実装します。
		新しい命令を\texttt{instruction}型に追加し、新しいケースを\texttt{step}と\texttt{showInstruction}に追加してそれらを処理し、
		新しいコンパイルスキームを実装します。
	\item[演習 4.12] 以下のプログラムを検討します。
		\begin{verbatim}
          f x y z = let p = x+y in p+x+y+z
          main = f 1 2 3
        \end{verbatim}
		\texttt{let}式がない場合は、次のように補助関数を使用して記述する必要があります。
		\begin{verbatim}
          f' p x y z = p+x+y+z
          f x y z = f' (x+y) x y z
          main = f 1 2 3
        \end{verbatim}
		これら2つのプログラムによって生成されたコードを比較し、消費されたストアと実行されたステップの違いを測定します。
		\texttt{let}式を直接実装することで得られる主な節約は何ですか?
\end{description}

\subsubsection{\texttt{letrec}式}

\texttt{letrec} 式も処理するにはどうすればよいでしょうか?
最初はとても簡単に思えます。
$\mathcal{R}$ スキームの \texttt{letrec} ケースは、$am_i$ の定義で $\rho$ を $\rho'$ に置き換える必要があることを除いて、\texttt{let} ケースとまったく同じです。
これは、$x_i$ がそれぞれの右辺のスコープ内にあるためです。

\begin{description}
	\item[演習 4.13] この追加のケースを\texttt{compileR}に実装し、プログラム上で試してみます。
		\begin{verbatim}
    f x = letrec p = if (x==0) 1 q ;
                 q = if (x==0) p 2
          in p+q
    main = f 1
  \end{verbatim}
		生成されたコードを必ず理解し、テストしてください。
\end{description}

残念ながら、この実装には微妙なバグがあります。
以下から生成されたコードを考えてみましょう。

\begin{verbatim}
  f x = letrec a = b ;
               b = x
        in a
\end{verbatim}

それは次のとおりです。

\begin{verbatim}
  [Take 3 1, Move 2 (Arg 3), Move 3 (Arg 1), Enter (Arg 2)]
\end{verbatim}

\texttt{b} のクロージャは、2 番目の \texttt{Move} によって割り当てられる前に、最初の \texttt{Move} によってコピーされます。
\vskip\baselineskip

ここから抜け出す方法は 2 つあります。
まず最初に、これは愚かなプログラムであると宣言します。
\texttt{b} のバインディングのスコープ内で \texttt{b} を \texttt{x} に置き換えるだけです。
しかし、後で有益になり、上記のようなばかげたプログラムでも動作できるようにする、より興味深いアプローチがあります。
代わりに、最初の \texttt{Move} に対して次のコードを生成するとします。

\begin{verbatim}
  Move 2 (Code [Enter (Arg 3)])
\end{verbatim}

これですべてがうまくいきます。
\texttt{Enter (Arg 3)} が実行される前にスロット \texttt{3} が割り当てられます。
実際、クロージャ \texttt{([Enter (Arg 3)], f)} はフレーム \texttt{f} のスロット \texttt{3} への\textbf{間接指定}と考えることができます。
\vskip\baselineskip

このコードは、$\mathcal{R}$ コンパイル スキームの \texttt{let(rec)} ケースを変更することで取得できます。
これにより、\texttt{let(rec)} によってバインドされた変数ごとに環境内の間接アドレス指定モードが記録されます。
図 4.3 を参照すると、必要な変更は $\mathcal{R}$ スキームの \texttt{let} のルールに対するもので、$\rho'$ の定義は次のようになります。

\begin{center}
	\begin{tabular}{r c l}
		$\rho'$ & $=$ & $\rho[x_1 \mapsto \mathcal{I} \llbracket d + 1 \rrbracket, ~ \ldots, ~ x_n \mapsto \mathcal{I} \llbracket d + n \rrbracket]$ \\
		        &     & ここで $\mathcal{I}\llbracket d \rrbracket = \texttt{Code} ~ [\texttt{Enter} ~ (\texttt{Arg} ~ d)]$
	\end{tabular}
\end{center}

もちろん、これはかなり保守的です。
多くの場合、その必要がない場合に間接参照を返しますが、結果として得られるコードは、効率は劣るものの、引き続き正常に動作します。

\begin{description}
	\item[演習 4.14] このアイデアを実装するために\texttt{compileR}を変更し、上記の例に対して正しいコードが生成されることを確認します。
		新しい環境で間接アドレス指定モードを生成するには、\texttt{compileR} を変更する際に、
		補助関数 \texttt{mkIndMode} ($\mathcal{I}$ スキームに対応) を使用します。

		\begin{verbatim}
    mkIndMode :: Int -> TimAMode
    mkIndMode n = Code [Enter (Arg n)]
  \end{verbatim}
\end{description}

\subsubsection{フレームスロットの再利用 \dag}

現在、スーパーコンビネータ定義の右側にあるすべての定義は、フレーム内に独自のプライベート スロットを取得します。
場合によっては、異なる \texttt{let(rec)} 間でスロットを安全に共有できることがわかるかもしれません。
たとえば、次の定義を考えてみましょう。

\begin{verbatim}
  f x = if x (let ... in ...) (let ... in ...)
\end{verbatim}

2 つの \texttt{let} 式のうち 1 つだけが評価できることは明らかなので、それらの定義に同じスロットを使用しても完全に安全です。
\vskip\baselineskip

同様に、式 $e_1 ~ \texttt{+} ~ e_2$ では、$e_1$ の評価中に使用された \texttt{let(rec)} スロットは、$e_2$ が評価されるまでに終了します
(または、\texttt{+} がその引数を逆の順序で評価した場合はその逆になります)。
$e_1$ 内の \texttt{let(rec)} バインドされた変数は、$e_2$ 内の変数とスロットを共有できます。

\begin{description}
	\item[演習 4.15] これを見つけて利用できるようにコンパイラを変更してください。
\end{description}

\subsubsection{ガベージ コレクション \dag}

セクション 4.2.6 では、スペース リークを回避できるように、コード シーケンスによってどのフレーム スロットが使用されたかを記録することが望ましいと述べました。
Take が割り当てた追加のフレーム スロットを初期化しない場合、ガベージ コレクターがそのコンテンツを処理する危険があります。
これらの初期化されていないスロットは有効なポインターとして扱われ、予測できない結果が生じます。
最も簡単な解決策はすべてのスロットを初期化することですが、これには非常にコストがかかります。
セクション 4.2.6 の解決策を採用し、保持する必要があるスロットのリストを各コード シーケンスとともに記録する方が良いでしょう。
初期化されていないスロットは、ガベージ コレクターによって参照されることはありません。

\newpage

\subsection{Mark 4: 更新}

これまでのところ、共有 Redexes を繰り返し評価するため、グラフ簡約ではなくツリー簡約を実行してきました。
これを修正する時期が来ました。
TIM 更新を実行するさまざまな方法がどのように機能するかを正確に理解するのは少し難しいですが、少なくともプロトタイプの実装はあります。
そのため、私たちの開発は非常に具体的なものになります。

\subsubsection{基礎技術}

標準的なテンプレートインスタンス化マシンとGマシンは、簡約のたびに更新を実行します。
(Gマシンには末尾呼び出しがいくつか最適化されていますが、原理は同じです。)
TIMはスパインのないマシンであるため、その更新手法はかなり異なったものになる必要があります。
重要なアイデアは次のとおりです。

\begin{quote}
	G マシンとは異なり、簡約のたびに更新は実行されません。
	代わりに、クロージャの評価が開始されるとき (つまり、クロージャに入ったとき)、次の手順が実行されます。

	\begin{itemize}
		\item 現在のスタックと、入力されているクロージャのアドレスは、マシン状態の新しいコンポーネントであるダンプにプッシュされます。
		\item クロージャの評価が完了するとトリガーされる「マウストラップ」が設定されます。
		\item クロージャの評価は、空のスタックから開始して通常どおりに実行されるようになりました。
		\item マウストラップがトリガーされると、クロージャは通常の形式で更新され、古いスタックがダンプから復元されます。
	\end{itemize}

	「マウストラップ」は次のとおりです。
	クロージャの評価は新しいスタック上で実行されるため、\texttt{Return} 命令が空のスタックを見つけるか、
	スーパーコンビネータが適用される引数が少なすぎるため、評価は最終的に停止する必要があります。
	この時点で、式は (頭部) 正規形に達しているため、更新を実行する必要があります。
\end{quote}

まず、値が整数型であるクロージャの更新に焦点を当てましょう。
クロージャに入る直前に、新しい命令 \texttt{PushMarker} $x$ が実行されるようにします。
これにより、ダンプに情報をプッシュすることで更新メカニズムがセットアップされます。
具体的には、\texttt{PushMarker} $x$ はダンプにプッシュします
\footnote{TIM に関する論文では、この操作は「更新マーカーのプッシュ」と呼ばれることがよくあります。
	これは、「マーカー」の下にある引数を使用しようとすると更新がトリガーされるようにスタックが「マーク」されているためです。}。

\begin{itemize}
	\item 現在のスタック。
	\item 現在のフレーム ポインター。更新するクロージャーを含むフレームを指します。
	\item フレーム内で更新されるクロージャのインデックス $x$ 。
\end{itemize}

現在のスタックをダンプに保存したので、\texttt{PushMarker} は空のスタックを使用して続行します。
その状態遷移規則は次のとおりです。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r r l l|} \hline
	(4.15) &                   & \texttt{PushMarker} $x$ : $i$ & $f$ & $s$ & $v$ & $d$               & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                           & $f$ & []  & $v$ & $(f, x, s)$ : $d$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

しばらくすると、クロージャの評価が完了します。
その値は整数であるため、その値は値スタックの最上位にあり、スタックの最上位の継続に戻ることを期待して \texttt{Return} 命令が実行されます。
ただし、この時点ではスタックは空になります。
これが更新のトリガーです。ダンプがポップされ、更新が実行され、復元されたスタックを使用して \texttt{Return} 命令が再実行されます。
このアクションは、次の遷移規則によって説明されます。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r r l l|} \hline
	(4.16) &                   & [\texttt{Return}]                                                                                                     & $f$  & []              & $n$ : $v$ & $(f_u, x, s)$ : $d$ & $h$  & $c$ \\
	       & $\Longrightarrow$ & [\texttt{Return}]                                                                                                     & $f$  & $s$             & $n$ : $v$ & $d$                 & $h'$ & $c$ \\
	       &                   & \multicolumn {7} {l|} {ここで$h' = h[f_u : \langle \ldots, d_{x-1}, (\texttt{intCode}, n), d_{x+1}, \ldots \rangle]$}                                                                         \\ \hline
	(4.16) &                   & [\texttt{Return}]                                                                                                     & $f$  & $(i, f')$ : $s$ & $n$ : $v$ & $d$                 & $h$  & $c$ \\
	       & $\Longrightarrow$ & $i$                                                                                                                   & $f'$ & $s$             & $n$ : $v$ & $d$                 & $h$  & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

最初の遷移規則は、フレーム $f_u$ 内の $x$ 番目のクロージャの更新をクロージャ $(\texttt{intCode}, n)$ で記述します。
これは、入力するとすぐに $n$ を値スタックにプッシュして戻ります (セクション 4.3.1 を参照)。
さらに更新を実行する必要がある場合に備えて、\texttt{Return} 命令が再試行されることに注意してください。
これは、遷移規則の右辺のコードシーケンスが依然として [\texttt{Return}] であるという事実によって示されます。
\vskip\baselineskip

2番目の遷移規則は、遷移規則 4.11 を再度書き直したものです。
実行する更新がない場合についても説明します。
スタックの一番上の継続は、プログラムカウンタと現在のフレームポインタにロードされます。

\subsubsection{\texttt{PushMarker}命令のコンパイル}

このように、\texttt{PushMarker} 命令と \texttt{Return} 命令の実行は非常に簡単ですが、難しい問題は、コンパイラが \texttt{PushMarker} 命令をどこに配置するかということです。
これに答えるには、更新作業全体の動機を思い出す必要があります。評価後に Redex をその値で上書きすることで、各 Redex が1回だけ評価されるようにするためです。
TIM では、「redex」はクロージャです。
重要な洞察は次のとおりです。

\begin{quote}
	クロージャをコピーするときは非常に注意する必要があります。2 つのコピーが存在すると、それらの評価を共有することはできないからです。
\end{quote}

たとえば、次の関数定義を考えてみましょう。

\begin{verbatim}
  g x = h x x
  h p q = q - p
\end{verbatim}

現時点では、\texttt{g} に対して次のコードを生成します。

\begin{verbatim}
  [ Take 1 1, Push (Arg 1), Push (Arg 1), Enter (Label "h") ]
\end{verbatim}

2 つの \texttt{Push Arg} 命令はそれぞれ同じクロージャのコピーを取得し、その後 \texttt{h} はそれぞれを独立して評価します。
\vskip\baselineskip

私たちが本当にやりたいことは、\texttt{x} のクロージャの\textbf{コピー}ではなく、それ\textbf{へのポインタ}をプッシュすることです。
セクション 4.4.2 の\textbf{間接}クロージャのアイデアを思い出してください。
これは、\texttt{Push (Arg 1)} を \texttt{Push (Code [Enter (Arg 1)])} に置き換えることによって簡単に実行できます。
\vskip\baselineskip

これで半分まで進みました。 クロージャをコピーしていませんが、まだ更新していません。
でも今は簡単です！
必要なのは、\texttt{Enter (Arg 1)} 命令の前に \texttt{PushMarker 1} を置くことだけです。次のようになります。

\begin{verbatim}
  Push (Code [PushMarker 1, Enter (Arg 1)])
\end{verbatim}

つまり、共有クロージャに入る直前に、評価が完了したときに共有クロージャが更新されるようにする更新メカニズムをセットアップします。
\vskip\baselineskip

アドレッシング モード \texttt{(Code [PushMarker \textit{n}, Enter (Arg \textit{n})])} は、フレームの $n$ 番目のクロージャへの\textbf{間接更新}と呼ばれます。
これは、更新を実行させる間接であるためです。
引数を (スタックにプッシュするのではなく) 入力する場合にも、まったく同じ考慮事項が適用されます。
引数自体ではなく、引数への間接更新を入力する必要があります。
\texttt{Enter (Arg 1)} は \texttt{Enter (Code [PushMarker 1, Enter (Arg 1)])} に置き換える必要があります。
\vskip\baselineskip

コンパイルスキームの変更は簡単です。
$\mathcal{SC}$ スキームと $\mathcal{R}$ スキームのみが影響を受けますが、両方とも同じように影響を受けます。
つまり、環境を構築する場合、各変数を更新間接アドレス指定モードにバインドする必要があります。
たとえば、$\mathcal{R}$ スキームの \texttt{let(rec)} の場合、$\rho'$ に次の定義を使用します (図 4.3 を参照)。

\begin{center}
	\begin{tabular}{r c l}
		$\rho'$ & $=$ & $\rho[x_1 \mapsto \mathcal{J} \llbracket d + 1 \rrbracket, ~ \ldots, ~ x_n \mapsto \mathcal{J} \llbracket d + n \rrbracket]$   \\
		        &     & ここで $\mathcal{J}\llbracket d \rrbracket = \texttt{Code} ~ [\texttt{PushMarker} ~ d, ~ \texttt{Enter} ~ (\texttt{Arg} ~ d)]$
	\end{tabular}
\end{center}

\subsubsection{更新メカニズムの実装}

新しい更新メカニズムを実装するには、次の変更を加える必要があります。

\begin{itemize}
	\item ダンプの型定義を指定します。
	      これは単なるトリプルのスタックであり、リストとして表され、空に初期化されます。
	      \begin{verbatim}
          type TimDump = [(FramePtr, -- The frame to be updated
                           Int,      -- Index of slot to be updated
                           TimStack) -- Old stack
                         ]
          initialDump = []
        \end{verbatim}
	\item \texttt{PushMarker} 命令を \texttt{instruction} 型に追加し、命令を表示するために適切な変更を加えます。
	\item \texttt{step} に \texttt{PushMarker} 命令用の定義を追加し、\texttt{Return} 命令用の定義を変更します。
	\item 各変数を更新間接アドレッシング モードにバインドする環境を構築するには、\texttt{compileSC} と、\texttt{compileR} の \texttt{ELet} 命令用定義を変更します。
	      関数 \texttt{mkUpdIndMode} を使用して $\mathcal{J}$ スキームを実装します。
	      \begin{verbatim}
          mkUpdIndMode :: Int -> TimAMode
          mkUpdIndMode n = Code [PushMarker n, Enter (Arg n)]
        \end{verbatim}
\end{itemize}

\begin{description}
	\item[演習 4.16] 説明に従って更新メカニズムを実装します。
		いくつかのテスト プログラムで新しいシステムを実行すると、\texttt{PushMarker} が更新情報をダンプに追加し、\texttt{Return} が更新を実行するのを確認できるはずです。
		考えられるテスト プログラムの 1 つを次に示します。
		\begin{verbatim}
          f x = x + x
          main = f (1+2)
        \end{verbatim}
		\texttt{(1+2)} の評価は 1 回だけ行う必要があります。
	\item[演習 4.17] ここでは、実行できる簡単な最適化を示します。
		次のような関数の場合:
		\begin{verbatim}
          compose f g x = f (g x)
        \end{verbatim}
		\texttt{compose} のコードは次のようになっていることがわかります。
		\begin{verbatim}
          compose: Take 3 3
                   Push (Code [...])
                   Enter (Code [PushMarker 1, Enter (Arg 1)])
        \end{verbatim}
		ここで、\texttt{[...]} は \texttt{(g x)} のコードです。
		最後の命令は、\texttt{f} の間接更新に入ります。
		しかし、
		\begin{center}
			\texttt{Enter (Code \textit{i})} が \textit{i} と同等であること
		\end{center}
		は事実です。(これはルール 4.8 から直ちに導かれます。)
		したがって、\texttt{compose} の同等のコードは次のようになります。
		\begin{verbatim}
          compose: Take 3 3
                   Push (Code [...])
                   PushMarker 1
                   Enter (Arg 1)
        \end{verbatim}
		この最適化を実装します。
		これを行う最も良い方法は、コンパイラ内の \texttt{[Enter \textit{e}]} 形式のすべての式を \texttt{(mkEnter \textit{e})} に置き換えることです。
		ここで、\texttt{mkEnter} は次のように定義されます。
		\begin{verbatim}
          mkEnter :: TimAMode -> [Instruction]
          mkEnter (Code i) = i
          mkEnter other_am = [Enter other_am]
        \end{verbatim}
		\texttt{mkEnter} は \texttt{Enter} コンストラクタの「アクティブ」形式で、\texttt{Enter} 命令を生成する前に特殊なケースをチェックします。
\end{description}

このスキームには他にも多くの改善点があり、それについては次のセクションで検討します。

\subsubsection{間接更新の問題}

この更新メカニズムは非常に単純ですが、非常に非効率的です。
2 つの主な問題があり、それらは Argo [Argo 1989] によって初めて識別されました。
最初の問題は、\textbf{同一の更新}の問題です。
前のセクションで示したプログラムを考えてみましょう。

\begin{verbatim}
  f x = x+x
  main = f (1+2)
\end{verbatim}

\texttt{x} を使用するたびに、\texttt{f} はその引数 \texttt{x} への更新クロージャに入ります。
最初、\texttt{x} はその値で更新されます。
2 回目では、2 回目の (完全に冗長な) 更新が行われ、\texttt{x} がその値で再度上書きされます。
実装でサンプルを実行すると、これが起こるのを確認できるはずです。
\vskip\baselineskip

この場合、もちろん、賢いコンパイラは \texttt{x} が確実に評価されることを認識し、\texttt{x} に間接指定を入力する代わりに \texttt{x} をコピーするだけです。
しかし、これはコンパイラを複雑にし、一般的には検出することが不可能になる可能性があります。
たとえば、 \texttt{f} が次のように定義されたとします。

\begin{verbatim}
  f x = g x x
\end{verbatim}

\texttt{f} が \texttt{g} を分析して、さまざまな \texttt{x} がどの順序で評価されるかを発見しない限り(そして一般に、この質問に対する答えは 1 つだけではない可能性があります)、
悲観的に考えて、間接参照の更新を引数として \texttt{g} にプッシュする必要があります。
\vskip\baselineskip

2 番目の問題は、間接チェーンの問題です。
次のプログラムを検討してみましょう。

\begin{verbatim}
  g x = x+x
  f y = g y
  main = f (1+2)
\end{verbatim}

ここで、\texttt{f} は引数 \texttt{y} への更新間接演算を \texttt{g} に渡します。
ただし、 \texttt{g} は引数 \texttt{x} への間接更新を入力します。
したがって、 \texttt{g} は間接への間接に入ります。
つまり、\textbf{引数が別の関数の引数として渡されるたびに間接参照が追加される}ため、間接参照の連鎖が構築されます。
次の末尾再帰関数で \texttt{m} への間接演算がどれだけ多くなるかを想像してみてください。

\begin{verbatim}
  horrid n m = if (n==0) m (horrid (n-1) m)
\end{verbatim}

これらの問題はまだ解決しません。
代わりに、次のセクションでは、\texttt{let(rec)} バインドされた変数の更新を処理する方法と、これら 2 つの問題が発生しない理由を示します。
これは、スーパーコンビネータの引数についても、より良い解決策への道を示しています。

\subsubsection{\texttt{let(rec)}にバインドされた共有変数の更新}

これまで、 \texttt{let(rec)} でバインドされた変数は、常に間接更新アドレス指定モードを使用することにより、スーパーコンビネータの引数とまったく同じ方法で更新されると仮定してきました。
たとえば、次のスーパーコンビネータ定義を考えてみましょう。

\begin{verbatim}
  f x = let y = ...
        in
        g y y
\end{verbatim}

ここで、「\texttt{...}」は \texttt{y} の任意の右辺を表します。
\texttt{y} を \texttt{x} と同じように扱って、\texttt{f} に対して次のコードを生成します。

\begin{verbatim}
  f:    Take 2 1                                  -- Frame with room for y
        Move 2 (Code [...code for y...])          -- Closure for y
        Push (Code [PushMarker 2, Enter (Arg 2)]) -- Indirection to y
        Push (Code [PushMarker 2, Enter (Arg 2)]) -- Indirection to y
        Enter (Label "g")
\end{verbatim}

ここで、「\texttt{...code for y...}」は、\texttt{y} の右辺から生成されたコードを表します。
このコードには、前に概説した同一更新の問題があります。
\vskip\baselineskip

しかし、はるかに優れたソリューションがすぐに利用可能です。
代わりに \texttt{f} に対して次のコードを生成するとします。

\begin{verbatim}
  f:    Take 2 1 -- Frame with room for y
        Move 2 (Code (PushMarker 2 :
                      [...code for y...])) -- Closure for y
        Push (Code [Enter (Arg 2)]) -- Non-updating indirection to y
        Push (Code [Enter (Arg 2)]) -- Indirection to y
        Enter (Label "g")
\end{verbatim}

\texttt{PushMarker} 命令は、\texttt{y} の\textbf{使用}からその\textbf{定義}に移行しました。
\texttt{Move} 命令によって構築された \texttt{y} のクロージャは、\textbf{自己更新クロージャ}になりました。
つまり、入力すると、それ自体を更新する更新メカニズムがセットアップされます。
一度この問題が発生すると、\texttt{PushMarker} 命令を含むコードへのポインタが上書きされるため、二度と同じ問題が発生することはありません。
\vskip\baselineskip

一般に、考え方は次のとおりです。

\begin{itemize}
	\item コードを \texttt{PushMarker} 命令で始めることにより、\texttt{let(rec)} バインディングの右側に自己更新クロージャを使用します。
	\item \texttt{let(rec)} でバインドされた変数をスタックにプッシュする場合は、通常の (非更新) 間接アドレス指定モードを使用します。
	      クロージャが更新されるまでコピーすると重複した作業が発生するため、クロージャのコピーを取得するのではなく、間接指定を使用する必要があります。
\end{itemize}

このアイデアを実装するには次の変更が必要です。

\begin{itemize}
	\item \texttt{let(rec)} でバインドされた変数に対して\textbf{非更新}間接参照を生成するように $\mathcal{R}$ スキームを変更します。
	      つまり、 $\mathcal{J}$ ではなく $\mathcal{I}$ スキームを使用して新しい環境を構築します。
	      (現時点では、$\mathcal{SC}$ は スーパーコンビネータ引数に対して $\mathcal{J}$ を使用して\textbf{更新}間接を生成し続ける必要があります。)
	\item \texttt{let(rec)} 式の $\mathcal{R}$ スキームを変更して、すべての右辺のコードの先頭に \texttt{PushMarker} 命令を生成します。
	      これは、新しいコンパイル スキームである U スキーム (図 4.4 を参照) を作成することで最も簡単に実行できます。
	      これは、$\mathcal{R}$ スキームの \texttt{let(rec)} の場合に定義の右辺をコンパイルするために使用されます。
	      $\mathcal{U}$ には、現在のフレームのどのスロットを更新する必要があるかを示す追加の引数が必要であり、この引数を使用して適切な \texttt{PushMarker} 命令を生成します。
	      図 4.4 には、$\mathcal{R}$ スキームの修正された \texttt{let} 定義式も示されています。
	      \texttt{letrec} の場合の変更もまったく同様です。
\end{itemize}
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$U \llbracket e \rrbracket ~ u ~ \rho ~ d$ はペア $(d', ~ am)$ です。       \\
	ここで、$am$ は環境 $\rho$ における式 $e$ の TIM アドレッシングモードです。 \\
	$am$ によってアドレス指定されたクロージャが入力されると、                   \\
	現在のフレームのスロット $u$ が通常の形式で更新されます。                   \\
	このコードは、フレームの最初の $d$ スロットが占有されていると想定しており、 \\
	スロット $(d + 1, ~ \ldots, ~ d')$ を使用します。                           \\
	\\
	\begin{tabular}{r c l}
		$U \llbracket e \rrbracket ~ u ~ \rho ~ d$ & $=$ & $(d', ~ \texttt{Code} ~ (\texttt{PushMarker} ~ u ~ \texttt{:} ~ is))$ \\
		                                           &     & ここで                                                                \\
		                                           &     & $(d', ~ is) = \mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$         \\
		                                           &     & です。
	\end{tabular}
	\\ \hline
	\begin{tabular}{r c l}
		\multicolumn{3}{l}{$\mathcal{R} \llbracket \texttt{let} ~ x_1 ~ \texttt{=} ~ e_1\texttt{;} ~  \ldots \texttt{;} ~ x_n ~ \texttt{=} ~ e_n ~ \texttt{in} ~ e \rrbracket ~ \rho ~ d$} \\
		 & $=$ & $(d', ~ \left[ \texttt{Move} ~ (d + 1) ~ am_1, ~ \ldots, ~ \texttt{Move} ~ (d + n) ~ am_n \right]$ ~ \texttt{++} ~ is)                                                    \\
		 &     & ここで                                                                                                                                                                    \\
		 &     & $(d_1, ~ am_1) = \mathcal{U} \llbracket e_1 \rrbracket ~ (d + 1) ~ \rho ~ (d + n)$                                                                                        \\
		 &     & $(d_2, ~ am_2) = \mathcal{U} \llbracket e_2 \rrbracket ~ (d + 2) ~ \rho ~ d_1$                                                                                            \\
		 &     & $\ldots$                                                                                                                                                                  \\
		 &     & $(d_n, ~ am_n) = \mathcal{U} \llbracket e_n \rrbracket ~ (d + n) ~ \rho ~ d_{n - 1}$                                                                                      \\
		 &     & $\rho' = \rho \left[x_1 ~ \mapsto ~ \mathcal{I} \llbracket (d + 1) \rrbracket, ~ \ldots , ~ x_n ~ \mapsto ~ \mathcal{I} \llbracket (d + n) \rrbracket\right]$             \\
		 &     & $\mathcal{I} \llbracket d \rrbracket = \texttt{Code} ~ [\texttt{Enter} ~ (\texttt{Arg} ~ d)]$                                                                             \\
		 &     & $(d', ~ is) = \mathcal{R} \llbracket e \rrbracket ~ \rho' ~ d_n$                                                                                                          \\
		 &     & です。                                                                                                                                                                    \\
		\multicolumn{3}{l}{\texttt{letrec} の場合も同様ですが、$\rho'$ が $\rho$ の代わりに $\mathcal{U} \llbracket \rrbracket$ への呼び出しに渡される点が異なります。}
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

\begin{description}
	\item[演習 4.18] このアイデアを試して、どれだけのステップが節約されるかという点でその効果を測定してください。
	\item[演習 4.19] 次の表現を考えてみる
		\begin{verbatim}
          let x = 3 in x+x
        \end{verbatim}
		この場合、\texttt{let} 式の右側はすでに正規形式になっているため、$\mathcal{U}$ スキームで \texttt{PushMarker} 命令を生成する意味はありません。
		むしろ、この場合、$\mathcal{U}$ は単純に \texttt{IntConst} アドレッシング モードを返すことができます。

		$\mathcal{U}$ コンパイルスキームと対応する \texttt{compileU} 関数を変更し、変更が正しく動作することを確認します。
\end{description}

\subsubsection{間接チェーンの排除}

前のセクションの考え方は、\texttt{let(rec)} バインドされた変数の同一の更新を排除する方法を示しています。
このセクションでは、このアイデアを拡張してスーパーコンビネータ引数の同一の更新を排除し、同時に間接チェーンの問題を根絶する方法を示します。
このアイデアは Argo によって最初に提案されました [Argo 1989]。
\vskip\baselineskip

間接チェーンから始めます。
前に述べたように、スーパーコンビネータは引数クロージャをコピーしてはならないと想定する必要があるため、間接チェーンが構築されます。そのため、それらを複数回使用する場合は、間接を使用することをお勧めします。
多くの場合、引数クロージャーはすでに間接的であり、それをコピーしても完全に安全であるため、これにより間接チェーンが発生します。
\vskip\baselineskip

これは、別の戦略を示唆しています。

\begin{quote}
	すべての引数クロージャは、共有を失うことなく自由にコピー可能でなければならないという規則を採用します。
\end{quote}

この呼び出し規約は呼び出される関数にとって明らかに便利ですが、呼び出し元はどのようにしてそれが満たされていることを確認できるのでしょうか?
引数は次のいずれかです。

\begin{itemize}
	\item 定数。そのクロージャは自由にコピー可能です。
	\item スーパーコンビネータ。同じ特性があります。
	\item \texttt{let(rec)} でバインドされた変数。これも自由にコピーできます (前のセクションのアイデアを使用)。
	\item 現在のスーパーコンビネータへの引数。新しい規約により自由にコピーできます。
	\item 非アトミックな式。そのクロージャーは (現状では) 自由にコピーできません。
\end{itemize}

したがって、この新しい呼び出し規約を採用するために必要なのは、非アトミックな引数を自由にコピー可能なクロージャとして渡す何らかの方法を見つけることだけです。
たとえば、次の式を考えてみましょう。

\begin{verbatim}
  f (factorial 20)
\end{verbatim}

引数 \texttt{(factorial 20)} を自由にコピー可能なクロージャとして渡すにはどうすればよいですか。
解決策は簡単です。式を次の同等の形式に変換します。

\begin{verbatim}
  let arg = factorial 20 in f arg
\end{verbatim}

\texttt{let} 式は現在のフレームにクロージャ \texttt{(factorial 20)} 用のスロットを割り当て、その中に自己更新クロージャを置き、このクロージャへの (通常の) 間接指定が \texttt{f} に渡されます。
(この変換は、 \texttt{f} に渡されるクロージャーが複数回入力される可能性がある場合にのみ実行する必要があることに注意してください。
ここには、より効率的なコードを生成するためにグローバル共有分析を行う機会があります。)
\vskip\baselineskip

この変換が完了すると、引数クロージャを自由にコピーできますが、\texttt{let(rec)} バインドされたクロージャには (非更新の) 間接参照を使用する必要があります。
間接チェーンが構築されたり、同一の更新が行われることはありません。
\vskip\baselineskip

何が起こったのかを振り返るのは興味深いことです。
スーパーコンビネータ呼び出しの割り当て全体がその引数を保持するために必要なフレームであったため、最初はTIMがGマシンよりもはるかに少ないヒープを割り当てるかのように見えました。
ただし、新しい更新手法を使用すると、スーパーコンビネータ本体内のすべての部分式には、それを保持するためにフレーム内のスロットが必要であることがわかります。
同様に、スーパーコンビネータの引数のほとんどが間接引数になっているため、TIMは、引数自体ではなく引数へのポインタを渡すGマシンとまったく同じように動作します。
したがって、遅延更新の問題により、TIM はよりGマシンらしくなる必要がありました。
\vskip\baselineskip

この手法を、引数式ごとに let 式を導入するプログラム変換として紹介しましたが、これを行うには、新しい任意の変数名を考え出す必要があるため、少々面倒です。
新しいコンパイル スキームをより直接的に記述する方が簡単です。
主な変更は、図 4.5 に示す $\mathcal{R}$ スキームの関数適用ケースに対するものです。
\vskip\baselineskip

\begin{tabular} {|l|} \hline
	$\mathcal{R} \llbracket e \rrbracket ~ \rho$は、環境$\rho$の式$e$の値をスタック上の引数に適用するTIMコードです。 \\
	\\
	\begin{tabular}{l c l}
		$\mathcal{R} \llbracket e ~ a \rrbracket ~ \rho ~ d$             & $=$ & ($d_1$, \texttt{Push} ($\mathcal{A} \llbracket a \rrbracket ~ \rho$) \texttt{:} $is$)                                                            \\
		                                                                 &     & ここで、$a$ はスーパーコンビネータ、局所変数、                                                                                                   \\
		                                                                 &     & または整数であり、$d_1, ~ is$は以下の通りです。                                                                                                  \\
		                                                                 &     & $(d_1, is) = \mathcal{R} \llbracket e \rrbracket ~ \rho ~ d$                                                                                     \\
		$\mathcal{R} \llbracket e_{fun} ~ e_{arg} \rrbracket ~ \rho ~ d$ & $=$ & ($d_2$, \texttt{Move} (d + 1) $am_{arg}$ \texttt{:} \texttt{Push} (\texttt{Code} [\texttt{Enter} (\texttt{Arg} (d + 1))]) \texttt{:} $is_{fun}$) \\
		                                                                 &     & ここで、$d_1, ~ d_2, ~ am_{arg}, ~ is_{fum}$は以下の通りです。                                                                                   \\
		                                                                 &     & $(d_1, am_{arg}) = \mathcal{U} \llbracket e_{arg} \rrbracket ~ (d + 1) ~ \rho ~ (d + 1)$                                                         \\
		                                                                 &     & $(d_2, is_{fun}) = \mathcal{R} \llbracket e_{fun} \rrbracket ~ \rho ~ d_1$                                                                       \\
	\end{tabular}
	\\ \hline
	\begin{tabular}{r c l l}
		$\mathcal{A} \llbracket n \rrbracket ~ \rho$ & $=$ & \texttt{IntConst} $n$ & ここで、$n$ は整数定数です。                 \\
		$\mathcal{A} \llbracket x \rrbracket ~ \rho$ & $=$ & $\rho ~ x$            & ここで、$x$ は $\rho$ によって束縛されます。 \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

最初の定義式は、関数適用への引数がアトミック式 (変数または定数) である場合を扱い、以前と同様に $\mathcal{A}$ スキームを使用して適切なアドレッシング モードを生成します。
2番目の式は、引数が複合式である場合を扱います。 フレーム内の次の空きスロットを引数式の自己更新クロージャで初期化し、このクロージャへの間接参照をプッシュします。
\vskip\baselineskip

図4.5にも示されている $\mathcal{A}$ スキームは、引数としてアトミック式 (変数または定数) を使用してのみ呼び出されるため、以前よりもケースが1つ減りました。
同じ理由で、フレームスロットをまったく使用しないため、$d$ を引数として受け取って結果として返す必要がなくなりました。

\begin{description}
	\item[演習 4.20] この改訂されたスキームを実装し、以前のバージョンとのパフォーマンスの違いを測定します。
\end{description}

\subsubsection{部分的な関数適用の更新}

これまでのところ、値が整数であるクロージャの更新を正常に処理できました。
Return 命令が空のスタックを見つけると、更新を実行し、ダンプから新しいスタックをポップします。
\vskip\baselineskip

しかし、スタックから項目を消費する別の命令、つまり \texttt{Take} があります。
\texttt{Take} 命令でスタック上に見つかったアイテムの数が必要な数よりも少ない場合はどうなるのでしょうか?
たとえば、次のプログラムを考えてみましょう。

\begin{verbatim}
  add a b = a+b
  twice f x = f (f x)
  g x = add (x*x)
  main = twice (g 3) 4
\end{verbatim}

\texttt{twice} が \texttt{f} をenterすると、間接経由でenterされ、\texttt{f} の更新が設定されます。
この例では、\texttt{f} は \texttt{(g 3)} にバインドされ、1つの引数への加算の部分適用として評価されます。
\texttt{add} のコードの先頭にある \texttt{Take 2} 命令は、スタック上に引数が1つだけあることを検出します。
これは、更新が行われ、\texttt{(g x)} のクロージャが \texttt{(add (x*x))} のクロージャで上書きされることを示します。
\vskip\baselineskip

一般的に：

\begin{quote}
	\texttt{Take} 命令がスタック上で見つけた引数が少なすぎる場合は、ダンプ上の先頭の項目によって識別されるクロージャの更新を実行し、
	現在のスタック上の項目をダンプから回復されたスタックの先頭に貼り付けて、 (別の更新が必要な場合) \texttt{Take} 命令を再試行する必要があります。
\end{quote}

\texttt{Take} 命令はすでに十分に複雑ですが、さらに実行するタスクがあります。
\texttt{Take} が扱いにくくなるのを避けるために、\texttt{Take} を2つの命令に分割しました。
1つは十分な引数があるかどうかのチェックを実行する \texttt{UpdateMarkers} で、もう1つは新しいフレームを実際に構築する \texttt{Take} です。
\texttt{UpdateMarkers} $n$ 命令は常に、すべての \texttt{Take} $t$ $n$ 命令の直前に配置されます。
\vskip\baselineskip

したがって、\texttt{Take} の遷移規則は変更されません。
\texttt{UpdateMarkers} の遷移規則は次のとおりです。
\vskip\baselineskip

\begin{tabular} {|c|l r l r r r l l|} \hline
	(4.17) &                   & \texttt{UpdateMarkers} $n$ : $i$                                                                                       & $f$ & $c_1$ : $\ldots$ : $c_m$ : $s$ & $v$ & $d$                 & $h$  & $c$ \\
	       & $\Longrightarrow$ & $i$                                                                                                                    & $f$ & $c_1$ : $\ldots$ : $c_m$ : $s$ & $v$ & $d$                 & $h$  & $c$ \\
	       &                   & \multicolumn {7} {l|} {ここで$m \ge n$}                                                                                                                                                                \\ \hline
	(4.17) &                   & \texttt{UpdateMarkers} $n$ : $i$                                                                                       & $f$ & $c_1$ : $\ldots$ : $c_m$ : []  & $v$ & $(f_u, x, s)$ : $d$ & $h$  & $c$ \\
	       & $\Longrightarrow$ & \texttt{UpdateMarkers} $n$ : $i$                                                                                       & $f$ & $c_1$ : $\ldots$ : $c_m$ : $s$ & $v$ & $d$                 & $h'$ & $c$ \\
	       &                   & \multicolumn {7} {l|} {ここで$m < n$かつ$h' = h[f_u :\langle \ldots, d_{x - 1}, (i', f'), d_{x + 1}, \ldots \rangle]$}                                                                                 \\ \hline
\end{tabular}
\vskip\baselineskip

最初の規則は、十分な引数があるため、\texttt{UpdateMarkers} が何も行わない場合を扱います。
2番目は、更新を行う必要があるもう1つのケースを扱います。
適切なクロージャが更新され、現在のスタックが古いスタックの上に貼り付けられ、\texttt{UpdateMarkers} が再試行されます。
\vskip\baselineskip

このルールでは、$i'$ と $f'$ はターゲット クロージャを上書きするコードポインタとフレームポインタですが、これまでのところ、それらがどのような値を取るべきかについては指定されていません。
それらがどうあるべきかを理解する方法は、「クロージャ $(i', f')$ が入力されたときに何が起こるべきか?」という質問をすることです。
このクロージャは、スーパーコンビネータの引数 $c_1, \ldots, c_m$ への部分的な適用を表します。
したがって、これが入力されると、$c_1, ..., c_m$ をプッシュしてから、スーパーコンビネータのコードにジャンプする必要があります。
したがって、

\begin{itemize}
	\item $f'$ は新しく割り当てられたフレーム $\langle c_1, \ldots, c_m \rangle$ を指している必要があります。
	\item $i'$ は以下の符号列でなければなりません
	      \vskip\baselineskip
	      \texttt{Push} (\texttt{Arg} $m$) \texttt{:} $\ldots$ \texttt{:} \texttt{Push} (\texttt{Arg} 1) \texttt{:} \texttt{UpdateMarkers} $n$ \texttt{:} $i$
	      \vskip\baselineskip
	      ここで、\texttt{Push} 命令は部分アプリケーションの引数をスタックに配置し、\texttt{UpdateMarkers} 命令は実行する必要があるさらなる更新をチェックします。
	      $i$ はスーパーコンビネータのコードの残りの部分です。
\end{itemize}

\begin{description}
	\item[演習 4.21] \texttt{UpdateMarkers} 命令を実装し、各 \texttt{Take} 命令の前に1つを配置するようにコンパイラを変更します。
		次のプログラムの変更の前後で実装をテストします。
		プログラムは高階関数を使用してペアを実装します (セクション 2.8.3)。
		ペア \texttt{w} は共有され、ペア関数の部分的な適用として評価されます。
		\begin{verbatim}
          pair x y f = f x y
          fst p = p K
          snd p = p K1
          main = let w = pair 2 3
                 in (fst w) * (snd w)
        \end{verbatim}
		\texttt{w} が \texttt{(pair 2 3)} の部分適用で更新されていることがわかります。
		もう少し説得力を持たせるために、\texttt{w} の右側にもう少し計算を含めることができます。
		たとえば、
		\begin{verbatim}
          main = let w = if (2*3 > 4) (pair 2 3) (pair 3 2)
                 in (fst w) * (snd w)
        \end{verbatim}
	\item[演習 4.22] \texttt{Take 0 0} が何もしないのと同様に、\texttt{UpdateMarkers 0} も何も行いません。
		必要に応じてこれらの命令の両方を省略するように、\texttt{compileSC} を変更します。
		(これは演習 4.3 の単純な拡張です。)
\end{description}

他にも注目すべき点がいくつかあります。

\begin{itemize}
	\item 実際の実装では、ルールにあるように、更新が行われるたびにコード $i'$ が新しく製造されることはありません。
	      代わりに、スーパーコンビネータ $i$ のコードの前に一連の \texttt{Push} 命令を配置し、部分適用のコードポインタはシーケンス内の適切な場所を指すだけで済みます。
	\item \texttt{UpdateMarkers} ルールはクロージャ $c_1, \ldots, c_m$ を複製します。
	      これは、スーパーコンビネータの引数が自由にコピーできるようになったことであり、セクション 4.5.6 で導入した修正です。
	      この変更が行われる前は、そのようなコピーを作成すると redex が複製される危険があったため、代わりに \texttt{UpdateMarkers} ルールが間接化されてさらに複雑になっていたでしょう。
	      \texttt{UpdateMarkers} の導入が遅れて放置されているのはこのためです。
	\item 式 $(\texttt{f} ~ e_1 ~ e_2)$ のコードをコンパイルしているとします。ここで、\texttt{f} は 2 つ (またはそれ以下) の引数のスーパーコンビネーターであることがわかっています。
	      この場合、スタックはそれを満たすのに十分な深さがあることが確実であるため、 \texttt{f} の先頭にある \texttt{UpdateMarkers} 命令は確かに何も行いません。
	      そのため、すべての引数 (またはそれ以上) に適用されるスーパーコンビネータへの呼び出しをコンパイルするときに、\texttt{UpdateMarkers} 命令の後にそのコードを入力できます。
	      一般的なプログラムの関数適用の多くは、既知のスーパーコンビネータの飽和した関数適用であるため、この最適化は頻繁に適用できます。
\end{itemize}
\newpage

\subsection{Mark 5: 構造化データ}

このセクションでは、代数データ型を TIM に追加する方法を学習します。
セクション 2.8.3 で説明されている高階関数を使用すると、このセクションの内容をまったく使用せずにデータ構造を実装することができます。
しかし、そうするのはむしろ非効率的です。
代わりに、より一般的なデータ構造を処理できるように、算術演算に使用したアプローチを開発します。

\subsubsection{一般的なアプローチ}

\texttt{is\_empty} 関数について考えてみましょう。この関数は、引数が空のリストの場合は 1 を返し、そうでない場合は 0 を返します。
これは、それをシングルトン リストに適用するプログラムのコンテキストで与えられます。

\begin{verbatim}
  is_empty xs = case xs of
                  <1>      -> 1
                  <2> y ys -> 0
  
  cons a b = Pack{2,2} a b
  nil      = Pack{1,0}
  
  main = is_empty (cons 1 nil)
\end{verbatim}

セクション 1.1.4 でコンストラクターが \texttt{Pack\{$tag, ~ arity$\}} で表されることを思い出してください。
リストを操作するこのプログラムでは、空リストコンストラクタ \texttt{nil} にはタグ1とアリティ0があり、リストコンストラクタ \texttt{cons} にはタグ2とアリティ2があります。
パターンマッチングは \texttt{case} 式によってのみ実行されます。ネストされたパターンは、ネストされた \texttt{case} 式によって照合されます。
\vskip\baselineskip

まず、\texttt{case} 式に対してどのようなコードを生成するかを検討します。
算術演算子では引数を評価する必要があるのと同様に、\texttt{case} 式では式 (\texttt{is\_empty} の例では \texttt{xs}) を評価する必要があります。
この後、返されたオブジェクトのタグに応じて、多方向ジャンプを実行できます。
算術演算子に使用したものと同様のアプローチを採用すると、次の規則が示唆されます。

\begin{itemize}
	\item データオブジェクトを表すクロージャを評価するには、継続が引数スタックにプッシュされ、クロージャがEnterされます。
	\item (先頭)正規形に評価されると、この継続がスタックからポップされてEnterされます。
	\item データオブジェクトのタグは値スタックの一番上に返されます。
	\item データオブジェクトのコンポーネント(存在する場合)は、新しいレジスタであるデータフレームポインタが指すフレームで返されます。
\end{itemize}

したがって、\texttt{is\_empty} に対して生成するコードは次のようになります。
\footnote{いつものように、継続の明示的なラベルを使用してコードを作成しますが、
	実際には、新しいラベルの生成を避けるために、\texttt{Code} アドレッシングモードを使用するようにコンパイルします。}

\begin{verbatim}
  is_empty: Take 1 1            -- One argument
            Push (Label "cont") -- Continuation
            Enter (Arg 1)       -- Evaluate xs

  cont:     Switch [ 1 -> [PushV (IntVConst 1), Return]
                     2 -> [PushV (IntVConst 0), Return]
                   ]
\end{verbatim}

\texttt{Switch} 命令は、値スタックの最上位項目に基づいて多方向ジャンプを実行します。
この例では、\texttt{case} 式の両方の分岐が定数を返すだけです。
\vskip\baselineskip

この例では、精査されたリストセルのコンポーネントは使用されませんでした。
これは常に当てはまるわけではありません。
たとえば、\texttt{sum} 関数を考えてみましょう。

\begin{verbatim}
  sum xs = case xs of
                  <1>      -> 0
                  <2> y ys -> y + sum ys
\end{verbatim}

\texttt{sum} はリストの要素の合計を計算します。
新しい機能は、式 \texttt{y + sum ys} がリスト セルのコンポーネント \texttt{y} と \texttt{ys} を使用することです。
前に示したように、これらのコンポーネントは、データフレームポインタが指すフレーム内の継続、つまり新しいレジスタに返されます。
(演習: なぜ通常のフレームポインタをこの目的に使用できないのですか?)
\vskip\baselineskip

これまでのところ、すべてのローカル変数(つまり、スーパーコンビネータ引数または \texttt{let(rec)} 束縛変数)には、
そのクロージャを含む現在のフレーム内にスロットがあるため、このアイデアを拡張して、\texttt{y} と \texttt{ys} にさらにスロットを追加するのが論理的であると思われます。
必要なのは、クロージャをリストセルフレームから現在のフレームに移動することだけです。
\texttt{sum} のコードは次のとおりです。

\begin{verbatim}
  sum: Take 3 1            -- One argument, two extra slots for y,ys
       Push (Label "cont") -- Continuation for case
       Enter (Arg 1)       -- Evalute xs

  cont: Switch [1 -> [PushV (IntVConst 0), Return]
                2 -> [Move 2 (Data 1)
                      Move 3 (Data 2)
                      ...code to compute y + sum ys...
                     ]
               ]
\end{verbatim}

\texttt{Move} 命令は、データフレームポインタが指すフレーム内のクロージャをアドレス指定する新しいアドレス指定モード \texttt{Data} を使用します。
2つの \texttt{Move} 命令は、\texttt{y} と \texttt{ys} をリスト セルから現在のフレーム (\texttt{xs} を含むフレーム) にコピーします。
\vskip\baselineskip

要約すると、\texttt{case} 式は 5 つのステップにコンパイルされます。

\begin{enumerate}
	\item 継続をPushします。
	\item 精査するクロージャをEnterします。
	      評価されると、ステップ1でPushした継続に入ります。
	\item 継続では、\texttt{Switch} 命令を使用して、値スタックの一番上に返されるタグに基づいて多方向ジャンプを実行します。
	\item \texttt{Switch} の各ブランチは、データオブジェクトの内容を現在のフレームにコピーする \texttt{Move} 命令で始まります。
	      これはクロージャをコピーするので、データオブジェクト内のすべてのクロージャが自由にコピーできるプロパティを持っていることを確認する必要があります (セクション 4.5.6)。
	\item 各ブランチは、通常どおりにコンパイルされたそのブランチのコードを続行します。
\end{enumerate}

最後に、式 \texttt{Pack\{} $tag$ \texttt{,} $arity$ \texttt{\}} に対してどのようなコードを生成する必要があるかを尋ねることができます。
たとえば、次の式を考えてみましょう。

\[\texttt{Pack\{1,2\}} ~ e1 ~ e2\]

これによりリストセルが構築されます。
最小限のアプローチは、\texttt{Pack\{1,2\}} をスーパーコンビネータとして扱うことです。
そして、次のコードを生成します。
\footnote{原理的には、使用可能なコンストラクタは無限にあるため、コードストアには、それらに対応する類似のコードフラグメントの有限ファミリーが必要と思われます。
	実際には、詳細なコンパイルスキームを記述するときにわかるように、これは簡単に回避できます。}

\begin{verbatim}
  Push (...addressing mode for e2...)
  Push (...addressing mode for e1...)
  Enter (Label "Pack{1,2}")
\end{verbatim}

\texttt{Pack\{1,2\}} のコードは非常に単純です。

\begin{verbatim}
  Pack{1,2}: UpdateMarkers 2
             Take 2 2
             ReturnConstr 1
\end{verbatim}

最初の2つの命令は、他のスーパーコンビネータとまったく同じです。
\texttt{UpdateMarkers} 命令は必要な更新を実行し、\texttt{Take} 命令はリストセルの2つのコンポーネントを含むフレームを構築し、そのフレームへのポインタを現在のフレームポインタに置きます。
最後に、新しい命令 \texttt{ReturnConstr} が継続に入ります。
タグ1を値スタックにプッシュし、現在のフレームポインタをデータフレームポインタにコピーします。
\texttt{Return} と同様に、\texttt{ReturnConstr} は更新を確認し、必要に応じて実行する必要があります。

\subsubsection{データ構造の遷移規則とコンパイル方式}

概要が完成したので、新しい構成の遷移規則とコンパイルスキームの詳細を説明します。
\texttt{Switch} の遷移規則は以下の通りです。
\vskip\baselineskip

\begin{tabular} {|c|l r l l r r r l l|} \hline
	(4.18) &                   & $[\texttt{Switch} ~ [\ldots ~ t ~ \texttt{->} ~ i ~ \ldots]]$ & $f$ & $f_d$ & $s$ & $t$ : $v$ & $d$ & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                                                           & $f$ & $f_d$ & $s$ & $v$       & $d$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{ReturnConstr} には更新が必要になる可能性を考慮する必要があるため、2つの遷移規則があります。
最初の方法は簡単で、更新を行う必要がない場合です。
\vskip\baselineskip

\begin{tabular} {|c|l r l l r r r l l|} \hline
	(4.19) &                   & $[\texttt{ReturnConstr} ~ t]$ & $f$ & $f_d$ & $(i, f')$ : $s$ & $v$       & $d$ & $h$ & $c$ \\
	       & $\Longrightarrow$ & $i$                           & $f$ & $f$   & $s$             & $t$ : $v$ & $d$ & $h$ & $c$ \\ \hline
\end{tabular}
\vskip\baselineskip

2番目のルールは更新を扱い、\texttt{ReturnConstr} 命令とデータフレームポインタのみを含むコードシーケンスで更新されるクロージャを上書きします。
\vskip\baselineskip

\begin{tabular} {|c|l r l l r r r l l|} \hline
	(4.20) &                   & $[\texttt{ReturnConstr} ~ t]$                                                                                                     & $f$ & $f_d$ & []  & $v$ & $(f_u, x, s)$ : $d$ & $h$  & $c$ \\
	       & $\Longrightarrow$ & $[\texttt{ReturnConstr} ~ t]$                                                                                                     & $f$ & $f$   & $s$ & $v$ & $d$                 & $h'$ & $c$ \\
	       &                   & \multicolumn {8} {l|} {ここで$h' = h[f_u :\langle \ldots, d_{x - 1}, ([\texttt{ReturnConstr} t], f), d_{x + 1}, \ldots \rangle]$}                                                              \\ \hline
\end{tabular}
\vskip\baselineskip

コンパイルスキームに対する唯一の変更は、コンストラクタと \texttt{case} 式の $\mathcal{R}$ スキームに特別なケースを追加することです。
後者は、\texttt{case} の選択肢をコンパイルする補助スキーム $\mathcal{E}$ を使用して構造化されています (図 4.6)。
コンストラクタは、検出されると「インライン」でコンパイルされるため、無限の定義ファミリーをコードストアに追加する必要がなくなります。

\vskip\baselineskip

\begin{tabular} {|l|} \hline
	\begin{tabular}{l c l}
		$\mathcal{R} \llbracket \texttt{Pack\{} t, ~ a \texttt{\}} \rrbracket ~ \rho ~ d$                       & $=$ & ($d$, [\texttt{UpdateMarkers} $a$, \texttt{Take} $a$ $a$, \texttt{ReturnConstr} $t$])                      \\
		$\mathcal{R} \llbracket \texttt{case} ~ e ~ \texttt{of} ~ alt_1 ~ \ldots ~ alt_n \rrbracket ~ \rho ~ d$ & $=$ & ($d'$, \texttt{Push} (\texttt{Code} [\texttt{Switch} [$branch_1 ~ \ldots ~ branch_n$]]) \texttt{:} $is_e$) \\
		                                                                                                        &     & ここで、$d_1, ~ \ldots, ~ d_n, ~ d', ~ is_e$は以下の通りです。                                             \\
		                                                                                                        &     & $(d_1, ~ branch_1) = \mathcal{E} \llbracket alt_1 \rrbracket ~ \rho ~ d)$                                  \\
		                                                                                                        &     & $\dots$                                                                                                    \\
		                                                                                                        &     & $(d_n, ~ branch_n) = \mathcal{E} \llbracket alt_n \rrbracket ~ \rho ~ d)$                                  \\
		                                                                                                        &     & $(d', ~ is_e) = \mathcal{R} \llbracket e \rrbracket ~ \rho ~ max(d_1, ~ \ldots, ~ d_n)$                    \\
	\end{tabular}
	\\ \hline
	$\mathcal{E} \llbracket alt \rrbracket ~ \rho ~ d$ ($alt$ は \texttt{case} の選択肢) はペア $(d', ~ branch)$ です。 \\
	ここで $branch$ は、環境 $\rho$ でコンパイルされた \texttt{Switch} の選択肢です。                                   \\
	このコードは、フレームの最初の $d$ スロットが占有されていると仮定し、                                               \\
	スロット $(d + 1, ~ \ldots, ~ d')$ を使用します。                                                                   \\
	\\
	\begin{tabular}{l c l}
		$\mathcal{E} \llbracket \texttt{<} t \texttt{>} ~ x_1 ~ \ldots ~ x_n ~ \texttt{->} ~ body \rrbracket ~ \rho ~ d$ & $=$ & ($d'$, $t$ \texttt{->} ($is_{moves}$ \texttt{++} $is_{body}$))                                            \\
		                                                                                                                 &     & ここで、$d', ~ is_{moves}, ~ is_{body}$は以下の通りです。                                                 \\
		                                                                                                                 &     & $is_{moves}$ = [\texttt{Move} (d + 1) (\texttt{Data} 1), \ldots, \texttt{Move} (d + n) (\texttt{Data} n)] \\
		                                                                                                                 &     & $\dots$                                                                                                   \\
		                                                                                                                 &     & $(d', ~ is_{body}) = \mathcal{R} \llbracket body \rrbracket ~ \rho' ~ (d + n)$                            \\
		                                                                                                                 &     & $\rho' = [x_1 \mapsto \texttt{Arg} ~ (d + 1), ~ \ldots, ~ x_n \mapsto \texttt{Arg} ~ (d + n)]$            \\
	\end{tabular}
	\\ \hline
\end{tabular}
\vskip\baselineskip

\subsubsection{試してみる}

次の追加のコア言語定義を使用することで、新しい機構を使用してリストとブール値を実装できます。

\begin{verbatim}
  cons = Pack{2,2}
  nil  = Pack{1,0}

  true  = Pack{2,0}
  false = Pack{1,0}
  if cond tbranch fbranch = case cond of
                                  <1> -> fbranch
                                  <2> -> tbranch
\end{verbatim}

\texttt{if} は、以前はコンパイルスキームに特別な命令とケースを持っていましたが、現在は他の定義と同様に単なるスーパーコンビネータ定義であることに注意してください。
それでも、多くの場合、\texttt{case} よりも \texttt{if} を使用してプログラムを作成する方が明確なので、コンパイラに特別なケースを残しておきたい場合があります。
ただし、今度は \texttt{Cond} 命令ではなく \texttt{Switch} 命令を生成します。
(後者は消える可能性があります。)

\begin{description}
	\item[演習 4.23] 新しい命令とコンパイル スキームを実装します。
		次のプログラムで新しい実装をテストします。
		\begin{verbatim}
      length xs = case xs of
                      <1> -> 0
                      <2> p ps -> 1 + length ps

      main = length (cons 1 (cons 2 nil))
    \end{verbatim}
		更新コードが正しく機能するかどうかを示す、より興味深い例は次のとおりです。
		\begin{verbatim}
      append xs ys = case xs of
                      <1>      -> ys
                      <2> p ps -> cons p (append ps ys)

      main = let xs = append (cons 1 nil) (cons 2 nil)
             in
             length xs + length xs
    \end{verbatim}
		ここでは \texttt{xs} が2回使用されていますが、\texttt{append} の作業は1回だけ行う必要があります。

	\item[演習 4.24] コンストラクタのアリティ $a$ が 0 の場合、
		$\mathcal{R} \llbracket \texttt{Pack\{} t, ~ a \texttt{\}} \rrbracket$ はコード \texttt{[UpdateMarkers 0, Take 0 0, ReturnConstr t]} を生成します。
		この場合に適したコードを生成するには、$\mathcal{R}$ スキームと \texttt{compileR} 関数を最適化します (演習 4.22 を参照)。
\end{description}

\subsubsection{リストの表示}

これまでに提案したサンプル プログラムはすべて整数を返しましたが、代わりにリストを返して出力できると便利です。
\vskip\baselineskip

Gマシンの章でこれを表現した方法は、出力の末尾に数字を追加する \texttt{Print} 命令とともに、出力を表す追加のコンポーネントをマシン状態に追加することでした。
この場合、数値は値スタックで返されるため、\texttt{Print} は値スタックから数値を消費し、それを出力に追加します。

現在、コンパイルは継続 \texttt{([], FrameNull)} を使用してスタックを初期化します。
これにより、この継続がEnterされるとマシンが停止します。
必要なのは、この継続を変更して印刷を行うことだけです。
今回は、継続ではプログラムの値がリストであることを期待しているため、処理方法を決定するためにケース分析を行う必要があります。
リストが空の場合、マシンは停止する必要があるため、そのブランチには空のコードシーケンスだけを含めることができます。
それ以外の場合は、リストの先頭が評価されて出力され、その後、末尾に元の継続が再度与えられる必要があります。
コードは次のとおりです。

\begin{verbatim}
  topCont:    Switch [ 1 -> []
                       2 -> [ Move 1 (Data 1)         -- Head
                              Move 2 (Data 2)         -- Tail
                              Push (Label "headCont")
                              Enter (Arg 1)           -- Evaluate head
                            ]
                     ]

  headCont:   Print
              Push (Label "topCont")
              Enter (Arg 2)                           -- Do the same to tail
\end{verbatim}

\texttt{topCont} コードには作業用ストレージとして2スロットフレームが必要であり、\texttt{compile} でそれを提供する方がよいことに注意してください。
したがって、\texttt{compile} は次の継続でスタックを初期化します。

\begin{verbatim}
  (topCont, frame)
\end{verbatim}

ここで、\texttt{topCont} は上記のコードシーケンス、\texttt{frame} はヒープから割り当てられた2スロットフレームのアドレスです。

\begin{description}
	\item[演習 4.25] 説明に従ってリストの表示を実装します。
		唯一面倒な点は、マシンの状態に追加のコンポーネントを(再度)追加する必要があることです。

		いつものように、\texttt{Push (Label "headCont")} の代わりに \texttt{Push (Code ...)} を使用できます。
		実際、少し再帰を使用することで、\texttt{Push (Label "topCont")} に対しても同じことができます。

		次のプログラムで作業をテストします。

		\begin{verbatim}
      between n m = if (n>m) nil (cons n (between (n+1) m))
      main = between 1 4
    \end{verbatim}

	\item[演習 4.26] 結果がリストであるプログラムを実行する場合、リストの要素が使用可能になったらすぐに出力できると便利です。
		現在の実装では、すべての状態を出力するか(\texttt{showFullResults} を使用する場合)、最後の状態のみを出力します(\texttt{showResults} を使用する場合)。
		前者の場合は非常に多くの出力が得られますが、後者の場合はプログラムが終了するまでまったく出力が得られません。

		\texttt{showResults} を変更して、生成された出力を印刷するようにします。
		これを行う最も簡単な方法は、連続する状態のペアの出力コンポーネントを比較し、ある状態と次の状態の間で出力が長くなったときに最後の要素を出力することです。

		\texttt{showResults} に対するもう1つの可能な変更は、各状態(または10個の状態)のドットを出力して、各出力ステップ間でどれだけの作業が行われたかを大まかに示すことです。
\end{description}

\subsubsection{データ構造を直接使用する \dag}

\texttt{Move} 以外の命令でデータアドレッシングモードを使用して、\texttt{Switch} 命令のアーム内でデータ構造のコンポーネントを直接使用できないのはなぜかと疑問に思う人もいるかもしれません。
理由は \texttt{sum} の例でわかります。これをここで繰り返します。

\begin{verbatim}
  sum xs = case xs of
                  <1>      -> 0
                  <2> y ys -> y + sum ys
\end{verbatim}

ここで、\texttt{y + sum ys} のコードをもう少し詳しく見てみましょう。
このコードは最初に \texttt{y} を評価する必要がありますが、これには大量の計算が必要となる可能性があり、必ずデータフレームポインタレジスタを使用します。
したがって、\texttt{ys} を評価する時点までに、データフレームポインタは変更されているため、データフレームポインタを介して \texttt{ys} にアクセスできなくなります。
リストセルの内容を現在のフレームに移動することにより、それらをさらに評価しても保存できるようになります。
\vskip\baselineskip

\texttt{head} 関数のように、それ以上の評価が行われない場合があります。

\begin{verbatim}
  head xs = case xs of
                  <1>      -> error
                  <2> y ys -> y
\end{verbatim}

この場合、最適化として、データフレームから \texttt{y} を直接使用できます。
つまり、\texttt{Switch} 命令の2番目の分岐は単純に \texttt{[Enter (Data 1)]} になります。
\vskip\baselineskip

同様に、変数が \texttt{case} 式の分岐でまったく使用されていない場合、その変数を現在のフレームに移動する必要はありません。
\newpage

\subsection{Mark 6: CAFとコードストア \dag}

前に述べたように (セクション 4.2.3)、コードストアを名前とコードシーケンスの関連付けリストとして表すという決定は、CAFが更新されないことを意味します。
代わりに、呼び出されるたびにコードが実行されるため、作業が重複する可能性があります。
この余分な作業は避けたいのですが、TIM の解決策は以前の実装ほど簡単ではありません。
\vskip\baselineskip

テンプレートインスタンス化マシンとGマシンの場合、解決策は各スーパーコンビネータを表すためにヒープ内にノードを割り当てることでした。
CAFが呼び出されるとき、redexのルートはスーパーコンビネータノード自体であるため、ノードはリダクションの結果(つまり、スーパーコンビネータ定義の右側のインスタンス)で更新されます。
その後スーパーコンビネータを使用すると、元のスーパーコンビネータではなく、この更新されたノードが表示されます。
問題は、TIMにはヒープノードがまったくないことです。
ノードに対応するのはフレーム内のクロージャです。
したがって、私たちがしなければならないことは、初期ヒープに、各スーパーコンビネータのクロージャを含む単一の巨大なフレーム、つまり\textbf{グローバルフレーム}を割り当てることです。
\vskip\baselineskip

コードストアは、スーパーコンビネータ名をフレーム内のオフセットにマッピングする関連付けリスト $g$ とともに、グローバルフレームのアドレス $f_G$ によって表されます。
\texttt{Label} アドレッシングモードは、この関連リストを使用してオフセットを見つけ、スーパーコンビネータのクロージャをグローバルフレームからフェッチします。
\texttt{Push Label} の新しい遷移規則は、これらのアイデアを正式なものとします。
\vskip\baselineskip

(4.21) \\
\begin{tabular} {|l r l r l l|} \hline
	                  & \texttt{Push} (\texttt{Label} $l$) : $i$ & $f$ & $s$                  & $h$[$f_G$ : $\langle (i_1, f_1), \ldots, (i_n, f_n) \rangle$] & ($f_G$, $g$[$l$ : $k$]) \\
	$\Longrightarrow$ & $i$                                      & $f$ & ($i_k$, $f_k$) : $s$ & $h$                                                           & ($f_G$, $g$)            \\ \hline
\end{tabular}
\vskip\baselineskip

\texttt{Enter Label} のルールは、\texttt{Push}/\texttt{Enter} 関係から直接に従います。
セクション 4.5.5 の \texttt{let(rec)} バインド変数のコンテキストで説明したように、グローバルフレーム内の各クロージャは自己更新クロージャです。
\texttt{let(rec)} でバインドされた変数と同様に、スーパーコンビネータをスタックにプッシュするときは、(非更新の) 間接指定を使用する必要があります (セクション 4.5.5)。

\subsubsection{CAF の実装}
\subsubsection{コードストアをより忠実にモデリングする}
\newpage

\subsection{まとめ}

最終的な TIM コンパイルスキームを図 4.7 と 4.8 にまとめます。
明らかな疑問は、「TIMはGマシンより優れているのか、それとも劣っているのか?」ということです。
答えるのは難しいです。
私たちのプロトタイプは、設計の選択を検討するのには非常に役立ちますが、本格的なパフォーマンスの比較には全く役に立ちません。
たとえば、Gマシン \texttt{Mkap} と比較した \texttt{Take} 命令の相対コストをどのように確立できるでしょうか?
実際に比較できる唯一の尺度は、この2つのヒープ消費量です。
\vskip\baselineskip

それでも、この章で行ったように、別の評価モデルを検討することは、TIMの側面とGマシンの側面を組み合わせた他の設計手段を示唆するため、非常に啓発的です。
そうする試みの1つがスパインレスタグレスGマシンです [Peyton Jones and Salkild 1989, Peyton Jones 1991]。
これは TIM のスパインレスと更新メカニズムを採用していますが、そのスタックは (G マシンと同様に) ヒープオブジェクトへのポインタで構成されています。
(TIM のような) コードとフレームのペアではありません。

\newpage

\begin{verbatim}
  module ParGM where
  import Utils
  import Language
  --import GM
\end{verbatim}
\newpage

\section{並列Gマシン}

\subsection{Introduction}

この章では、並列Gマシン用の抽象マシンとコンパイラを開発します。
これは、ESPRITプロジェクト415の一部として開発された並列Gマシンの簡易バージョンに基づいています。
興味のある読者は、簡単にアクセスできる[Kingdon et al 1991]を参照してください。
[Peyton Jones 1989]では、並列グラフ簡約の一般的な紹介を見つけることができます。

\subsubsection{Parallel functional programming}
\subsubsection{Parallel graph reduction}
\newpage

\subsection{Mark 1: A minimal parallel G-machine}
\subsubsection{Data type definitions}
\subsubsection{The evaluator}
\subsubsection{Compiling a program}
\subsubsection{Printing the results}
\newpage

\subsection{Mark 2: The evaluate-and-die model}
\subsubsection{The node data structure}
\subsubsection{The instruction set}
\newpage

\subsection{Mark 3: A realistic parallel G-machine}
\subsubsection{Scheduling policy}
\subsubsection{Conservative and speculative parallelism}
\newpage

\subsection{Mark 4: A better way to handle blocking}
\subsubsection{Data structures}
\subsubsection{Locking and unlocking}
\newpage

\subsection{結論}

この章では、原則として、遅延関数型言語の共有メモリ実装は簡単であることを示しました。
もちろん、Mark 1 マシンで最初に使用した単純なスキームの最適化を慎重に検討することで得られる利益があることもわかりました。
すべての並列マシンにおいて、グラフは通信および同期媒体として機能します。
また、Mark 2 および Mark 3 マシンでは、ヒープ内のロックされたノードにアクセスしようとすると、個々のプロセスがブロックされます。
\vskip\baselineskip

それでは、遅延関数型言語の並列実装における現在の課題はどこにあるのでしょうか?
本書に含まれる並列処理のメカニズムでは、プロセスの削除は処理されません。
投機的な並列処理を使用する場合は、現実的な実装でこの問題に対処する必要があります。
一方、非投機的並列処理を見つけることは多くの場合困難であり、大規模なプログラムではこれが困難になる場合もあります。
この目的のために抽象的な解釈を使用する試みがなされており、その結果は有望に見えますが、暫定的なものとみなされるべきです。

私たちがカバーしていない最後の領域の 1 つは、分散メモリ並列マシンの領域です。
繰り返しますが、原理的には共有メモリマシンに似ていますが、実際の機能はまったく異なります。
デッドロックを回避するようにメッセージの受け渡しを調整するのは、一種の黒魔術です。
\newpage

\section{ラムダリフティング}

この章では、本書で以前に見たマシンに受け入れられる一連のプログラムを拡張する方法を見ていきます。
導入する拡張機能は、\textbf{ローカル関数定義}を許可することです。
次に、代替アプローチに直面します。

\begin{itemize}
	\item 環境に対処するためのメカニズムをマシンに追加します。
	\item ローカル関数定義がないようにプログラムを変換します。
	      代わりに、すべての関数がスーパー コンビネータとして定義されます。
\end{itemize}

この本では、常に2番目のアプローチが取られると想定してきました。

この章は、\textbf{完全なlaziness}の概念を紹介する適切なポイントでもあります。
ここでも、関数型言語のこの望ましい最適化は、プログラム変換を使用して実現されます。

\subsection{Introduction}
\newpage

\subsection{Improving the \texttt{expr} data type}

\begin{verbatim}
  module Lambda where
  import Utils
  import Language
\end{verbatim}
\newpage

\subsection{Mark 1: A simple lambda lifter}
\subsubsection{Implementing a simple lambda lifter}
\subsubsection{Free variables}
\subsubsection{Generating supercombinators}
\subsubsection{Making all the variables unique}
\subsubsection{Collecting supercombinators}
\newpage

\subsection{Mark 2: Improving the simple lambda lifter}
\subsubsection{Simple extensions}
\subsubsection{Eliminating redundant supercombinators}
\subsubsection{Eliminating redundant local definitions}
\newpage

\subsection{Mark 3: Johnsson-style lambda lifter}
\subsubsection{implementation}
\subsubsection{Abstracting free variables in functions}
\subsubsection{A tricky point \dag}
\newpage

\subsection{Mark 4: A separate full laziness pass}
\subsubsection{A review of full laziness}
\subsubsection{Full-lazy lambda lifting in the presence of \texttt{let(rec)}s}
\subsubsection{Full laziness without lambda lifting}
\subsubsection{A full lazy lambda lifter}
\subsubsection{Separating the lambdas}
\subsubsection{Adding level numbers}
\subsubsection{Identifying MFEs}
\subsubsection{Renaming variables}
\subsubsection{Floating \texttt{let(rec)} expressions}
\newpage

\subsection{Mark 5: Improvements to full laziness}
\subsubsection{Adding \texttt{case} expressions}
\subsubsection{Eliminating redundant supercombinators}
\subsubsection{Avoiding redundant full laziness}
\newpage

\subsection{Mark 6: Dependency analysis \dag}
\subsubsection{Strongly connected components}
\subsubsection{Implementing a strongly connected component algorithm}
\subsubsection{A dependency analysis}
\newpage

\subsection{結論}

完全な遅延評価に対する私たちのアプローチを、同様の問題を扱ったBirdの非常に優れた論文 [Bird 1987] と比較するのは興味深いことです。
Bird の目的は、初期仕様を連続的に変換することによって、効率的な完全遅延ラムダ リフターを正式に開発することです。
結果として得られるアルゴリズムはかなり複雑で、直接書き出すのは難しいため、正式な開発の努力は十分に正当化されます。
\vskip\baselineskip

対照的に、私たちはアルゴリズムを多数の非常に単純なフェーズの構成として表現しており、各フェーズは簡単に指定して直接書き出すことができます。
結果として得られるプログラムは、式を何度も走査するため、定数因数の非効率性を伴います。
これは、連続するパスを 1 つの関数に折りたたんで、中間データ構造を排除することで簡単に削除できます。
Bird の変換とは異なり、これは簡単なプロセスです。
\vskip\baselineskip

私たちのアプローチにはモジュール式であるという大きな利点があります。
例えば：

\begin{itemize}
	\item いくつかの場合 (\texttt{freeVars}、\texttt{rename}、\texttt{collectSCs} など) に既存の関数を再利用することができました。
	\item マルチパスアプローチは、各パスに明確な単純な目的があることを意味し、変更が容易になります。
	      たとえば、完全な遅延評価が導入される場所についてより選択的になるように、\texttt{identifyMFEs} アルゴリズムを変更しました (セクション 6.7.3)。
	\item 主要フェーズをさまざまに組み合わせて使用し、さまざまな変換を「スナップ」することができます。
	      たとえば、トップレベルで適切な関数を構成するだけで、依存関係分析と完全な遅延処理を実行するかどうか、およびどのラムダ リフターを使用するかを選択できます。
\end{itemize}

私たちのアプローチの主な欠点は、Hughes が提案した 1 つの最適化、つまりパラメータをスーパーコンビネータに順序付けして MFE の数を減らすことができないことです。
その理由は、最適化ではラムダ リフティングを MFE 識別のプロセスに組み込むことが絶対に必要である一方で、これらのアクティビティを慎重に分離しているためです。
私たちにとって幸いなことに、この最適化によって作成されたより大きな MFE は常に部分的なアプリケーションであり、
作業が共有されないため、おそらく MFE として識別されるべきではありません (セクション 6.7.3)。
それでも、事態はそれほど偶然に起こったわけではないかもしれません。
関心事の分離により、ある種の変革がかなり困難になっているのは確かです。
\newpage

\section{A ユーティリティモジュール}

このAppendixでは、本全体で使用されるさまざまな便利な型と関数の定義を示します。

\begin{verbatim}
  module Utils where
\end{verbatim}

\begin{verbatim}
  -- The following definitions are used to make some synonyms for routines
  -- in the Gofer prelude to be more Miranda compatible
  shownum n = show n
  hd :: [a] -> a
  hd = head -- in Gofer standard prelude
  tl :: [a] -> [a]
  tl = tail -- in Gofer standard prelude
  zip2 :: [a] -> [b] -> [(a,b)]
  zip2 = zip -- in Gofer standard prelude
  -- can't do anything about # = length, since # not binary.
\end{verbatim}

\subsection{The heap type}

抽象データ型の\texttt{heap}と\texttt{address}は、実装ごとにガベージコレクションされたノードのヒープを表すために使用されます。

\subsubsection{Specification}
\subsubsection{Representation}
\newpage

\subsection{The association list type}

\subsection{Generating unique names}
\subsubsection{Representation}
\newpage

\subsection{Sets}
\subsubsection{Representation}
\newpage

\subsection{Other useful function definitions}
\newpage

\section{B コア言語プログラムの例}

このAppendixでは、この本で開発された実装のいくつかをテストするのに役立ついくつかのコア言語プログラムを示します。
それらは、プレリュード(セクション 1.4)で定義された関数が定義されていると想定しています。

\subsection{基本プログラム}

このセクションのプログラムでは、整数定数と関数の適用のみが必要です。

\subsubsection{超基本テスト}

このプログラムは、かなり早く値 3 を返すはずです!

\begin{verbatim}
  main = I 3
\end{verbatim}

次のプログラムでは、3 を返す前にさらにいくつかの手順が必要です。

\begin{verbatim}
  id = S K K ;
  main = id 3
\end{verbatim}

これはかなりの数の \texttt{id} の関数適用を作成します (いくつ?)。

\begin{verbatim}
  id = S K K ;
  main = twice twice twice id 3
\end{verbatim}

\subsubsection{更新のテスト}

このプログラムは、更新を行うシステムと行わないシステムの違いを示すはずです。
更新が発生した場合、\texttt{(I I I)}の評価は1回だけ行う必要があります。
更新しないと、2 回行われます。

\begin{verbatim}
  main = twice (I I I) 3
\end{verbatim}

\subsubsection{もっと興味深い例}

この例では、リストの関数表現(セクション2.8.3を参照)を使用して\texttt{4}の無限リストを作成し、
次にその2番目の要素を取ります。
headとtailの関数 (\texttt{hd}と\texttt{tl}) は、引数が空のリストの場合、\texttt{abort}を返します。
\texttt{abort}スーパーコンビネータは、無限ループを生成するだけです。

\begin{verbatim}
  cons a b cc cn = cc a b ;
  nil      cc cn = cn ;
  hd list = list K abort ;
  tl list = list K1 abort ;
  abort = abort ;
  infinite x = cons x (infinite x) ;
  main = hd (tl (infinite 4))
\end{verbatim}
\newpage

\subsection{\texttt{let}と\texttt{letrec}}

更新が実装されている場合、\texttt{id1}の評価が共有されるため、
このプログラムは実装されていない場合よりも少ないステップで実行されます。

\begin{verbatim}
  main = let id1 = I I I
         in id1 id1 3
\end{verbatim}

ネストされた\texttt{let}式もテストする必要があります。

\begin{verbatim}
  oct g x = let h = twice g
            in let k = twice h
            in k (k x) ;
  main = oct I 4
\end{verbatim}

次のプログラムは、以前の\texttt{cons}や\texttt{nil}などの定義に基づく「関数リスト」を使用して、
\texttt{letrec}をテストします。

\begin{verbatim}
  infinite x = letrec xs = cons x xs
               in xs ;
  main = hd (tl (tl (infinite 4)))
\end{verbatim}
\newpage

\subsection{算術演算}

\subsubsection{条件分岐なし}

まずは、条件式を必要としない簡単なテストから始めます。

\begin{verbatim}
  main = 4*5+(2-5)
\end{verbatim}

この次のプログラムは、正しく動作させるために関数呼び出しが必要です。
\texttt{twice twice}を\texttt{twice twice twice}または\texttt{twice twice twice twice}に置き換えてみてください。
どのような結果になるかを予想してください。

\begin{verbatim}
  inc x = x+1;
  main = twice twice inc 4
\end{verbatim}

再び関数型リストを使って、length関数を書きます。

\begin{verbatim}
  length xs = xs length1 0 ;
  length1 x xs = 1 + (length xs) ;
  main = length (cons 3 (cons 3 (cons 3 nil)))
\end{verbatim}

\subsubsection{条件分岐あり}

条件分岐ができれば、ようやく「面白い」プログラムが書けるようになります。
例えば、階乗。

\begin{verbatim}
  fac n = if (n==0) 1 (n * fac (n-1)) ;
  main = fac 5
\end{verbatim}

次のプログラムは、ユークリッドのアルゴリズムを用いて、2つの整数の最大公約数を計算するものです。

\begin{verbatim}
  gcd a b = if (a==b)
                  a
            if (a<b) (gcd b a) (gcd b (a-b)) ;
  main = gcd 6 10
\end{verbatim}

\texttt{nfib}関数は、その結果（整数）が、実行中に何回関数が呼び出されたかをカウントしてくれるから面白いです。
そのため、結果を実行時間で割ると、1秒あたりの関数呼び出し回数で性能を表すことができます。
その結果、\texttt{nfib}はベンチマークとしてかなり広く使われています。
しかし、特定の実装の「nfib-number」は、様々な特殊な最適化に決定的に依存しているため、非常に大きな塩梅で受け取る必要があります。

\begin{verbatim}
  nfib n = if (n==0) 1 (1 + nfib (n-1) + nfib (n-2)) ;
  main = nfib 4
\end{verbatim}

\subsection{データ構造}

このプログラムは、降順の整数のリストを返します。
評価者は、プログラムの結果としてリストを期待する必要があります。
\texttt{cons}と\texttt{nil}は、それぞれ\texttt{Pack\{2,2\}}と\texttt{Pack\{1,0\}}としてプレリュードに実装されることが期待されています。

\begin{verbatim}
  downfrom n = if (n == 0)
                    nil
                    (cons n (downfrom (n-1))) ;
  main = downfrom 4
\end{verbatim}

次のプログラムは、エラトステネスのふるいを実装して素数の無限リストを生成し、結果リストの最初のいくつかの要素を取ります。
出力が生成されたときにインクリメンタルに出力されるように調整する場合は、\texttt{take}の呼び出しを削除して、無限リストを出力するだけで済みます。

\begin{verbatim}
  main = take 3 (sieve (from 2)) ;

  from n = cons n (from (n+1)) ;

  sieve xs = case xs of
                  <1> -> nil ;
                  <2> p ps -> cons p (sieve (filter (nonMultiple p) ps)) ;

  filter predicate xs
          = case xs of
                  <1> -> nil ;
                  <2> p ps -> let rest = filter predicate ps
                              in
                              if (predicate p) (cons p rest) rest ;

  nonMultiple p n = ((n/p)*p) ~= n ;

  take n xs = if (n==0)
                  nil
                  (case xs of
                          <1> -> nil ;
                          <2> p ps -> cons p (take (n-1) ps))
\end{verbatim}

\end{document}
